{"version":3,"sources":["webpack://examples/webpack/universalModuleDefinition","webpack://examples/webpack/bootstrap","webpack://examples/wrapper.js","webpack://examples/misc.js","webpack://examples/polyfills.js","webpack://examples/core.js","webpack://examples/markerFunctions.js","webpack://examples/arrayUtils.js","webpack://examples/conversions.js","webpack://examples/long.js","webpack://examples/rtti.js","webpack://examples/./kotlin-dce/runtime/Enum.kt","webpack://examples/arrayUtils.kt","webpack://examples/primitiveCompanionObjects.kt","webpack://examples/./kotlin-dce/generated/_Arrays.kt","webpack://examples/./kotlin-dce/generated/_Ranges.kt","webpack://examples/./kotlin-dce/kotlin/UByte.kt","webpack://examples/./kotlin-dce/kotlin/UInt.kt","webpack://examples/./kotlin-dce/kotlin/UShort.kt","webpack://examples/Ranges.kt","webpack://examples/./kotlin-dce/collections/Collections.kt","webpack://examples/./kotlin-dce/collections/Maps.kt","webpack://examples/./kotlin-dce/collections/Sets.kt","webpack://examples/./kotlin-dce/text/StringNumberConversions.kt","webpack://examples/./kotlin-dce/generated/_Collections.kt","webpack://examples/Iterators.kt","webpack://examples/ProgressionIterators.kt","webpack://examples/Progressions.kt","webpack://examples/./kotlin-dce/kotlin/UnsignedUtils.kt","webpack://examples/Collections.kt","webpack://examples/Range.kt","webpack://examples/Unit.kt","webpack://examples/./kotlin-dce/internal/progressionUtil.kt","webpack://examples/./kotlin-dce/kotlin/builtins.kt","webpack://examples/./kotlin-dce/kotlin/coroutines/CoroutineImpl.kt","webpack://examples/./kotlin-dce/util/Standard.kt","webpack://examples/./kotlin-dce/util/Result.kt","webpack://examples/./kotlin-dce/coroutines/Continuation.kt","webpack://examples/./kotlin-dce/util/Preconditions.kt","webpack://examples/./kotlin-dce/kotlin/coroutines/intrinsics/IntrinsicsJs.kt","webpack://examples/./kotlin-dce/generated/_ArraysJs.kt","webpack://examples/./kotlin-dce/kotlin/collections.kt","webpack://examples/./kotlin-dce/kotlin/kotlin.kt","webpack://examples/./kotlin-dce/kotlin/collections/AbstractMutableCollection.kt","webpack://examples/./kotlin-dce/kotlin/collections/AbstractMutableList.kt","webpack://examples/./kotlin-dce/kotlin/collections/AbstractMutableMap.kt","webpack://examples/./kotlin-dce/kotlin/collections/AbstractMutableSet.kt","webpack://examples/./kotlin-dce/kotlin/collections/ArrayList.kt","webpack://examples/./kotlin-dce/kotlin/collections/EqualityComparator.kt","webpack://examples/./kotlin-dce/kotlin/collections/HashMap.kt","webpack://examples/./kotlin-dce/kotlin/collections/HashSet.kt","webpack://examples/./kotlin-dce/kotlin/collections/InternalHashCodeMap.kt","webpack://examples/./kotlin-dce/kotlin/collections/InternalStringMap.kt","webpack://examples/./kotlin-dce/kotlin/collections/LinkedHashMap.kt","webpack://examples/./kotlin-dce/kotlin/console.kt","webpack://examples/./kotlin-dce/kotlin/coroutines/SafeContinuationJs.kt","webpack://examples/./kotlin-dce/kotlin/exceptionUtils.kt","webpack://examples/./kotlin-dce/kotlin/exceptions.kt","webpack://examples/./kotlin-dce/kotlin/math.kt","webpack://examples/./kotlin-dce/kotlin/numbers_js-v1.kt","webpack://examples/./kotlin-dce/kotlin/numbers.kt","webpack://examples/./kotlin-dce/kotlin/random/PlatformRandom.kt","webpack://examples/./kotlin-dce/kotlin/reflect/JsClass.kt","webpack://examples/./kotlin-dce/kotlin/reflect/KClassImpl.kt","webpack://examples/./kotlin-dce/kotlin/collections/InternalMap.kt","webpack://examples/./kotlin-dce/kotlin/jsOperators.kt","webpack://examples/./kotlin-dce/kotlin/text/string.kt","webpack://examples/./kotlin-dce/kotlin/reflect/primitives.kt","webpack://examples/./kotlin-dce/kotlin/reflect/reflection.kt","webpack://examples/./kotlin-dce/kotlin/text/StringBuilderJs.kt","webpack://examples/./kotlin-dce/kotlin/text/char.kt","webpack://examples/./kotlin-dce/kotlin/text/numberConversions.kt","webpack://examples/./kotlin-dce/kotlin/Comparator.kt","webpack://examples/./kotlin-dce/generated/_ComparisonsJs.kt","webpack://examples/./kotlin-dce/collections/AbstractCollection.kt","webpack://examples/./kotlin-dce/collections/AbstractList.kt","webpack://examples/./kotlin-dce/generated/_Strings.kt","webpack://examples/./kotlin-dce/text/Strings.kt","webpack://examples/./kotlin-dce/collections/AbstractMap.kt","webpack://examples/./kotlin-dce/collections/AbstractSet.kt","webpack://examples/./kotlin-dce/collections/IndexedValue.kt","webpack://examples/./kotlin-dce/collections/MapWithDefault.kt","webpack://examples/./kotlin-dce/collections/MutableCollections.kt","webpack://examples/./kotlin-dce/collections/Sequences.kt","webpack://examples/./kotlin-dce/collections/SequenceBuilder.kt","webpack://examples/./kotlin-dce/coroutines/ContinuationInterceptor.kt","webpack://examples/./kotlin-dce/coroutines/CoroutineContext.kt","webpack://examples/./kotlin-dce/coroutines/CoroutineContextImpl.kt","webpack://examples/./kotlin-dce/coroutines/intrinsics/Intrinsics.kt","webpack://examples/./kotlin-dce/random/Random.kt","webpack://examples/./kotlin-dce/random/XorWowRandom.kt","webpack://examples/./kotlin-dce/ranges/Ranges.kt","webpack://examples/./kotlin-dce/text/Appendable.kt","webpack://examples/./kotlin-dce/util/Tuples.kt","webpack://examples/./kotlin-dce/kotlin/MathH.kt","webpack://examples/./kotlin-dce/kotlin/coroutines/js/internal/EmptyContinuation.kt","webpack://examples/./kotlin-dce/kotlin/text/utf8Encoding.kt","webpack://examples/coroutines.kt","webpack://examples/coroutinesIntrinsics.kt","webpack://examples/CoroutinesLibrary.kt","webpack://examples/Intrinsics.kt","webpack://examples//home/runner/work/kgpu/kgpu/build/js/node_modules/process/browser.js","webpack://examples/../../../../../common/src/Delay.kt","webpack://examples/../../../../../common/src/EventLoop.common.kt","webpack://examples/./kotlin-dce/text/StringBuilder.kt","webpack://examples/../../../../../common/src/internal/LockFreeTaskQueue.kt","webpack://examples/../../../../../js/src/JSDispatcher.kt","webpack://examples/../../../../../common/src/AbstractCoroutine.kt","webpack://examples/../../../../../common/src/Builders.common.kt","webpack://examples/../../../../../common/src/CancellableContinuation.kt","webpack://examples/../../../../../common/src/CancellableContinuationImpl.kt","webpack://examples/../../../../../src/commonMain/kotlin/kotlinx/atomicfu/AtomicFU.common.kt","webpack://examples/../../../../../common/src/CompletableDeferred.kt","webpack://examples/../../../../../common/src/CompletedExceptionally.kt","webpack://examples/../../../../../common/src/CoroutineDispatcher.kt","webpack://examples/../../../../../common/src/CompletionHandler.common.kt","webpack://examples/../../../../../common/src/CoroutineExceptionHandler.kt","webpack://examples/../../../../../common/src/CoroutineName.kt","webpack://examples/../../../../../common/src/CoroutineScope.kt","webpack://examples/../../../../../common/src/CoroutineStart.kt","webpack://examples/../../../../../common/src/Job.kt","webpack://examples/../../../../../common/src/JobSupport.kt","webpack://examples/./kotlin-dce/generated/_Sequences.kt","webpack://examples/../../../../../js/src/internal/LinkedList.kt","webpack://examples/../../../../../common/src/NonCancellable.kt","webpack://examples/../../../../../common/src/Supervisor.kt","webpack://examples/../../../../../common/src/Timeout.kt","webpack://examples/../../../../../common/src/channels/AbstractChannel.kt","webpack://examples/../../../../../common/src/MainCoroutineDispatcher.kt","webpack://examples/../../../../../common/src/internal/ThreadSafeHeap.kt","webpack://examples/../../../../../common/src/selects/Select.kt","webpack://examples/../../../../../common/src/sync/Semaphore.kt","webpack://examples/../../../../../common/src/flow/terminal/Collect.kt","webpack://examples/../../../../../common/src/internal/ConcurrentLinkedList.kt","webpack://examples/../../../../../common/src/internal/DispatchedContinuation.kt","webpack://examples/../../../../../common/src/internal/DispatchedTask.kt","webpack://examples/../../../../../common/src/internal/InlineList.kt","webpack://examples/../../../../../common/src/intrinsics/Undispatched.kt","webpack://examples/../../../../../common/src/channels/Channels.common.kt","webpack://examples/../../../../../common/src/flow/Channels.kt","webpack://examples/../../../../../common/src/flow/operators/Zip.kt","webpack://examples/../../../../../common/src/flow/terminal/Collection.kt","webpack://examples/../../../../../common/src/flow/terminal/Reduce.kt","webpack://examples/../../../../../common/src/internal/ArrayQueue.kt","webpack://examples/../../../../../common/src/internal/Atomic.kt","webpack://examples/../../../../../common/src/internal/SystemProps.common.kt","webpack://examples/../../../../../js/src/internal/Synchronized.kt","webpack://examples/../../../../../common/src/intrinsics/Cancellable.kt","webpack://examples/../../../../../js/src/Runnable.kt","webpack://examples/../../../../../common/src/sync/Mutex.kt","webpack://examples/../../../../../js/src/CompletionHandler.kt","webpack://examples/../../../../../js/src/CoroutineContext.kt","webpack://examples/./kotlin-dce/kotlin/jsTypeOf.kt","webpack://examples/../../../../../js/src/Debug.kt","webpack://examples/../../../../../js/src/Dispatchers.kt","webpack://examples/../../../../../js/src/EventLoop.kt","webpack://examples/../../../../../js/src/Window.kt","webpack://examples/../../../../../js/src/internal/CopyOnWriteList.kt","webpack://examples/../../../../../js/src/CoroutineExceptionHandlerImpl.kt","webpack://examples/../../../../../js/src/flow/internal/FlowExceptions.kt","webpack://examples/../../../../../js/src/flow/internal/SafeCollector.kt","webpack://examples//home/runner/work/kgpu/kgpu/examples/src/commonMain/kotlin/Examples.kt","webpack://examples//home/runner/work/kgpu/kgpu/examples/src/jsMain/kotlin/WebExamples.kt","webpack://examples//home/runner/work/kgpu/kgpu/src/commonMain/kotlin/io/github/kgpu/Kgpu.kt","webpack://examples//home/runner/work/kgpu/kgpu/src/commonMain/kotlin/io/github/kgpu/KgpuMath.kt","webpack://examples//home/runner/work/kgpu/kgpu/src/commonMain/kotlin/io/github/kgpu/Util.kt","webpack://examples//home/runner/work/kgpu/kgpu/src/jsMain/kotlin/io/github/kgpu/JsFiles.kt","webpack://examples/./kotlin-dce/org.w3c/org.w3c.fetch.kt","webpack://examples//home/runner/work/kgpu/kgpu/src/jsMain/kotlin/io/github/kgpu/JsKgpu.kt","webpack://examples//home/runner/work/kgpu/kgpu/src/jsMain/kotlin/io/github/kgpu/JsMath.kt","webpack://examples//home/runner/work/kgpu/kgpu/src/jsMain/kotlin/io/github/kgpu/JsShaders.kt","webpack://examples//home/runner/work/kgpu/kgpu/src/jsMain/kotlin/io/github/kgpu/internal/ArrayBufferUtils.kt","webpack://examples//home/runner/work/kgpu/kgpu/src/jsMain/kotlin/io/github/kgpu/internal/glslang.kt","webpack://examples//home/runner/work/kgpu/kgpu/build/js/node_modules/gl-matrix/esm/common.js","webpack://examples//home/runner/work/kgpu/kgpu/build/js/node_modules/gl-matrix/esm/mat2.js","webpack://examples//home/runner/work/kgpu/kgpu/build/js/node_modules/gl-matrix/esm/mat2d.js","webpack://examples//home/runner/work/kgpu/kgpu/build/js/node_modules/gl-matrix/esm/mat3.js","webpack://examples//home/runner/work/kgpu/kgpu/build/js/node_modules/gl-matrix/esm/mat4.js","webpack://examples//home/runner/work/kgpu/kgpu/build/js/node_modules/gl-matrix/esm/vec3.js","webpack://examples//home/runner/work/kgpu/kgpu/build/js/node_modules/gl-matrix/esm/vec4.js","webpack://examples//home/runner/work/kgpu/kgpu/build/js/node_modules/gl-matrix/esm/quat.js","webpack://examples//home/runner/work/kgpu/kgpu/build/js/node_modules/gl-matrix/esm/quat2.js","webpack://examples//home/runner/work/kgpu/kgpu/build/js/node_modules/gl-matrix/esm/vec2.js","webpack://examples//home/runner/work/kgpu/kgpu/build/js/node_modules/gl-matrix/esm/index.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Kotlin","buf","bufFloat64","bufFloat32","bufInt32","lowIndex","highIndex","_","getObjectHashCode","obj","hash","Math","random","throwMarkerError","Error","imul","a","b","isBooleanArray","Array","isArray","Int8Array","$type$","isByteArray","isShortArray","Int16Array","isCharArray","Uint16Array","isIntArray","Int32Array","isFloatArray","Float32Array","isDoubleArray","Float64Array","isLongArray","isArrayish","ArrayBuffer","isView","arrayToString","toString","String","fromCharCode","map","e","join","toByte","toChar","toBoxedChar","BoxedChar","unboxChar","equals","obj1","obj2","hashCode","objType","numberHashCode","Number","str","length","code","charCodeAt","getStringHashCode","identityHashCode","Long","this","low_","low","high_","high","$metadata$","IntCache_","fromInt","cachedObj","fromNumber","isNaN","ZERO","TWO_PWR_63_DBL_","MIN_VALUE","MAX_VALUE","negate","TWO_PWR_32_DBL_","fromBits","lowBits","highBits","fromString","radix","opt_radix","charAt","substring","indexOf","radixToPower","pow","result","size","min","parseInt","power","multiply","add","TWO_PWR_16_DBL_","TWO_PWR_24_DBL_","TWO_PWR_31_DBL_","TWO_PWR_48_DBL_","TWO_PWR_64_DBL_","ONE","NEG_ONE","TWO_PWR_24_","toInt","toNumber","getLowBitsUnsigned","isZero","isNegative","equalsLong","radixLong","div","rem","subtract","remDiv","digits","getHighBits","getLowBits","getNumBitsAbs","val","bit","isOdd","other","notEqualsLong","lessThan","compare","lessThanOrEqual","greaterThan","greaterThanOrEqual","thisNeg","otherNeg","not","a48","a32","a16","a00","b48","b32","b16","c48","c32","c16","c00","b00","approx","shiftRight","shiftLeft","res","max","floor","log2","ceil","log","LN2","delta","approxRes","approxRem","modulo","and","or","xor","numBits","shiftRightUnsigned","compareTo_11rb$","inc","dec","valueOf","unaryPlus","unaryMinus","inv","rangeTo","kotlin","ranges","LongRange","defineInlineFunction","fun","wrapFunction","f","apply","arguments","suspendCall","coroutineResult","coroutineReceiver","setCoroutineResult","compareTo","typeA","doubleCompareTo","primitiveCompareTo","ia","imulEmulated","doubleToRawBits","doubleFromBits","floatToRawBits","ensureNotNull","x","throwNPE","startsWith","position","lastIndexOf","searchString","endsWith","subjectString","undefined","lastIndex","sign","trunc","NaN","taylor_2_bound","sqrt","taylor_n_bound","upper_taylor_2_bound","upper_taylor_n_bound","sinh","abs","y","exp","y1","isFinite","cosh","tanh","Infinity","asinh","acosh","atanh","log1p","x2","x3","expm1","hypot","log10","LOG10E","LOG2E","clz32","asUint","__proto__","fill","TypeError","O","len","start","relativeStart","k","end","relativeEnd","final","normalizeOffset","offset","typedArraySlice","begin","constructor","subarray","arrays","TypedArray","slice","Function","self","array","callback","totalOrderComparator","sort","compareFunction","Kind","callGetter","thisObject","klass","propertyName","propertyDescriptor","getOwnPropertyDescriptor","getPrototypeOf","isType","proto","kind","OBJECT","klassMetadata","INTERFACE","isInheritanceFromInterface","ctor","iface","metadata","interfaces","superPrototype","superConstructor","isNumber","isChar","isCharSequence","CharSequence","ordinal","element","index","IntRange","separator","prefix","postfix","limit","truncated","transform","buffer","count","last","first","step","CharIterator","IntIterator","LongIterator","getProgressionLastElement","endInclusive","nextChar","nextInt","nextLong","CharProgressionIterator","isEmpty","CharProgression","rangeStart","rangeEnd","IntProgressionIterator","IntProgression","LongProgressionIterator","LongProgression","CharRange","mod","differenceModulo","context","current","v","currentResult","isFailure","currentException","exceptionOrNull","doResume","outcome","exception","completion","Result","createFailure","intercepted","CoroutineImpl","receiver","fromIndex","toIndex","toArray","copyToArrayImpl","collection","iterator","hasNext","push","next","AbstractCollection","AbstractMutableCollection","AbstractMutableList","AbstractMap","AbstractMutableSet","remove","modified","elements","it","_index","changed","times","hasPrevious","newValue","oldValue","entries","clear","from","iter","entry","modCount","splice","concat","copyToArray","pop","value1","value2","internalMap","equality","InternalHashCodeMap","loadFactor","initialCapacity","createJsMap","keys","BaseOutput","BufferedOutput","initialResult","ClassCastException","message","cause","Exception","RuntimeException","NEGATIVE_INFINITY","toRawBits","bits","POSITIVE_INFINITY","isInfinite","hi26","INV_2_26","low27","INV_2_53","jClass","KClassImpl","createEntrySet","chainOrEntry","chain","isChain","chainSize","keyIndex","itemIndex","state","lastEntry","_head","_tail","node","old","newEntry","println","outputStream","write","messageString","flush","console","cur","NotImplementedError","simpleName","jsClass","PrimitiveKClassImpl","functionClasses","arity","getOrCreateKClass","stringClass","SimpleKClassImpl","kClass","content","MIN_HIGH_SURROGATE","MAX_HIGH_SURROGATE","MIN_LOW_SURROGATE","MAX_LOW_SURROGATE","char","startIndex","endIndex","ignoreCase","n1","n2","s1","s2","toUpperCase","toLowerCase","IndexOutOfBoundsException","reversed","isLowSurrogate","isHighSurrogate","concatToString","_capacity","minimumCapacity","capacity","string","newLength","destinationOffset","destination","dstIndex","stringCsq","otherIterator","elem","elemOther","AbstractSet","ourValue","filterInPlace","predicate","predicateResultToRemove","writeIndex","readIndex","removeIndex","j","copy","SequenceBuilderIterator","nextStep","block","SequenceScope","sequence","throwOnFailure","safe","getOrThrow","acc","removed","interceptor","CombinedContext","left","baseKey","operation","initial","newLeft","Random","defaultPlatformRandom","accumulator","until","checkRangeBounds","fastLog2","bitCount","nLow","nHigh","rnd","doubleFromParts","nextDouble","r1","nextDown","steps","remainder","vr","nextBoolean","nextFloat","seed","boundsErrorMessage","seed1","seed2","checkRadix","firstChar","limitBeforeMul","limitForMaxRadix","digitOf","digit","v0","takeUpperBits","second","minimumValue","maximumValue","captureStackTrace","instance","stack","source","rangeSize","set","subrange","output","delegate","NullPointerException","intClass","doubleClass","booleanClass","functionClass","booleanArrayClass","charArrayClass","byteArrayClass","shortArrayClass","intArrayClass","longArrayClass","floatArrayClass","doubleArrayClass","arrayClass","anyClass","throwableClass","createCoroutineUnintercepted","isNode","NodeJsOutput","BufferedOutputToConsoleLog","cachedSetTimeout","cachedClearTimeout","process","defaultSetTimout","defaultClearTimeout","runTimeout","setTimeout","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","drainQueue","timeout","run","marker","runClearTimeout","Item","noop","nextTick","args","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","Matrix4f","joinToString","matrix","toFloats","getWindowSize","windowSize","height","MathUtils","aspectRatio","isOutOfDate","getCurrentTextureView","createCommandEncoder","RenderPassColorAttachmentDescriptor","swapChainTexture","Color","WHITE","cmdEncoder","RenderPassDescriptor","colorAttachment","renderPassEncoder","endPass","finish","getDefaultQueue","toBytes","cmdBuffer","present","RenderPipelineDescriptor","pipelineLayout","ProgrammableStageDescriptor","vertexModule","fragModule","RasterizationStateDescriptor","cullMode","ColorStateDescriptor","BlendDescriptor","Kgpu","VertexStateDescriptor","VertexBufferLayoutDescriptor","VertexAttributeDescriptor","init","Window","kgpuWindow","URL","location","href","searchParams","launch","GlobalScope","Vec3f","UNIT_Z","projMatrix","adapter","requestDeviceAsync","ShaderUtils","BufferUtils","BindGroupLayoutDescriptor","BindGroupLayoutEntry","descriptor","PipelineLayoutDescriptor","bindGroupLayout","BindGroupDescriptor","BindGroupEntry","matrixBuffer","createRenderPipeline","fragShader","pipelineDesc","SwapChainDescriptor","swapChain","swapChainDescriptor","mathTest","vertices","runCubeExample","runTriangleExample","width","degrees","PIf","shaderSrc","vertexShader","device","BufferDescriptor","data","usage","floatArray","item","bytes","shortArray","fetch","arrayBuffer","response","text","func","requestAnimationFrame","document","getElementById","getContext","frontFace","jsType","srcFactor","dstFactor","format","stepMode","indexFormat","type","bindGroupLayouts","OUTPUT_ATTACHMENT","storeOp","attachment","clearColor","resource","intoBindingResource","layout","mat4","vec3","fromValues","z","Adapter","WindowSize","SwapChain","configureSwapChain","desc","requestDevice","Device","toTypedArray","Uint32Array","createShaderModule","createPipelineLayout","Texture","createTexture","CommandEncoder","Queue","defaultQueue","Buffer","createBuffer","BindGroupLayout","createBindGroupLayout","createBufferMapped","values","unmap","BindGroup","createBindGroup","RenderPassEncoder","beginRenderPass","CommandBuffer","setPipeline","pipeline","firstVertex","firstInstance","draw","vertexCount","instanceCount","setVertexBuffer","slot","baseVertex","drawIndexed","indexCount","setIndexBuffer","setBindGroup","bindGroup","TextureView","createView","getCurrentTexture","cmdBuffers","submit","dataOffset","Uint8Array","writeBuffer","getMappedRange","translate","mat","xyz","out","ortho","right","bottom","top","near","far","lookAt","eye","vec","center","up","mul","perspective","fov","aspect","rotateX","angle","rotateY","rotateZ","getGlslang","compileGLSL","createElement","script","id","setAttribute","innerHTML","scriptSrc","body","EPSILON","ARRAY_TYPE","RANDOM","setMatrixArrayType","degree","PI","toRadian","clone","identity","m00","m01","m10","m11","transpose","a1","invert","a0","a2","a3","det","adjoint","determinant","b0","b1","b2","b3","rotate","rad","sin","cos","v1","fromRotation","fromScaling","frob","LDU","L","D","U","exactEquals","multiplyScalar","multiplyScalarAndAdd","scale","sub","tx","ty","aa","ab","ac","ad","atx","aty","a4","a5","b4","b5","fromTranslation","fromMat4","m02","m12","m20","m21","m22","a01","a02","a12","a10","a11","a20","a21","a22","b01","b11","b21","b02","b10","b12","b20","b22","fromMat2d","fromQuat","q","w","y2","z2","xx","yx","yy","zx","zy","zz","wx","wy","wz","normalFromMat4","a03","a13","a23","a30","a31","a33","b03","b04","b05","b06","b07","b08","b09","projection","a6","a7","a8","b6","b7","b8","m03","m13","m23","m30","m31","m32","m33","axis","fromXRotation","fromYRotation","fromZRotation","fromRotationTranslation","xy","xz","yz","fromQuat2","translation","bx","by","bz","bw","ax","ay","az","aw","magnitude","getTranslation","getScaling","getRotation","scaling","is1","is2","is3","sm11","sm12","sm13","sm21","sm22","sm23","sm31","sm32","sm33","trace","S","fromRotationTranslationScale","sx","sy","sz","fromRotationTranslationScaleOrigin","ox","oy","oz","out0","out1","out2","out4","out5","out6","out8","out9","out10","frustum","rl","tb","nf","fovy","tan","perspectiveFromFieldOfView","upTan","upDegrees","downTan","downDegrees","leftTan","leftDegrees","rightTan","rightDegrees","xScale","yScale","lr","bt","x0","x1","y0","z0","z1","eyex","eyey","eyez","upx","upy","upz","centerx","centery","centerz","targetTo","target","a9","a14","a15","b9","b13","b14","b15","divide","round","scaleAndAdd","distance","squaredDistance","squaredLength","inverse","normalize","cross","lerp","hermite","factorTimes2","factor1","factor2","factor3","factor4","bezier","inverseFactor","inverseFactorTimesTwo","zScale","transformMat4","transformMat3","transformQuat","qx","qy","qz","qw","uvx","uvy","uvz","uuvx","uuvy","uuvz","w2","mag","cosine","acos","zero","dist","sqrDist","sqrLen","forEach","stride","fn","arg","u","A","B","C","E","F","G","H","I","J","v2","v3","v4","ix","iy","iz","iw","setAxisAngle","getAxisAngle","out_axis","getAngle","dotproduct","calculateW","et","ln","atan2","slerp","omega","cosom","sinom","scale0","scale1","u1","u2","u3","sqrt1MinusU1","sqrtU1","dot","invDot","conjugate","fromMat3","fRoot","fTrace","fromEuler","halfToRad","cx","cy","cz","tmpvec3","xUnitVec3","yUnitVec3","temp1","temp2","matr","rotationTo","sqlerp","setAxes","view","dq","w1","fromRotationTranslationValues","outer","getReal","getDual","setReal","setDual","ax1","ay1","az1","aw1","bx1","by1","bz1","ax2","ay2","az2","aw2","rotateByQuatAppend","rotateByQuatPrepend","rotateAroundAxis","axisLength","ax0","ay0","az0","aw0","bw1","bx0","by0","bz0","bw0","mt","sqlen","a_dot_b","transformMat2","transformMat2d","p0","p1","sinC","cosC"],"mappings":"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iC,cAAjC,2DACI,kBAAI,OACJ,wBACA,gCACA,mBACA,mBAJA,6BACA,6BACA,6BACA,6BACA,6BAcyB,wBAAC,UAAqB,IAAnD,aAA8B,cAA9B,2DACI,mBAAK,QACL,kBAAI,OACJ,yBACA,mCACA,yBACA,mCACA,yBACA,mCACA,yBACA,mCACA,oCACA,4BACA,sCAZA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BAGyB,mBAA7B,aAA8B,cAA9B,2DACI,qBAAO,UACP,qBAAO,UADP,6BACA,6BAG0B,mBAA9B,aAA+B,cAA/B,2DACI,qBAAO,UACP,qBAAO,UACP,oBAAM,SACN,oBAAM,SACN,0BAAY,cACZ,0BAAY,cACZ,yBAAW,aACX,yBAAW,aACX,sBAAQ,WACR,sBAAQ,WACR,sBAAO,UACP,sBAAO,UACP,4BAAa,eACb,4BAAa,eACb,2BAAY,cACZ,2BAAY,cACZ,qBAAM,SACN,qBAAM,SACN,qBAAM,SACN,sBAAO,UACP,sBAAO,UACP,sBAAO,UACP,oBAAK,QACL,qBAAM,SACN,qBAAM,SACN,qBAAM,SACN,mBAAI,OACJ,oBAAK,QACL,oBAAK,QACL,oBAAK,QA7BL,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BAkBoB,mBAAxB,aAAyB,cAAzB,2DACI,oBAAM,SACN,mBAAK,QADL,6BACA,6BAGqB,mBAAzB,aAA0B,cAA1B,2DACI,oBAAM,SACN,oBAAM,SADN,6BACA,6BAGyB,mBAA7B,aAA8B,cAA9B,2DACI,6BAAe,kBACf,6BAAe,kBACf,sCAAwB,2BACxB,sBAAQ,WACR,iCAAmB,sBACnB,8BAAgB,mBAChB,uCAAyB,4BACzB,wCAA0B,6BAP1B,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BC9uBkB,cAClB,SAAUe,EAAK/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","file":"examples.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"examples\"] = factory();\n\telse\n\t\troot[\"examples\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define('kotlin', ['exports'], factory);\n    }\n    else if (typeof exports === 'object') {\n        factory(module.exports);\n    }\n    else {\n        root.kotlin = {};\n        factory(root.kotlin);\n    }\n}(this, function (Kotlin) {\n    var _ = Kotlin;\n\n    insertContent();\n}));\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.compareTo = function (a, b) {\n    var typeA = typeof a;\n    if (typeA === \"number\") {\n        if (typeof b === \"number\") {\n            return Kotlin.doubleCompareTo(a, b);\n        }\n        return Kotlin.primitiveCompareTo(a, b);\n    }\n    if (typeA === \"string\" || typeA === \"boolean\") {\n        return Kotlin.primitiveCompareTo(a, b);\n    }\n    return a.compareTo_11rb$(b);\n};\n\nKotlin.primitiveCompareTo = function (a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n};\n\nKotlin.doubleCompareTo = function (a, b) {\n    if (a < b) return -1;\n    if (a > b) return 1;\n\n    if (a === b) {\n        if (a !== 0) return 0;\n\n        var ia = 1 / a;\n        return ia === 1 / b ? 0 : (ia < 0 ? -1 : 1);\n    }\n\n    return a !== a ? (b !== b ? 0 : 1) : -1\n};\n\nKotlin.charInc = function (value) {\n    return Kotlin.toChar(value+1);\n};\n\nKotlin.charDec = function (value) {\n    return Kotlin.toChar(value-1);\n};\n\nKotlin.imul = Math.imul || imul;\n\nKotlin.imulEmulated = imul;\n\nfunction imul(a, b) {\n    return ((a & 0xffff0000) * (b & 0xffff) + (a & 0xffff) * (b | 0)) | 0;\n}\n\n(function() {\n    var buf = new ArrayBuffer(8);\n    var bufFloat64 = new Float64Array(buf);\n    var bufFloat32 = new Float32Array(buf);\n    var bufInt32 = new Int32Array(buf);\n    var lowIndex = 0;\n    var highIndex = 1;\n\n    bufFloat64[0] = -1; // bff00000_00000000\n    if (bufInt32[lowIndex] !== 0) {\n        lowIndex = 1;\n        highIndex = 0;\n    }\n\n    Kotlin.doubleToBits = function(value) {\n        return Kotlin.doubleToRawBits(isNaN(value) ? NaN : value);\n    };\n\n    Kotlin.doubleToRawBits = function(value) {\n        bufFloat64[0] = value;\n        return Kotlin.Long.fromBits(bufInt32[lowIndex], bufInt32[highIndex]);\n    };\n\n    Kotlin.doubleFromBits = function(value) {\n        bufInt32[lowIndex] = value.low_;\n        bufInt32[highIndex] = value.high_;\n        return bufFloat64[0];\n    };\n\n    Kotlin.floatToBits = function(value) {\n        return Kotlin.floatToRawBits(isNaN(value) ? NaN : value);\n    };\n\n    Kotlin.floatToRawBits = function(value) {\n        bufFloat32[0] = value;\n        return bufInt32[0];\n    };\n\n    Kotlin.floatFromBits = function(value) {\n        bufInt32[0] = value;\n        return bufFloat32[0];\n    };\n\n    // returns zero value for number with positive sign bit and non-zero value for number with negative sign bit.\n    Kotlin.doubleSignBit = function(value) {\n        bufFloat64[0] = value;\n        return bufInt32[highIndex] & 0x80000000;\n    };\n\n    Kotlin.numberHashCode = function(obj) {\n        if ((obj | 0) === obj) {\n            return obj | 0;\n        }\n        else {\n            bufFloat64[0] = obj;\n            return (bufInt32[highIndex] * 31 | 0) + bufInt32[lowIndex] | 0;\n        }\n    }\n})();\n\nKotlin.ensureNotNull = function(x) {\n    return x != null ? x : Kotlin.throwNPE();\n};\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nif (typeof String.prototype.startsWith === \"undefined\") {\n    String.prototype.startsWith = function(searchString, position) {\n        position = position || 0;\n        return this.lastIndexOf(searchString, position) === position;\n    };\n}\nif (typeof String.prototype.endsWith === \"undefined\") {\n    String.prototype.endsWith = function(searchString, position) {\n        var subjectString = this.toString();\n        if (position === undefined || position > subjectString.length) {\n            position = subjectString.length;\n        }\n        position -= searchString.length;\n        var lastIndex = subjectString.indexOf(searchString, position);\n        return lastIndex !== -1 && lastIndex === position;\n    };\n}\n// ES6 Math polyfills\nif (typeof Math.sign === \"undefined\") {\n    Math.sign = function(x) {\n        x = +x; // convert to a number\n        if (x === 0 || isNaN(x)) {\n            return Number(x);\n        }\n        return x > 0 ? 1 : -1;\n    };\n}\nif (typeof Math.trunc === \"undefined\") {\n    Math.trunc = function(x) {\n        if (isNaN(x)) {\n            return NaN;\n        }\n        if (x > 0) {\n            return Math.floor(x);\n        }\n        return Math.ceil(x);\n    };\n}\n\n(function() {\n    var epsilon = 2.220446049250313E-16;\n    var taylor_2_bound = Math.sqrt(epsilon);\n    var taylor_n_bound = Math.sqrt(taylor_2_bound);\n    var upper_taylor_2_bound = 1/taylor_2_bound;\n    var upper_taylor_n_bound = 1/taylor_n_bound;\n\n    if (typeof Math.sinh === \"undefined\") {\n        Math.sinh = function(x) {\n            if (Math.abs(x) < taylor_n_bound) {\n                var result = x;\n                if (Math.abs(x) > taylor_2_bound) {\n                    result += (x * x * x) / 6;\n                }\n                return result;\n            } else {\n                var y = Math.exp(x);\n                var y1 = 1 / y;\n                if (!isFinite(y)) return Math.exp(x - Math.LN2);\n                if (!isFinite(y1)) return -Math.exp(-x - Math.LN2);\n                return (y - y1) / 2;\n            }\n        };\n    }\n    if (typeof Math.cosh === \"undefined\") {\n        Math.cosh = function(x) {\n            var y = Math.exp(x);\n            var y1 = 1 / y;\n            if (!isFinite(y) || !isFinite(y1)) return Math.exp(Math.abs(x) - Math.LN2);\n            return (y + y1) / 2;\n        };\n    }\n\n    if (typeof Math.tanh === \"undefined\") {\n        Math.tanh = function(x){\n            if (Math.abs(x) < taylor_n_bound) {\n                var result = x;\n                if (Math.abs(x) > taylor_2_bound) {\n                    result -= (x * x * x) / 3;\n                }\n                return result;\n            }\n            else {\n                var a = Math.exp(+x), b = Math.exp(-x);\n                return a === Infinity ? 1 : b === Infinity ? -1 : (a - b) / (a + b);\n            }\n        };\n    }\n\n    // Inverse hyperbolic function implementations derived from boost special math functions,\n    // Copyright Eric Ford & Hubert Holin 2001.\n\n    if (typeof Math.asinh === \"undefined\") {\n        var asinh = function(x) {\n            if (x >= +taylor_n_bound)\n            {\n                if (x > upper_taylor_n_bound)\n                {\n                    if (x > upper_taylor_2_bound)\n                    {\n                        // approximation by laurent series in 1/x at 0+ order from -1 to 0\n                        return Math.log(x) + Math.LN2;\n                    }\n                    else\n                    {\n                        // approximation by laurent series in 1/x at 0+ order from -1 to 1\n                        return Math.log(x * 2 + (1 / (x * 2)));\n                    }\n                }\n                else\n                {\n                    return Math.log(x + Math.sqrt(x * x + 1));\n                }\n            }\n            else if (x <= -taylor_n_bound)\n            {\n                return -asinh(-x);\n            }\n            else\n            {\n                // approximation by taylor series in x at 0 up to order 2\n                var result = x;\n                if (Math.abs(x) >= taylor_2_bound)\n                {\n                    var x3 = x * x * x;\n                    // approximation by taylor series in x at 0 up to order 4\n                    result -= x3 / 6;\n                }\n                return result;\n            }\n        };\n        Math.asinh = asinh;\n    }\n    if (typeof Math.acosh === \"undefined\") {\n        Math.acosh = function(x) {\n            if (x < 1)\n            {\n                return NaN;\n            }\n            else if (x - 1 >= taylor_n_bound)\n            {\n                if (x > upper_taylor_2_bound)\n                {\n                    // approximation by laurent series in 1/x at 0+ order from -1 to 0\n                    return Math.log(x) + Math.LN2;\n                }\n                else\n                {\n                    return Math.log(x + Math.sqrt(x * x - 1));\n                }\n            }\n            else\n            {\n                var y = Math.sqrt(x - 1);\n                // approximation by taylor series in y at 0 up to order 2\n                var result = y;\n                if (y >= taylor_2_bound)\n                {\n                    var y3 = y * y * y;\n                    // approximation by taylor series in y at 0 up to order 4\n                    result -= y3 / 12;\n                }\n\n                return Math.sqrt(2) * result;\n            }\n        };\n    }\n    if (typeof Math.atanh === \"undefined\") {\n        Math.atanh = function(x) {\n            if (Math.abs(x) < taylor_n_bound) {\n                var result = x;\n                if (Math.abs(x) > taylor_2_bound) {\n                    result += (x * x * x) / 3;\n                }\n                return result;\n            }\n            return Math.log((1 + x) / (1 - x)) / 2;\n        };\n    }\n    if (typeof Math.log1p === \"undefined\") {\n        Math.log1p = function(x) {\n            if (Math.abs(x) < taylor_n_bound) {\n                var x2 = x * x;\n                var x3 = x2 * x;\n                var x4 = x3 * x;\n                // approximation by taylor series in x at 0 up to order 4\n                return (-x4 / 4 + x3 / 3 - x2 / 2 + x);\n            }\n            return Math.log(x + 1);\n        };\n    }\n    if (typeof Math.expm1 === \"undefined\") {\n        Math.expm1 = function(x) {\n            if (Math.abs(x) < taylor_n_bound) {\n                var x2 = x * x;\n                var x3 = x2 * x;\n                var x4 = x3 * x;\n                // approximation by taylor series in x at 0 up to order 4\n                return (x4 / 24 + x3 / 6 + x2 / 2 + x);\n            }\n            return Math.exp(x) - 1;\n        };\n    }\n})();\nif (typeof Math.hypot === \"undefined\") {\n    Math.hypot = function() {\n        var y = 0;\n        var length = arguments.length;\n\n        for (var i = 0; i < length; i++) {\n            if (arguments[i] === Infinity || arguments[i] === -Infinity) {\n                return Infinity;\n            }\n            y += arguments[i] * arguments[i];\n        }\n        return Math.sqrt(y);\n    };\n}\nif (typeof Math.log10 === \"undefined\") {\n    Math.log10 = function(x) {\n        return Math.log(x) * Math.LOG10E;\n    };\n}\nif (typeof Math.log2 === \"undefined\") {\n    Math.log2 = function(x) {\n        return Math.log(x) * Math.LOG2E;\n    };\n}\nif (typeof Math.clz32 === \"undefined\") {\n    Math.clz32 = (function(log, LN2) {\n        return function(x) {\n            var asUint = x >>> 0;\n            if (asUint === 0) {\n                return 32;\n            }\n            return 31 - (log(asUint) / LN2 | 0) | 0; // the \"| 0\" acts like math.floor\n        };\n    })(Math.log, Math.LN2);\n}\n\n// For HtmlUnit and PhantomJs\nif (typeof ArrayBuffer.isView === \"undefined\") {\n    ArrayBuffer.isView = function(a) {\n        return a != null && a.__proto__ != null && a.__proto__.__proto__ === Int8Array.prototype.__proto__;\n    };\n}\n\nif (typeof Array.prototype.fill === \"undefined\") {\n    // Polyfill from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill#Polyfill\n    Array.prototype.fill = function() {\n      // Steps 1-2.\n      if (this == null) {\n        throw new TypeError('this is null or not defined');\n      }\n\n      var O = Object(this);\n\n      // Steps 3-5.\n      var len = O.length >>> 0;\n\n      // Steps 6-7.\n      var start = arguments[1];\n      var relativeStart = start >> 0;\n\n      // Step 8.\n      var k = relativeStart < 0 ?\n        Math.max(len + relativeStart, 0) :\n        Math.min(relativeStart, len);\n\n      // Steps 9-10.\n      var end = arguments[2];\n      var relativeEnd = end === undefined ?\n        len : end >> 0;\n\n      // Step 11.\n      var final = relativeEnd < 0 ?\n        Math.max(len + relativeEnd, 0) :\n        Math.min(relativeEnd, len);\n\n      // Step 12.\n      while (k < final) {\n        O[k] = value;\n        k++;\n      }\n\n      // Step 13.\n      return O;\n    };\n}\n\n(function() {\n    function normalizeOffset(offset, length) {\n        if (offset < 0) return Math.max(0, offset + length);\n        return Math.min(offset, length);\n    }\n    function typedArraySlice(begin, end) {\n        if (typeof end === \"undefined\") {\n            end = this.length;\n        }\n        begin = normalizeOffset(begin || 0, this.length);\n        end = Math.max(begin, normalizeOffset(end, this.length));\n        return new this.constructor(this.subarray(begin, end));\n    }\n\n    var arrays = [Int8Array, Int16Array, Uint16Array, Int32Array, Float32Array, Float64Array];\n    for (var i = 0; i < arrays.length; ++i) {\n        var TypedArray = arrays[i];\n        if (typeof TypedArray.prototype.fill === \"undefined\") {\n            TypedArray.prototype.fill = Array.prototype.fill;\n        }\n        if (typeof TypedArray.prototype.slice === \"undefined\") {\n            Object.defineProperty(TypedArray.prototype, 'slice', {\n                value: typedArraySlice\n            });\n        }\n    }\n\n    // Patch apply to work with TypedArrays if needed.\n    try {\n        (function() {}).apply(null, new Int32Array(0))\n    } catch (e) {\n        var apply = Function.prototype.apply;\n        Object.defineProperty(Function.prototype, 'apply', {\n            value: function(self, array) {\n                return apply.call(this, self, [].slice.call(array));\n            }\n        });\n    }\n\n\n    // Patch map to work with TypedArrays if needed.\n    for (var i = 0; i < arrays.length; ++i) {\n        var TypedArray = arrays[i];\n        if (typeof TypedArray.prototype.map === \"undefined\") {\n            Object.defineProperty(TypedArray.prototype, 'map', {\n                value: function(callback, self) {\n                    return [].slice.call(this).map(callback, self);\n                }\n            });\n        }\n    }\n\n    // Patch sort to work with TypedArrays if needed.\n    // TODO: consider to remove following function and replace it with `Kotlin.doubleCompareTo` (see misc.js)\n    var totalOrderComparator = function (a, b) {\n        if (a < b) return -1;\n        if (a > b) return 1;\n\n        if (a === b) {\n            if (a !== 0) return 0;\n\n            var ia = 1 / a;\n            return ia === 1 / b ? 0 : (ia < 0 ? -1 : 1);\n        }\n\n        return a !== a ? (b !== b ? 0 : 1) : -1\n    };\n\n    for (var i = 0; i < arrays.length; ++i) {\n        var TypedArray = arrays[i];\n        if (typeof TypedArray.prototype.sort === \"undefined\") {\n            Object.defineProperty(TypedArray.prototype, 'sort', {\n                value: function(compareFunction) {\n                    return Array.prototype.sort.call(this, compareFunction || totalOrderComparator);\n                }\n            });\n        }\n    }\n})();\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.equals = function (obj1, obj2) {\n    if (obj1 == null) {\n        return obj2 == null;\n    }\n\n    if (obj2 == null) {\n        return false;\n    }\n\n    if (obj1 !== obj1) {\n        return obj2 !== obj2;\n    }\n\n    if (typeof obj1 === \"object\" && typeof obj1.equals === \"function\") {\n        return obj1.equals(obj2);\n    }\n\n    if (typeof obj1 === \"number\" && typeof obj2 === \"number\") {\n        return obj1 === obj2 && (obj1 !== 0 || 1 / obj1 === 1 / obj2)\n    }\n\n    return obj1 === obj2;\n};\n\nKotlin.hashCode = function (obj) {\n    if (obj == null) {\n        return 0;\n    }\n    var objType = typeof obj;\n    if (\"object\" === objType) {\n        return \"function\" === typeof obj.hashCode ? obj.hashCode() : getObjectHashCode(obj);\n    }\n    if (\"function\" === objType) {\n        return getObjectHashCode(obj);\n    }\n    if (\"number\" === objType) {\n        return Kotlin.numberHashCode(obj);\n    }\n    if (\"boolean\" === objType) {\n        return Number(obj)\n    }\n\n    var str = String(obj);\n    return getStringHashCode(str);\n};\n\n\nKotlin.toString = function (o) {\n    if (o == null) {\n        return \"null\";\n    }\n    else if (Kotlin.isArrayish(o)) {\n        return \"[...]\";\n    }\n    else {\n        return o.toString();\n    }\n};\n\n/** @const */\nvar POW_2_32 = 4294967296;\n// TODO: consider switching to Symbol type once we are on ES6.\n/** @const */\nvar OBJECT_HASH_CODE_PROPERTY_NAME = \"kotlinHashCodeValue$\";\n\nfunction getObjectHashCode(obj) {\n    if (!(OBJECT_HASH_CODE_PROPERTY_NAME in obj)) {\n        var hash = (Math.random() * POW_2_32) | 0; // Make 32-bit singed integer.\n        Object.defineProperty(obj, OBJECT_HASH_CODE_PROPERTY_NAME, { value:  hash, enumerable: false });\n    }\n    return obj[OBJECT_HASH_CODE_PROPERTY_NAME];\n}\n\nfunction getStringHashCode(str) {\n    var hash = 0;\n    for (var i = 0; i < str.length; i++) {\n        var code  = str.charCodeAt(i);\n        hash  = (hash * 31 + code) | 0; // Keep it 32-bit.\n    }\n    return hash;\n}\n\nKotlin.identityHashCode = getObjectHashCode;\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/**\n * @param {string} id\n * @param {Object} declaration\n */\nKotlin.defineModule = function (id, declaration) {\n};\n\nKotlin.defineInlineFunction = function(tag, fun) {\n    return fun;\n};\n\nKotlin.wrapFunction = function(fun) {\n    var f = function() {\n        f = fun();\n        return f.apply(this, arguments);\n    };\n    return function() {\n        return f.apply(this, arguments);\n    };\n};\n\nKotlin.isTypeOf = function(type) {\n    return function (object) {\n        return typeof object === type;\n    }\n};\n\nKotlin.isInstanceOf = function (klass) {\n    return function (object) {\n        return Kotlin.isType(object, klass);\n    }\n};\n\nKotlin.orNull = function (fn) {\n    return function (object) {\n        return object == null || fn(object);\n    }\n};\n\nKotlin.andPredicate = function (a, b) {\n    return function (object) {\n        return a(object) && b(object);\n    }\n};\n\nKotlin.kotlinModuleMetadata = function (abiVersion, moduleName, data) {\n};\n\nKotlin.suspendCall = function(value) {\n    return value;\n};\n\nKotlin.coroutineResult = function(qualifier) {\n    throwMarkerError();\n};\n\nKotlin.coroutineController = function(qualifier) {\n    throwMarkerError();\n};\n\nKotlin.coroutineReceiver = function(qualifier) {\n    throwMarkerError();\n};\n\nKotlin.setCoroutineResult = function(value, qualifier) {\n    throwMarkerError();\n};\n\nKotlin.getReifiedTypeParameterKType = function(typeParameter) {\n    throwMarkerError();\n};\n\nfunction throwMarkerError() {\n    throw new Error(\n        \"This marker function should never been called. \" +\n        \"Looks like compiler did not eliminate it properly. \" +\n        \"Please, report an issue if you caught this exception.\");\n}\n\nKotlin.getFunctionById = function(id, defaultValue) {\n    return function() {\n        return defaultValue;\n    }\n};","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.isBooleanArray = function (a) {\n    return (Array.isArray(a) || a instanceof Int8Array) && a.$type$ === \"BooleanArray\"\n};\n\nKotlin.isByteArray = function (a) {\n    return a instanceof Int8Array && a.$type$ !== \"BooleanArray\"\n};\n\nKotlin.isShortArray = function (a) {\n    return a instanceof Int16Array\n};\n\nKotlin.isCharArray = function (a) {\n    return a instanceof Uint16Array && a.$type$ === \"CharArray\"\n};\n\nKotlin.isIntArray = function (a) {\n    return a instanceof Int32Array\n};\n\nKotlin.isFloatArray = function (a) {\n    return a instanceof Float32Array\n};\n\nKotlin.isDoubleArray = function (a) {\n    return a instanceof Float64Array\n};\n\nKotlin.isLongArray = function (a) {\n    return Array.isArray(a) && a.$type$ === \"LongArray\"\n};\n\nKotlin.isArray = function (a) {\n    return Array.isArray(a) && !a.$type$;\n};\n\nKotlin.isArrayish = function (a) {\n    return Array.isArray(a) || ArrayBuffer.isView(a)\n};\n\nKotlin.arrayToString = function (a) {\n    var toString = Kotlin.isCharArray(a) ? String.fromCharCode : Kotlin.toString;\n    return \"[\" + Array.prototype.map.call(a, function(e) { return toString(e); }).join(\", \") + \"]\";\n};\n\nKotlin.arrayDeepToString = function (arr) {\n    return Kotlin.kotlin.collections.contentDeepToStringImpl(arr);\n};\n\nKotlin.arrayEquals = function (a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (!Kotlin.isArrayish(b) || a.length !== b.length) {\n        return false;\n    }\n\n    for (var i = 0, n = a.length; i < n; i++) {\n        if (!Kotlin.equals(a[i], b[i])) {\n            return false;\n        }\n    }\n    return true;\n};\n\nKotlin.arrayDeepEquals = function (a, b) {\n    return Kotlin.kotlin.collections.contentDeepEqualsImpl(a, b);\n};\n\nKotlin.arrayHashCode = function (arr) {\n    var result = 1;\n    for (var i = 0, n = arr.length; i < n; i++) {\n        result = ((31 * result | 0) + Kotlin.hashCode(arr[i])) | 0;\n    }\n    return result;\n};\n\nKotlin.arrayDeepHashCode = function (arr) {\n    return Kotlin.kotlin.collections.contentDeepHashCodeImpl(arr);\n};\n\nKotlin.primitiveArraySort = function (array) {\n    array.sort(Kotlin.doubleCompareTo)\n};\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.toShort = function (a) {\n    return (a & 0xFFFF) << 16 >> 16;\n};\n\nKotlin.toByte = function (a) {\n    return (a & 0xFF) << 24 >> 24;\n};\n\nKotlin.toChar = function (a) {\n    return a & 0xFFFF;\n};\n\nKotlin.numberToLong = function (a) {\n    return a instanceof Kotlin.Long ? a : Kotlin.Long.fromNumber(a);\n};\n\nKotlin.numberToInt = function (a) {\n    return a instanceof Kotlin.Long ? a.toInt() : Kotlin.doubleToInt(a);\n};\n\nKotlin.numberToShort = function (a) {\n    return Kotlin.toShort(Kotlin.numberToInt(a));\n};\n\nKotlin.numberToByte = function (a) {\n    return Kotlin.toByte(Kotlin.numberToInt(a));\n};\n\nKotlin.numberToDouble = function (a) {\n    return +a;\n};\n\nKotlin.numberToChar = function (a) {\n    return Kotlin.toChar(Kotlin.numberToInt(a));\n};\n\nKotlin.doubleToInt = function(a) {\n    if (a > 2147483647) return 2147483647;\n    if (a < -2147483648) return -2147483648;\n    return a | 0;\n};\n\nKotlin.toBoxedChar = function (a) {\n    if (a == null) return a;\n    if (a instanceof Kotlin.BoxedChar) return a;\n    return new Kotlin.BoxedChar(a);\n};\n\nKotlin.unboxChar = function(a) {\n    if (a == null) return a;\n    return Kotlin.toChar(a);\n};\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Copyright 2009 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n/**\n * Constructs a 64-bit two's-complement integer, given its low and high 32-bit\n * values as *signed* integers.  See the from* functions below for more\n * convenient ways of constructing Longs.\n *\n * The internal representation of a long is the two given signed, 32-bit values.\n * We use 32-bit pieces because these are the size of integers on which\n * Javascript performs bit-operations.  For operations like addition and\n * multiplication, we split each number into 16-bit pieces, which can easily be\n * multiplied within Javascript's floating-point representation without overflow\n * or change in sign.\n *\n * In the algorithms below, we frequently reduce the negative case to the\n * positive case by negating the input(s) and then post-processing the result.\n * Note that we must ALWAYS check specially whether those values are MIN_VALUE\n * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n * a positive number, it overflows back into a negative).  Not handling this\n * case would often result in infinite recursion.\n *\n * @param {number} low  The low (signed) 32 bits of the long.\n * @param {number} high  The high (signed) 32 bits of the long.\n * @constructor\n * @final\n */\nKotlin.Long = function(low, high) {\n  /**\n   * @type {number}\n   * @private\n   */\n  this.low_ = low | 0;  // force into 32 signed bits.\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.high_ = high | 0;  // force into 32 signed bits.\n};\n\nKotlin.Long.$metadata$ = {\n    kind: \"class\",\n    simpleName: \"Long\",\n    interfaces:[]\n};\n\n\n// NOTE: Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the\n// from* methods on which they depend.\n\n\n/**\n * A cache of the Long representations of small integer values.\n * @type {!Object}\n * @private\n */\nKotlin.Long.IntCache_ = {};\n\n\n/**\n * Returns a Long representing the given (32-bit) integer value.\n * @param {number} value The 32-bit integer in question.\n * @return {!Kotlin.Long} The corresponding Long value.\n */\nKotlin.Long.fromInt = function(value) {\n  if (-128 <= value && value < 128) {\n    var cachedObj = Kotlin.Long.IntCache_[value];\n    if (cachedObj) {\n      return cachedObj;\n    }\n  }\n\n  var obj = new Kotlin.Long(value | 0, value < 0 ? -1 : 0);\n  if (-128 <= value && value < 128) {\n    Kotlin.Long.IntCache_[value] = obj;\n  }\n  return obj;\n};\n\n\n/**\n * Converts this number value to `Long`.\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Double` value is `NaN`, `Long.MIN_VALUE` if it's less than `Long.MIN_VALUE`,\n * `Long.MAX_VALUE` if it's bigger than `Long.MAX_VALUE`.\n * @param {number} value The number in question.\n * @return {!Kotlin.Long} The corresponding Long value.\n */\nKotlin.Long.fromNumber = function(value) {\n  if (isNaN(value)) {\n    return Kotlin.Long.ZERO;\n  } else if (value <= -Kotlin.Long.TWO_PWR_63_DBL_) {\n    return Kotlin.Long.MIN_VALUE;\n  } else if (value + 1 >= Kotlin.Long.TWO_PWR_63_DBL_) {\n    return Kotlin.Long.MAX_VALUE;\n  } else if (value < 0) {\n    return Kotlin.Long.fromNumber(-value).negate();\n  } else {\n    return new Kotlin.Long(\n        (value % Kotlin.Long.TWO_PWR_32_DBL_) | 0,\n        (value / Kotlin.Long.TWO_PWR_32_DBL_) | 0);\n  }\n};\n\n\n/**\n * Returns a Long representing the 64-bit integer that comes by concatenating\n * the given high and low bits.  Each is assumed to use 32 bits.\n * @param {number} lowBits The low 32-bits.\n * @param {number} highBits The high 32-bits.\n * @return {!Kotlin.Long} The corresponding Long value.\n */\nKotlin.Long.fromBits = function(lowBits, highBits) {\n  return new Kotlin.Long(lowBits, highBits);\n};\n\n\n/**\n * Returns a Long representation of the given string, written using the given\n * radix.\n * @param {string} str The textual representation of the Long.\n * @param {number=} opt_radix The radix in which the text is written.\n * @return {!Kotlin.Long} The corresponding Long value.\n */\nKotlin.Long.fromString = function(str, opt_radix) {\n  if (str.length == 0) {\n    throw Error('number format error: empty string');\n  }\n\n  var radix = opt_radix || 10;\n  if (radix < 2 || 36 < radix) {\n    throw Error('radix out of range: ' + radix);\n  }\n\n  if (str.charAt(0) == '-') {\n    return Kotlin.Long.fromString(str.substring(1), radix).negate();\n  } else if (str.indexOf('-') >= 0) {\n    throw Error('number format error: interior \"-\" character: ' + str);\n  }\n\n  // Do several (8) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n  var radixToPower = Kotlin.Long.fromNumber(Math.pow(radix, 8));\n\n  var result = Kotlin.Long.ZERO;\n  for (var i = 0; i < str.length; i += 8) {\n    var size = Math.min(8, str.length - i);\n    var value = parseInt(str.substring(i, i + size), radix);\n    if (size < 8) {\n      var power = Kotlin.Long.fromNumber(Math.pow(radix, size));\n      result = result.multiply(power).add(Kotlin.Long.fromNumber(value));\n    } else {\n      result = result.multiply(radixToPower);\n      result = result.add(Kotlin.Long.fromNumber(value));\n    }\n  }\n  return result;\n};\n\n\n// NOTE: the compiler should inline these constant values below and then remove\n// these variables, so there should be no runtime penalty for these.\n\n\n/**\n * Number used repeated below in calculations.  This must appear before the\n * first call to any from* function below.\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_16_DBL_ = 1 << 16;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_24_DBL_ = 1 << 24;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_32_DBL_ =\n    Kotlin.Long.TWO_PWR_16_DBL_ * Kotlin.Long.TWO_PWR_16_DBL_;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_31_DBL_ =\n    Kotlin.Long.TWO_PWR_32_DBL_ / 2;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_48_DBL_ =\n    Kotlin.Long.TWO_PWR_32_DBL_ * Kotlin.Long.TWO_PWR_16_DBL_;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_64_DBL_ =\n    Kotlin.Long.TWO_PWR_32_DBL_ * Kotlin.Long.TWO_PWR_32_DBL_;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_63_DBL_ =\n    Kotlin.Long.TWO_PWR_64_DBL_ / 2;\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.ZERO = Kotlin.Long.fromInt(0);\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.ONE = Kotlin.Long.fromInt(1);\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.NEG_ONE = Kotlin.Long.fromInt(-1);\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.MAX_VALUE =\n    Kotlin.Long.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0);\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.MIN_VALUE = Kotlin.Long.fromBits(0, 0x80000000 | 0);\n\n\n/**\n * @type {!Kotlin.Long}\n * @private\n */\nKotlin.Long.TWO_PWR_24_ = Kotlin.Long.fromInt(1 << 24);\n\n\n/** @return {number} The value, assuming it is a 32-bit integer. */\nKotlin.Long.prototype.toInt = function() {\n  return this.low_;\n};\n\n\n/** @return {number} The closest floating-point representation to this value. */\nKotlin.Long.prototype.toNumber = function() {\n  return this.high_ * Kotlin.Long.TWO_PWR_32_DBL_ +\n         this.getLowBitsUnsigned();\n};\n\n/** @return {number} The 32-bit hashCode of this value. */\nKotlin.Long.prototype.hashCode = function() {\n  return this.high_ ^ this.low_;\n};\n\n/**\n * @param {number=} opt_radix The radix in which the text should be written.\n * @return {string} The textual representation of this value.\n * @override\n */\nKotlin.Long.prototype.toString = function(opt_radix) {\n  var radix = opt_radix || 10;\n  if (radix < 2 || 36 < radix) {\n    throw Error('radix out of range: ' + radix);\n  }\n\n  if (this.isZero()) {\n    return '0';\n  }\n\n  if (this.isNegative()) {\n    if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n      // We need to change the Long value before it can be negated, so we remove\n      // the bottom-most digit in this base and then recurse to do the rest.\n      var radixLong = Kotlin.Long.fromNumber(radix);\n      var div = this.div(radixLong);\n      var rem = div.multiply(radixLong).subtract(this);\n      return div.toString(radix) + rem.toInt().toString(radix);\n    } else {\n      return '-' + this.negate().toString(radix);\n    }\n  }\n\n  // Do several (6) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n  var radixToPower = Kotlin.Long.fromNumber(Math.pow(radix, 6));\n\n  var rem = this;\n  var result = '';\n  while (true) {\n    var remDiv = rem.div(radixToPower);\n    var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();\n    var digits = intval.toString(radix);\n\n    rem = remDiv;\n    if (rem.isZero()) {\n      return digits + result;\n    } else {\n      while (digits.length < 6) {\n        digits = '0' + digits;\n      }\n      result = '' + digits + result;\n    }\n  }\n};\n\n\n/** @return {number} The high 32-bits as a signed value. */\nKotlin.Long.prototype.getHighBits = function() {\n  return this.high_;\n};\n\n\n/** @return {number} The low 32-bits as a signed value. */\nKotlin.Long.prototype.getLowBits = function() {\n  return this.low_;\n};\n\n\n/** @return {number} The low 32-bits as an unsigned value. */\nKotlin.Long.prototype.getLowBitsUnsigned = function() {\n  return (this.low_ >= 0) ?\n      this.low_ : Kotlin.Long.TWO_PWR_32_DBL_ + this.low_;\n};\n\n\n/**\n * @return {number} Returns the number of bits needed to represent the absolute\n *     value of this Long.\n */\nKotlin.Long.prototype.getNumBitsAbs = function() {\n  if (this.isNegative()) {\n    if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n      return 64;\n    } else {\n      return this.negate().getNumBitsAbs();\n    }\n  } else {\n    var val = this.high_ != 0 ? this.high_ : this.low_;\n    for (var bit = 31; bit > 0; bit--) {\n      if ((val & (1 << bit)) != 0) {\n        break;\n      }\n    }\n    return this.high_ != 0 ? bit + 33 : bit + 1;\n  }\n};\n\n\n/** @return {boolean} Whether this value is zero. */\nKotlin.Long.prototype.isZero = function() {\n  return this.high_ == 0 && this.low_ == 0;\n};\n\n\n/** @return {boolean} Whether this value is negative. */\nKotlin.Long.prototype.isNegative = function() {\n  return this.high_ < 0;\n};\n\n\n/** @return {boolean} Whether this value is odd. */\nKotlin.Long.prototype.isOdd = function() {\n  return (this.low_ & 1) == 1;\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long equals the other.\n */\nKotlin.Long.prototype.equalsLong = function(other) {\n  return (this.high_ == other.high_) && (this.low_ == other.low_);\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long does not equal the other.\n */\nKotlin.Long.prototype.notEqualsLong = function(other) {\n  return (this.high_ != other.high_) || (this.low_ != other.low_);\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long is less than the other.\n */\nKotlin.Long.prototype.lessThan = function(other) {\n  return this.compare(other) < 0;\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long is less than or equal to the other.\n */\nKotlin.Long.prototype.lessThanOrEqual = function(other) {\n  return this.compare(other) <= 0;\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long is greater than the other.\n */\nKotlin.Long.prototype.greaterThan = function(other) {\n  return this.compare(other) > 0;\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long is greater than or equal to the other.\n */\nKotlin.Long.prototype.greaterThanOrEqual = function(other) {\n  return this.compare(other) >= 0;\n};\n\n\n/**\n * Compares this Long with the given one.\n * @param {Kotlin.Long} other Long to compare against.\n * @return {number} 0 if they are the same, 1 if the this is greater, and -1\n *     if the given one is greater.\n */\nKotlin.Long.prototype.compare = function(other) {\n  if (this.equalsLong(other)) {\n    return 0;\n  }\n\n  var thisNeg = this.isNegative();\n  var otherNeg = other.isNegative();\n  if (thisNeg && !otherNeg) {\n    return -1;\n  }\n  if (!thisNeg && otherNeg) {\n    return 1;\n  }\n\n  // at this point, the signs are the same, so subtraction will not overflow\n  if (this.subtract(other).isNegative()) {\n    return -1;\n  } else {\n    return 1;\n  }\n};\n\n\n/** @return {!Kotlin.Long} The negation of this value. */\nKotlin.Long.prototype.negate = function() {\n  if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    return Kotlin.Long.MIN_VALUE;\n  } else {\n    return this.not().add(Kotlin.Long.ONE);\n  }\n};\n\n\n/**\n * Returns the sum of this and the given Long.\n * @param {Kotlin.Long} other Long to add to this one.\n * @return {!Kotlin.Long} The sum of this and the given Long.\n */\nKotlin.Long.prototype.add = function(other) {\n  // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n\n  var a48 = this.high_ >>> 16;\n  var a32 = this.high_ & 0xFFFF;\n  var a16 = this.low_ >>> 16;\n  var a00 = this.low_ & 0xFFFF;\n\n  var b48 = other.high_ >>> 16;\n  var b32 = other.high_ & 0xFFFF;\n  var b16 = other.low_ >>> 16;\n  var b00 = other.low_ & 0xFFFF;\n\n  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n  c00 += a00 + b00;\n  c16 += c00 >>> 16;\n  c00 &= 0xFFFF;\n  c16 += a16 + b16;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c32 += a32 + b32;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c48 += a48 + b48;\n  c48 &= 0xFFFF;\n  return Kotlin.Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);\n};\n\n\n/**\n * Returns the difference of this and the given Long.\n * @param {Kotlin.Long} other Long to subtract from this.\n * @return {!Kotlin.Long} The difference of this and the given Long.\n */\nKotlin.Long.prototype.subtract = function(other) {\n  return this.add(other.negate());\n};\n\n\n/**\n * Returns the product of this and the given long.\n * @param {Kotlin.Long} other Long to multiply with this.\n * @return {!Kotlin.Long} The product of this and the other.\n */\nKotlin.Long.prototype.multiply = function(other) {\n  if (this.isZero()) {\n    return Kotlin.Long.ZERO;\n  } else if (other.isZero()) {\n    return Kotlin.Long.ZERO;\n  }\n\n  if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    return other.isOdd() ? Kotlin.Long.MIN_VALUE : Kotlin.Long.ZERO;\n  } else if (other.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    return this.isOdd() ? Kotlin.Long.MIN_VALUE : Kotlin.Long.ZERO;\n  }\n\n  if (this.isNegative()) {\n    if (other.isNegative()) {\n      return this.negate().multiply(other.negate());\n    } else {\n      return this.negate().multiply(other).negate();\n    }\n  } else if (other.isNegative()) {\n    return this.multiply(other.negate()).negate();\n  }\n\n  // If both longs are small, use float multiplication\n  if (this.lessThan(Kotlin.Long.TWO_PWR_24_) &&\n      other.lessThan(Kotlin.Long.TWO_PWR_24_)) {\n    return Kotlin.Long.fromNumber(this.toNumber() * other.toNumber());\n  }\n\n  // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n  // We can skip products that would overflow.\n\n  var a48 = this.high_ >>> 16;\n  var a32 = this.high_ & 0xFFFF;\n  var a16 = this.low_ >>> 16;\n  var a00 = this.low_ & 0xFFFF;\n\n  var b48 = other.high_ >>> 16;\n  var b32 = other.high_ & 0xFFFF;\n  var b16 = other.low_ >>> 16;\n  var b00 = other.low_ & 0xFFFF;\n\n  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n  c00 += a00 * b00;\n  c16 += c00 >>> 16;\n  c00 &= 0xFFFF;\n  c16 += a16 * b00;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c16 += a00 * b16;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c32 += a32 * b00;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c32 += a16 * b16;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c32 += a00 * b32;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n  c48 &= 0xFFFF;\n  return Kotlin.Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);\n};\n\n\n/**\n * Returns this Long divided by the given one.\n * @param {Kotlin.Long} other Long by which to divide.\n * @return {!Kotlin.Long} This Long divided by the given one.\n */\nKotlin.Long.prototype.div = function(other) {\n  if (other.isZero()) {\n    throw Error('division by zero');\n  } else if (this.isZero()) {\n    return Kotlin.Long.ZERO;\n  }\n\n  if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    if (other.equalsLong(Kotlin.Long.ONE) ||\n        other.equalsLong(Kotlin.Long.NEG_ONE)) {\n      return Kotlin.Long.MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE\n    } else if (other.equalsLong(Kotlin.Long.MIN_VALUE)) {\n      return Kotlin.Long.ONE;\n    } else {\n      // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n      var halfThis = this.shiftRight(1);\n      var approx = halfThis.div(other).shiftLeft(1);\n      if (approx.equalsLong(Kotlin.Long.ZERO)) {\n        return other.isNegative() ? Kotlin.Long.ONE : Kotlin.Long.NEG_ONE;\n      } else {\n        var rem = this.subtract(other.multiply(approx));\n        var result = approx.add(rem.div(other));\n        return result;\n      }\n    }\n  } else if (other.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    return Kotlin.Long.ZERO;\n  }\n\n  if (this.isNegative()) {\n    if (other.isNegative()) {\n      return this.negate().div(other.negate());\n    } else {\n      return this.negate().div(other).negate();\n    }\n  } else if (other.isNegative()) {\n    return this.div(other.negate()).negate();\n  }\n\n  // Repeat the following until the remainder is less than other:  find a\n  // floating-point that approximates remainder / other *from below*, add this\n  // into the result, and subtract it from the remainder.  It is critical that\n  // the approximate value is less than or equal to the real value so that the\n  // remainder never becomes negative.\n  var res = Kotlin.Long.ZERO;\n  var rem = this;\n  while (rem.greaterThanOrEqual(other)) {\n    // Approximate the result of division. This may be a little greater or\n    // smaller than the actual value.\n    var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));\n\n    // We will tweak the approximate result by changing it in the 48-th digit or\n    // the smallest non-fractional digit, whichever is larger.\n    var log2 = Math.ceil(Math.log(approx) / Math.LN2);\n    var delta = (log2 <= 48) ? 1 : Math.pow(2, log2 - 48);\n\n    // Decrease the approximation until it is smaller than the remainder.  Note\n    // that if it is too large, the product overflows and is negative.\n    var approxRes = Kotlin.Long.fromNumber(approx);\n    var approxRem = approxRes.multiply(other);\n    while (approxRem.isNegative() || approxRem.greaterThan(rem)) {\n      approx -= delta;\n      approxRes = Kotlin.Long.fromNumber(approx);\n      approxRem = approxRes.multiply(other);\n    }\n\n    // We know the answer can't be zero... and actually, zero would cause\n    // infinite recursion since we would make no progress.\n    if (approxRes.isZero()) {\n      approxRes = Kotlin.Long.ONE;\n    }\n\n    res = res.add(approxRes);\n    rem = rem.subtract(approxRem);\n  }\n  return res;\n};\n\n\n/**\n * Returns this Long modulo the given one.\n * @param {Kotlin.Long} other Long by which to mod.\n * @return {!Kotlin.Long} This Long modulo the given one.\n */\nKotlin.Long.prototype.modulo = function(other) {\n  return this.subtract(this.div(other).multiply(other));\n};\n\n\n/** @return {!Kotlin.Long} The bitwise-NOT of this value. */\nKotlin.Long.prototype.not = function() {\n  return Kotlin.Long.fromBits(~this.low_, ~this.high_);\n};\n\n\n/**\n * Returns the bitwise-AND of this Long and the given one.\n * @param {Kotlin.Long} other The Long with which to AND.\n * @return {!Kotlin.Long} The bitwise-AND of this and the other.\n */\nKotlin.Long.prototype.and = function(other) {\n  return Kotlin.Long.fromBits(this.low_ & other.low_,\n                                 this.high_ & other.high_);\n};\n\n\n/**\n * Returns the bitwise-OR of this Long and the given one.\n * @param {Kotlin.Long} other The Long with which to OR.\n * @return {!Kotlin.Long} The bitwise-OR of this and the other.\n */\nKotlin.Long.prototype.or = function(other) {\n  return Kotlin.Long.fromBits(this.low_ | other.low_,\n                                 this.high_ | other.high_);\n};\n\n\n/**\n * Returns the bitwise-XOR of this Long and the given one.\n * @param {Kotlin.Long} other The Long with which to XOR.\n * @return {!Kotlin.Long} The bitwise-XOR of this and the other.\n */\nKotlin.Long.prototype.xor = function(other) {\n  return Kotlin.Long.fromBits(this.low_ ^ other.low_,\n                                 this.high_ ^ other.high_);\n};\n\n\n/**\n * Returns this Long with bits shifted to the left by the given amount.\n * @param {number} numBits The number of bits by which to shift.\n * @return {!Kotlin.Long} This shifted to the left by the given amount.\n */\nKotlin.Long.prototype.shiftLeft = function(numBits) {\n  numBits &= 63;\n  if (numBits == 0) {\n    return this;\n  } else {\n    var low = this.low_;\n    if (numBits < 32) {\n      var high = this.high_;\n      return Kotlin.Long.fromBits(\n          low << numBits,\n          (high << numBits) | (low >>> (32 - numBits)));\n    } else {\n      return Kotlin.Long.fromBits(0, low << (numBits - 32));\n    }\n  }\n};\n\n\n/**\n * Returns this Long with bits shifted to the right by the given amount.\n * @param {number} numBits The number of bits by which to shift.\n * @return {!Kotlin.Long} This shifted to the right by the given amount.\n */\nKotlin.Long.prototype.shiftRight = function(numBits) {\n  numBits &= 63;\n  if (numBits == 0) {\n    return this;\n  } else {\n    var high = this.high_;\n    if (numBits < 32) {\n      var low = this.low_;\n      return Kotlin.Long.fromBits(\n          (low >>> numBits) | (high << (32 - numBits)),\n          high >> numBits);\n    } else {\n      return Kotlin.Long.fromBits(\n          high >> (numBits - 32),\n          high >= 0 ? 0 : -1);\n    }\n  }\n};\n\n\n/**\n * Returns this Long with bits shifted to the right by the given amount, with\n * zeros placed into the new leading bits.\n * @param {number} numBits The number of bits by which to shift.\n * @return {!Kotlin.Long} This shifted to the right by the given amount, with\n *     zeros placed into the new leading bits.\n */\nKotlin.Long.prototype.shiftRightUnsigned = function(numBits) {\n  numBits &= 63;\n  if (numBits == 0) {\n    return this;\n  } else {\n    var high = this.high_;\n    if (numBits < 32) {\n      var low = this.low_;\n      return Kotlin.Long.fromBits(\n          (low >>> numBits) | (high << (32 - numBits)),\n          high >>> numBits);\n    } else if (numBits == 32) {\n      return Kotlin.Long.fromBits(high, 0);\n    } else {\n      return Kotlin.Long.fromBits(high >>> (numBits - 32), 0);\n    }\n  }\n};\n\n// Support for Kotlin\nKotlin.Long.prototype.equals = function (other) {\n    return other instanceof Kotlin.Long && this.equalsLong(other);\n};\n\nKotlin.Long.prototype.compareTo_11rb$ = Kotlin.Long.prototype.compare;\n\nKotlin.Long.prototype.inc = function() {\n    return this.add(Kotlin.Long.ONE);\n};\n\nKotlin.Long.prototype.dec = function() {\n    return this.add(Kotlin.Long.NEG_ONE);\n};\n\nKotlin.Long.prototype.valueOf = function() {\n    return this.toNumber();\n};\n\nKotlin.Long.prototype.unaryPlus = function() {\n    return this;\n};\n\nKotlin.Long.prototype.unaryMinus = Kotlin.Long.prototype.negate;\nKotlin.Long.prototype.inv = Kotlin.Long.prototype.not;\n\nKotlin.Long.prototype.rangeTo = function (other) {\n    return new Kotlin.kotlin.ranges.LongRange(this, other);\n};","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.Kind = {\n    CLASS: \"class\",\n    INTERFACE: \"interface\",\n    OBJECT: \"object\"\n};\n\nKotlin.callGetter = function (thisObject, klass, propertyName) {\n    var propertyDescriptor = Object.getOwnPropertyDescriptor(klass, propertyName);\n    if (propertyDescriptor != null && propertyDescriptor.get != null) {\n        return propertyDescriptor.get.call(thisObject);\n    }\n\n    propertyDescriptor = Object.getOwnPropertyDescriptor(thisObject, propertyName);\n    if (propertyDescriptor != null && \"value\" in propertyDescriptor) {\n        return thisObject[propertyName];\n    }\n\n    return Kotlin.callGetter(thisObject, Object.getPrototypeOf(klass), propertyName);\n};\n\nKotlin.callSetter = function (thisObject, klass, propertyName, value) {\n    var propertyDescriptor = Object.getOwnPropertyDescriptor(klass, propertyName);\n    if (propertyDescriptor != null && propertyDescriptor.set != null) {\n        propertyDescriptor.set.call(thisObject, value);\n        return;\n    }\n\n    propertyDescriptor = Object.getOwnPropertyDescriptor(thisObject, propertyName);\n    if (propertyDescriptor != null && \"value\" in propertyDescriptor) {\n        thisObject[propertyName] = value;\n        return\n    }\n\n    Kotlin.callSetter(thisObject, Object.getPrototypeOf(klass), propertyName, value);\n};\n\nfunction isInheritanceFromInterface(ctor, iface) {\n    if (ctor === iface) return true;\n\n    var metadata = ctor.$metadata$;\n    if (metadata != null) {\n        var interfaces = metadata.interfaces;\n        for (var i = 0; i < interfaces.length; i++) {\n            if (isInheritanceFromInterface(interfaces[i], iface)) {\n                return true;\n            }\n        }\n    }\n\n    var superPrototype = ctor.prototype != null ? Object.getPrototypeOf(ctor.prototype) : null;\n    var superConstructor = superPrototype != null ? superPrototype.constructor : null;\n    return superConstructor != null && isInheritanceFromInterface(superConstructor, iface);\n}\n\n/**\n *\n * @param {*} object\n * @param {Function|Object} klass\n * @returns {Boolean}\n */\nKotlin.isType = function (object, klass) {\n    if (klass === Object) {\n        switch (typeof object) {\n            case \"string\":\n            case \"number\":\n            case \"boolean\":\n            case \"function\":\n                return true;\n            default:\n                return object instanceof Object;\n        }\n    }\n\n    if (object == null || klass == null || (typeof object !== 'object' && typeof object !== 'function')) {\n        return false;\n    }\n\n    if (typeof klass === \"function\" && object instanceof klass) {\n        return true;\n    }\n\n    var proto = Object.getPrototypeOf(klass);\n    var constructor = proto != null ? proto.constructor : null;\n    if (constructor != null && \"$metadata$\" in constructor) {\n        var metadata = constructor.$metadata$;\n        if (metadata.kind === Kotlin.Kind.OBJECT) {\n            return object === klass;\n        }\n    }\n\n    var klassMetadata = klass.$metadata$;\n\n    // In WebKit (JavaScriptCore) for some interfaces from DOM typeof returns \"object\", nevertheless they can be used in RHS of instanceof\n    if (klassMetadata == null) {\n        return object instanceof klass;\n    }\n\n    if (klassMetadata.kind === Kotlin.Kind.INTERFACE && object.constructor != null) {\n        return isInheritanceFromInterface(object.constructor, klass);\n    }\n\n    return false;\n};\n\nKotlin.isNumber = function (a) {\n    return typeof a == \"number\" || a instanceof Kotlin.Long;\n};\n\nKotlin.isChar = function (value) {\n    return value instanceof Kotlin.BoxedChar\n};\n\nKotlin.isComparable = function (value) {\n    var type = typeof value;\n\n    return type === \"string\" ||\n           type === \"boolean\" ||\n           Kotlin.isNumber(value) ||\n           Kotlin.isType(value, Kotlin.kotlin.Comparable);\n};\n\nKotlin.isCharSequence = function (value) {\n    return typeof value === \"string\" || Kotlin.isType(value, Kotlin.kotlin.CharSequence);\n};","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\npublic class Enum<T : Enum<T>> : Comparable<Enum<T>> {\n    @JsName(\"name$\") private var _name: String = \"\"\n    @JsName(\"ordinal$\") private var _ordinal: Int = 0\n\n    val name: String\n        get() = _name\n\n    val ordinal: Int\n        get() = _ordinal\n\n    override fun compareTo(other: Enum<T>) = ordinal.compareTo(other.ordinal)\n\n    override fun equals(other: Any?) = this === other\n\n    override fun hashCode(): Int = js(\"Kotlin.identityHashCode\")(this)\n\n    override fun toString() = name\n\n    companion object\n}",null,null,"/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"ArraysKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component1(): Byte {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component1(): Short {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component1(): Int {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component1(): Long {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component1(): Float {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component1(): Double {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component1(): Boolean {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component1(): Char {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component2(): Byte {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component2(): Short {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component2(): Int {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component2(): Long {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component2(): Float {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component2(): Double {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component2(): Boolean {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component2(): Char {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component3(): Byte {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component3(): Short {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component3(): Int {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component3(): Long {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component3(): Float {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component3(): Double {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component3(): Boolean {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component3(): Char {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component4(): Byte {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component4(): Short {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component4(): Int {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component4(): Long {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component4(): Float {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component4(): Double {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component4(): Boolean {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component4(): Char {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component5(): Byte {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component5(): Short {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component5(): Int {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component5(): Long {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component5(): Float {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component5(): Double {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component5(): Boolean {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component5(): Char {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.contains(element: T): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun ByteArray.contains(element: Byte): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun ShortArray.contains(element: Short): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun IntArray.contains(element: Int): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun LongArray.contains(element: Long): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun FloatArray.contains(element: Float): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun DoubleArray.contains(element: Double): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun BooleanArray.contains(element: Boolean): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun CharArray.contains(element: Char): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun <T> Array<out T>.elementAt(index: Int): T\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun ByteArray.elementAt(index: Int): Byte\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun ShortArray.elementAt(index: Int): Short\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun IntArray.elementAt(index: Int): Int\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun LongArray.elementAt(index: Int): Long\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun FloatArray.elementAt(index: Int): Float\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun DoubleArray.elementAt(index: Int): Double\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun BooleanArray.elementAt(index: Int): Boolean\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun CharArray.elementAt(index: Int): Char\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Byte): Byte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Short): Short {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Int): Int {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Long): Long {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Float): Float {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Double): Double {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Boolean): Boolean {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.elementAtOrNull(index: Int): Byte? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.elementAtOrNull(index: Int): Short? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.elementAtOrNull(index: Int): Int? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.elementAtOrNull(index: Int): Long? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.elementAtOrNull(index: Int): Float? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.elementAtOrNull(index: Int): Double? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.elementAtOrNull(index: Int): Boolean? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.elementAtOrNull(index: Int): Char? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.find(predicate: (Byte) -> Boolean): Byte? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.find(predicate: (Short) -> Boolean): Short? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.find(predicate: (Int) -> Boolean): Int? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.find(predicate: (Long) -> Boolean): Long? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.find(predicate: (Float) -> Boolean): Float? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.find(predicate: (Double) -> Boolean): Double? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.find(predicate: (Boolean) -> Boolean): Boolean? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.find(predicate: (Char) -> Boolean): Char? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.findLast(predicate: (Byte) -> Boolean): Byte? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.findLast(predicate: (Short) -> Boolean): Short? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.findLast(predicate: (Int) -> Boolean): Int? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.findLast(predicate: (Long) -> Boolean): Long? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.findLast(predicate: (Float) -> Boolean): Float? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.findLast(predicate: (Double) -> Boolean): Double? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.findLast(predicate: (Boolean) -> Boolean): Boolean? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.findLast(predicate: (Char) -> Boolean): Char? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun <T> Array<out T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun ByteArray.first(): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun ShortArray.first(): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun IntArray.first(): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun LongArray.first(): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun FloatArray.first(): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun DoubleArray.first(): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun BooleanArray.first(): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun CharArray.first(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Array<out T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun ByteArray.first(predicate: (Byte) -> Boolean): Byte {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun ShortArray.first(predicate: (Short) -> Boolean): Short {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun IntArray.first(predicate: (Int) -> Boolean): Int {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun LongArray.first(predicate: (Long) -> Boolean): Long {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun FloatArray.first(predicate: (Float) -> Boolean): Float {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun DoubleArray.first(predicate: (Double) -> Boolean): Double {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun BooleanArray.first(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun CharArray.first(predicate: (Char) -> Boolean): Char {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun <T> Array<out T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun ByteArray.firstOrNull(): Byte? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun ShortArray.firstOrNull(): Short? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun IntArray.firstOrNull(): Int? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun LongArray.firstOrNull(): Long? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun FloatArray.firstOrNull(): Float? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun DoubleArray.firstOrNull(): Double? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun BooleanArray.firstOrNull(): Boolean? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun CharArray.firstOrNull(): Char? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Array<out T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun ByteArray.firstOrNull(predicate: (Byte) -> Boolean): Byte? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun ShortArray.firstOrNull(predicate: (Short) -> Boolean): Short? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun IntArray.firstOrNull(predicate: (Int) -> Boolean): Int? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun LongArray.firstOrNull(predicate: (Long) -> Boolean): Long? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun FloatArray.firstOrNull(predicate: (Float) -> Boolean): Float? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun DoubleArray.firstOrNull(predicate: (Double) -> Boolean): Double? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun BooleanArray.firstOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun CharArray.firstOrNull(predicate: (Char) -> Boolean): Char? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.getOrElse(index: Int, defaultValue: (Int) -> Byte): Byte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.getOrElse(index: Int, defaultValue: (Int) -> Short): Short {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.getOrElse(index: Int, defaultValue: (Int) -> Int): Int {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.getOrElse(index: Int, defaultValue: (Int) -> Long): Long {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.getOrElse(index: Int, defaultValue: (Int) -> Float): Float {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.getOrElse(index: Int, defaultValue: (Int) -> Double): Double {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.getOrElse(index: Int, defaultValue: (Int) -> Boolean): Boolean {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.getOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\npublic fun <T> Array<out T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\npublic fun ByteArray.getOrNull(index: Int): Byte? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\npublic fun ShortArray.getOrNull(index: Int): Short? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\npublic fun IntArray.getOrNull(index: Int): Int? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\npublic fun LongArray.getOrNull(index: Int): Long? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\npublic fun FloatArray.getOrNull(index: Int): Float? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\npublic fun DoubleArray.getOrNull(index: Int): Double? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\npublic fun BooleanArray.getOrNull(index: Int): Boolean? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\npublic fun CharArray.getOrNull(index: Int): Char? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.indexOf(element: T): Int {\n    if (element == null) {\n        for (index in indices) {\n            if (this[index] == null) {\n                return index\n            }\n        }\n    } else {\n        for (index in indices) {\n            if (element == this[index]) {\n                return index\n            }\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun ByteArray.indexOf(element: Byte): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun ShortArray.indexOf(element: Short): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun IntArray.indexOf(element: Int): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun LongArray.indexOf(element: Long): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun FloatArray.indexOf(element: Float): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun DoubleArray.indexOf(element: Double): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun BooleanArray.indexOf(element: Boolean): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun CharArray.indexOf(element: Char): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun <T> Array<out T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ByteArray.indexOfFirst(predicate: (Byte) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ShortArray.indexOfFirst(predicate: (Short) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun IntArray.indexOfFirst(predicate: (Int) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun LongArray.indexOfFirst(predicate: (Long) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun FloatArray.indexOfFirst(predicate: (Float) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun DoubleArray.indexOfFirst(predicate: (Double) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun BooleanArray.indexOfFirst(predicate: (Boolean) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun CharArray.indexOfFirst(predicate: (Char) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun <T> Array<out T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ByteArray.indexOfLast(predicate: (Byte) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ShortArray.indexOfLast(predicate: (Short) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun IntArray.indexOfLast(predicate: (Int) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun LongArray.indexOfLast(predicate: (Long) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun FloatArray.indexOfLast(predicate: (Float) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun DoubleArray.indexOfLast(predicate: (Double) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun BooleanArray.indexOfLast(predicate: (Boolean) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun CharArray.indexOfLast(predicate: (Char) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun <T> Array<out T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun ByteArray.last(): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun ShortArray.last(): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun IntArray.last(): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun LongArray.last(): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun FloatArray.last(): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun DoubleArray.last(): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun BooleanArray.last(): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun CharArray.last(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Array<out T>.last(predicate: (T) -> Boolean): T {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun ByteArray.last(predicate: (Byte) -> Boolean): Byte {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun ShortArray.last(predicate: (Short) -> Boolean): Short {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun IntArray.last(predicate: (Int) -> Boolean): Int {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun LongArray.last(predicate: (Long) -> Boolean): Long {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun FloatArray.last(predicate: (Float) -> Boolean): Float {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun DoubleArray.last(predicate: (Double) -> Boolean): Double {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun BooleanArray.last(predicate: (Boolean) -> Boolean): Boolean {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun CharArray.last(predicate: (Char) -> Boolean): Char {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.lastIndexOf(element: T): Int {\n    if (element == null) {\n        for (index in indices.reversed()) {\n            if (this[index] == null) {\n                return index\n            }\n        }\n    } else {\n        for (index in indices.reversed()) {\n            if (element == this[index]) {\n                return index\n            }\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun ByteArray.lastIndexOf(element: Byte): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun ShortArray.lastIndexOf(element: Short): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun IntArray.lastIndexOf(element: Int): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun LongArray.lastIndexOf(element: Long): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun FloatArray.lastIndexOf(element: Float): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun DoubleArray.lastIndexOf(element: Double): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun BooleanArray.lastIndexOf(element: Boolean): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun CharArray.lastIndexOf(element: Char): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun <T> Array<out T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun ByteArray.lastOrNull(): Byte? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun ShortArray.lastOrNull(): Short? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun IntArray.lastOrNull(): Int? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun LongArray.lastOrNull(): Long? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun FloatArray.lastOrNull(): Float? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun DoubleArray.lastOrNull(): Double? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun BooleanArray.lastOrNull(): Boolean? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun CharArray.lastOrNull(): Char? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> Array<out T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun ByteArray.lastOrNull(predicate: (Byte) -> Boolean): Byte? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun ShortArray.lastOrNull(predicate: (Short) -> Boolean): Short? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun IntArray.lastOrNull(predicate: (Int) -> Boolean): Int? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun LongArray.lastOrNull(predicate: (Long) -> Boolean): Long? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun FloatArray.lastOrNull(predicate: (Float) -> Boolean): Float? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun DoubleArray.lastOrNull(predicate: (Double) -> Boolean): Double? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun BooleanArray.lastOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun CharArray.lastOrNull(predicate: (Char) -> Boolean): Char? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.random(): Byte {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.random(): Short {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.random(): Int {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.random(): Long {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.random(): Float {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.random(): Double {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.random(): Boolean {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.random(): Char {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Array<out T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun ByteArray.random(random: Random): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun ShortArray.random(random: Random): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun IntArray.random(random: Random): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun LongArray.random(random: Random): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun FloatArray.random(random: Random): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun DoubleArray.random(random: Random): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun BooleanArray.random(random: Random): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun CharArray.random(random: Random): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.randomOrNull(): T? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.randomOrNull(): Byte? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.randomOrNull(): Short? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.randomOrNull(): Int? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.randomOrNull(): Long? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.randomOrNull(): Float? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.randomOrNull(): Double? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.randomOrNull(): Boolean? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.randomOrNull(): Char? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun <T> Array<out T>.randomOrNull(random: Random): T? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun ByteArray.randomOrNull(random: Random): Byte? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun ShortArray.randomOrNull(random: Random): Short? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun IntArray.randomOrNull(random: Random): Int? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun LongArray.randomOrNull(random: Random): Long? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun FloatArray.randomOrNull(random: Random): Float? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun DoubleArray.randomOrNull(random: Random): Double? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun BooleanArray.randomOrNull(random: Random): Boolean? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun CharArray.randomOrNull(random: Random): Char? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun <T> Array<out T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun ByteArray.single(): Byte {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun ShortArray.single(): Short {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun IntArray.single(): Int {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun LongArray.single(): Long {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun FloatArray.single(): Float {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun DoubleArray.single(): Double {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun BooleanArray.single(): Boolean {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun CharArray.single(): Char {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Array<out T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun ByteArray.single(predicate: (Byte) -> Boolean): Byte {\n    var single: Byte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Byte\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun ShortArray.single(predicate: (Short) -> Boolean): Short {\n    var single: Short? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Short\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun IntArray.single(predicate: (Int) -> Boolean): Int {\n    var single: Int? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Int\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun LongArray.single(predicate: (Long) -> Boolean): Long {\n    var single: Long? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Long\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun FloatArray.single(predicate: (Float) -> Boolean): Float {\n    var single: Float? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Float\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun DoubleArray.single(predicate: (Double) -> Boolean): Double {\n    var single: Double? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Double\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun BooleanArray.single(predicate: (Boolean) -> Boolean): Boolean {\n    var single: Boolean? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Boolean\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun CharArray.single(predicate: (Char) -> Boolean): Char {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Char\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun <T> Array<out T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun ByteArray.singleOrNull(): Byte? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun ShortArray.singleOrNull(): Short? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun IntArray.singleOrNull(): Int? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun LongArray.singleOrNull(): Long? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun FloatArray.singleOrNull(): Float? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun DoubleArray.singleOrNull(): Double? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun BooleanArray.singleOrNull(): Boolean? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun CharArray.singleOrNull(): Char? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Array<out T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun ByteArray.singleOrNull(predicate: (Byte) -> Boolean): Byte? {\n    var single: Byte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun ShortArray.singleOrNull(predicate: (Short) -> Boolean): Short? {\n    var single: Short? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun IntArray.singleOrNull(predicate: (Int) -> Boolean): Int? {\n    var single: Int? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun LongArray.singleOrNull(predicate: (Long) -> Boolean): Long? {\n    var single: Long? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun FloatArray.singleOrNull(predicate: (Float) -> Boolean): Float? {\n    var single: Float? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun DoubleArray.singleOrNull(predicate: (Double) -> Boolean): Double? {\n    var single: Double? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun BooleanArray.singleOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    var single: Boolean? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun CharArray.singleOrNull(predicate: (Char) -> Boolean): Char? {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Array<out T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ByteArray.drop(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ShortArray.drop(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun IntArray.drop(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun LongArray.drop(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun FloatArray.drop(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun DoubleArray.drop(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun BooleanArray.drop(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun CharArray.drop(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Array<out T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ByteArray.dropLast(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ShortArray.dropLast(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun IntArray.dropLast(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun LongArray.dropLast(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun FloatArray.dropLast(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun DoubleArray.dropLast(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun BooleanArray.dropLast(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun CharArray.dropLast(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Array<out T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ByteArray.dropLastWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ShortArray.dropLastWhile(predicate: (Short) -> Boolean): List<Short> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun IntArray.dropLastWhile(predicate: (Int) -> Boolean): List<Int> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun LongArray.dropLastWhile(predicate: (Long) -> Boolean): List<Long> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun FloatArray.dropLastWhile(predicate: (Float) -> Boolean): List<Float> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun DoubleArray.dropLastWhile(predicate: (Double) -> Boolean): List<Double> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun BooleanArray.dropLastWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun CharArray.dropLastWhile(predicate: (Char) -> Boolean): List<Char> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Array<out T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ByteArray.dropWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    var yielding = false\n    val list = ArrayList<Byte>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ShortArray.dropWhile(predicate: (Short) -> Boolean): List<Short> {\n    var yielding = false\n    val list = ArrayList<Short>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun IntArray.dropWhile(predicate: (Int) -> Boolean): List<Int> {\n    var yielding = false\n    val list = ArrayList<Int>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun LongArray.dropWhile(predicate: (Long) -> Boolean): List<Long> {\n    var yielding = false\n    val list = ArrayList<Long>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun FloatArray.dropWhile(predicate: (Float) -> Boolean): List<Float> {\n    var yielding = false\n    val list = ArrayList<Float>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun DoubleArray.dropWhile(predicate: (Double) -> Boolean): List<Double> {\n    var yielding = false\n    val list = ArrayList<Double>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun BooleanArray.dropWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    var yielding = false\n    val list = ArrayList<Boolean>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun CharArray.dropWhile(predicate: (Char) -> Boolean): List<Char> {\n    var yielding = false\n    val list = ArrayList<Char>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Array<out T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ByteArray.filter(predicate: (Byte) -> Boolean): List<Byte> {\n    return filterTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ShortArray.filter(predicate: (Short) -> Boolean): List<Short> {\n    return filterTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun IntArray.filter(predicate: (Int) -> Boolean): List<Int> {\n    return filterTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun LongArray.filter(predicate: (Long) -> Boolean): List<Long> {\n    return filterTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun FloatArray.filter(predicate: (Float) -> Boolean): List<Float> {\n    return filterTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun DoubleArray.filter(predicate: (Double) -> Boolean): List<Double> {\n    return filterTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun BooleanArray.filter(predicate: (Boolean) -> Boolean): List<Boolean> {\n    return filterTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun CharArray.filter(predicate: (Char) -> Boolean): List<Char> {\n    return filterTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T> Array<out T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun ByteArray.filterIndexed(predicate: (index: Int, Byte) -> Boolean): List<Byte> {\n    return filterIndexedTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun ShortArray.filterIndexed(predicate: (index: Int, Short) -> Boolean): List<Short> {\n    return filterIndexedTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun IntArray.filterIndexed(predicate: (index: Int, Int) -> Boolean): List<Int> {\n    return filterIndexedTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun LongArray.filterIndexed(predicate: (index: Int, Long) -> Boolean): List<Long> {\n    return filterIndexedTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun FloatArray.filterIndexed(predicate: (index: Int, Float) -> Boolean): List<Float> {\n    return filterIndexedTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun DoubleArray.filterIndexed(predicate: (index: Int, Double) -> Boolean): List<Double> {\n    return filterIndexedTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun BooleanArray.filterIndexed(predicate: (index: Int, Boolean) -> Boolean): List<Boolean> {\n    return filterIndexedTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun CharArray.filterIndexed(predicate: (index: Int, Char) -> Boolean): List<Char> {\n    return filterIndexedTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterIndexedTo(destination: C, predicate: (index: Int, Byte) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterIndexedTo(destination: C, predicate: (index: Int, Short) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterIndexedTo(destination: C, predicate: (index: Int, Int) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterIndexedTo(destination: C, predicate: (index: Int, Long) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterIndexedTo(destination: C, predicate: (index: Int, Float) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterIndexedTo(destination: C, predicate: (index: Int, Double) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterIndexedTo(destination: C, predicate: (index: Int, Boolean) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterIndexedTo(destination: C, predicate: (index: Int, Char) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n */\npublic inline fun <reified R> Array<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Array<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Array<out T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ByteArray.filterNot(predicate: (Byte) -> Boolean): List<Byte> {\n    return filterNotTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ShortArray.filterNot(predicate: (Short) -> Boolean): List<Short> {\n    return filterNotTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun IntArray.filterNot(predicate: (Int) -> Boolean): List<Int> {\n    return filterNotTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun LongArray.filterNot(predicate: (Long) -> Boolean): List<Long> {\n    return filterNotTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun FloatArray.filterNot(predicate: (Float) -> Boolean): List<Float> {\n    return filterNotTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun DoubleArray.filterNot(predicate: (Double) -> Boolean): List<Double> {\n    return filterNotTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun BooleanArray.filterNot(predicate: (Boolean) -> Boolean): List<Boolean> {\n    return filterNotTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun CharArray.filterNot(predicate: (Char) -> Boolean): List<Char> {\n    return filterNotTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNull\n */\npublic fun <T : Any> Array<out T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n */\npublic fun <C : MutableCollection<in T>, T : Any> Array<out T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterNotTo(destination: C, predicate: (Byte) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterNotTo(destination: C, predicate: (Short) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterNotTo(destination: C, predicate: (Int) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterNotTo(destination: C, predicate: (Long) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterNotTo(destination: C, predicate: (Float) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterNotTo(destination: C, predicate: (Double) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterNotTo(destination: C, predicate: (Boolean) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterNotTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterTo(destination: C, predicate: (Byte) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterTo(destination: C, predicate: (Short) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterTo(destination: C, predicate: (Int) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterTo(destination: C, predicate: (Long) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterTo(destination: C, predicate: (Float) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterTo(destination: C, predicate: (Double) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterTo(destination: C, predicate: (Boolean) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> Array<out T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun ByteArray.slice(indices: IntRange): List<Byte> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun ShortArray.slice(indices: IntRange): List<Short> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun IntArray.slice(indices: IntRange): List<Int> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun LongArray.slice(indices: IntRange): List<Long> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun FloatArray.slice(indices: IntRange): List<Float> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun DoubleArray.slice(indices: IntRange): List<Double> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun BooleanArray.slice(indices: IntRange): List<Boolean> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun CharArray.slice(indices: IntRange): List<Char> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> Array<out T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun ByteArray.slice(indices: Iterable<Int>): List<Byte> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Byte>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun ShortArray.slice(indices: Iterable<Int>): List<Short> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Short>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun IntArray.slice(indices: Iterable<Int>): List<Int> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Int>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun LongArray.slice(indices: Iterable<Int>): List<Long> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Long>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun FloatArray.slice(indices: Iterable<Int>): List<Float> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Float>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun DoubleArray.slice(indices: Iterable<Int>): List<Double> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Double>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun BooleanArray.slice(indices: Iterable<Int>): List<Boolean> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Boolean>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun CharArray.slice(indices: Iterable<Int>): List<Char> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Char>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun <T> Array<T>.sliceArray(indices: Collection<Int>): Array<T> {\n    val result = arrayOfNulls(this, indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun ByteArray.sliceArray(indices: Collection<Int>): ByteArray {\n    val result = ByteArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun ShortArray.sliceArray(indices: Collection<Int>): ShortArray {\n    val result = ShortArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun IntArray.sliceArray(indices: Collection<Int>): IntArray {\n    val result = IntArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun LongArray.sliceArray(indices: Collection<Int>): LongArray {\n    val result = LongArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun FloatArray.sliceArray(indices: Collection<Int>): FloatArray {\n    val result = FloatArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun DoubleArray.sliceArray(indices: Collection<Int>): DoubleArray {\n    val result = DoubleArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun BooleanArray.sliceArray(indices: Collection<Int>): BooleanArray {\n    val result = BooleanArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun CharArray.sliceArray(indices: Collection<Int>): CharArray {\n    val result = CharArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun <T> Array<T>.sliceArray(indices: IntRange): Array<T> {\n    if (indices.isEmpty()) return copyOfRange(0, 0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun ByteArray.sliceArray(indices: IntRange): ByteArray {\n    if (indices.isEmpty()) return ByteArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun ShortArray.sliceArray(indices: IntRange): ShortArray {\n    if (indices.isEmpty()) return ShortArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun IntArray.sliceArray(indices: IntRange): IntArray {\n    if (indices.isEmpty()) return IntArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun LongArray.sliceArray(indices: IntRange): LongArray {\n    if (indices.isEmpty()) return LongArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun FloatArray.sliceArray(indices: IntRange): FloatArray {\n    if (indices.isEmpty()) return FloatArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun DoubleArray.sliceArray(indices: IntRange): DoubleArray {\n    if (indices.isEmpty()) return DoubleArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun BooleanArray.sliceArray(indices: IntRange): BooleanArray {\n    if (indices.isEmpty()) return BooleanArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun CharArray.sliceArray(indices: IntRange): CharArray {\n    if (indices.isEmpty()) return CharArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Array<out T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ByteArray.take(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Byte>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ShortArray.take(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Short>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun IntArray.take(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Int>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun LongArray.take(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Long>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun FloatArray.take(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Float>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun DoubleArray.take(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Double>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun BooleanArray.take(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Boolean>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun CharArray.take(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Char>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Array<out T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<T>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ByteArray.takeLast(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Byte>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ShortArray.takeLast(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Short>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun IntArray.takeLast(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Int>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun LongArray.takeLast(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Long>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun FloatArray.takeLast(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Float>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun DoubleArray.takeLast(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Double>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun BooleanArray.takeLast(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Boolean>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun CharArray.takeLast(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Char>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Array<out T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ByteArray.takeLastWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ShortArray.takeLastWhile(predicate: (Short) -> Boolean): List<Short> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun IntArray.takeLastWhile(predicate: (Int) -> Boolean): List<Int> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun LongArray.takeLastWhile(predicate: (Long) -> Boolean): List<Long> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun FloatArray.takeLastWhile(predicate: (Float) -> Boolean): List<Float> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun DoubleArray.takeLastWhile(predicate: (Double) -> Boolean): List<Double> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun BooleanArray.takeLastWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun CharArray.takeLastWhile(predicate: (Char) -> Boolean): List<Char> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Array<out T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ByteArray.takeWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    val list = ArrayList<Byte>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ShortArray.takeWhile(predicate: (Short) -> Boolean): List<Short> {\n    val list = ArrayList<Short>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun IntArray.takeWhile(predicate: (Int) -> Boolean): List<Int> {\n    val list = ArrayList<Int>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun LongArray.takeWhile(predicate: (Long) -> Boolean): List<Long> {\n    val list = ArrayList<Long>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun FloatArray.takeWhile(predicate: (Float) -> Boolean): List<Float> {\n    val list = ArrayList<Float>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun DoubleArray.takeWhile(predicate: (Double) -> Boolean): List<Double> {\n    val list = ArrayList<Double>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun BooleanArray.takeWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    val list = ArrayList<Boolean>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun CharArray.takeWhile(predicate: (Char) -> Boolean): List<Char> {\n    val list = ArrayList<Char>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun <T> Array<T>.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun ByteArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun ShortArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun IntArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun LongArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun FloatArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun DoubleArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun BooleanArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun CharArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Array<out T>.reversed(): List<T> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun ByteArray.reversed(): List<Byte> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun ShortArray.reversed(): List<Short> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun IntArray.reversed(): List<Int> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun LongArray.reversed(): List<Long> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun FloatArray.reversed(): List<Float> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun DoubleArray.reversed(): List<Double> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun BooleanArray.reversed(): List<Boolean> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun CharArray.reversed(): List<Char> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun <T> Array<T>.reversedArray(): Array<T> {\n    if (isEmpty()) return this\n    val result = arrayOfNulls(this, size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun ByteArray.reversedArray(): ByteArray {\n    if (isEmpty()) return this\n    val result = ByteArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun ShortArray.reversedArray(): ShortArray {\n    if (isEmpty()) return this\n    val result = ShortArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun IntArray.reversedArray(): IntArray {\n    if (isEmpty()) return this\n    val result = IntArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun LongArray.reversedArray(): LongArray {\n    if (isEmpty()) return this\n    val result = LongArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun FloatArray.reversedArray(): FloatArray {\n    if (isEmpty()) return this\n    val result = FloatArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun DoubleArray.reversedArray(): DoubleArray {\n    if (isEmpty()) return this\n    val result = DoubleArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun BooleanArray.reversedArray(): BooleanArray {\n    if (isEmpty()) return this\n    val result = BooleanArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun CharArray.reversedArray(): CharArray {\n    if (isEmpty()) return this\n    val result = CharArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Sorts elements in the array in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the array in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<out T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun ByteArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun ShortArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun IntArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun LongArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun FloatArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun DoubleArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun CharArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<out T>.sorted(): List<T> {\n    return sortedArray().asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun ByteArray.sorted(): List<Byte> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun ShortArray.sorted(): List<Short> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun IntArray.sorted(): List<Int> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun LongArray.sorted(): List<Long> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun FloatArray.sorted(): List<Float> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun DoubleArray.sorted(): List<Double> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun CharArray.sorted(): List<Char> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<T>.sortedArray(): Array<T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun ByteArray.sortedArray(): ByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun ShortArray.sortedArray(): ShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun IntArray.sortedArray(): IntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun LongArray.sortedArray(): LongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun FloatArray.sortedArray(): FloatArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun DoubleArray.sortedArray(): DoubleArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun CharArray.sortedArray(): CharArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<T>.sortedArrayDescending(): Array<T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortWith(reverseOrder()) }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun ByteArray.sortedArrayDescending(): ByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun ShortArray.sortedArrayDescending(): ShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun IntArray.sortedArrayDescending(): IntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun LongArray.sortedArrayDescending(): LongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun FloatArray.sortedArrayDescending(): FloatArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun DoubleArray.sortedArrayDescending(): DoubleArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun CharArray.sortedArrayDescending(): CharArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Array<out T>.sortedArrayWith(comparator: Comparator<in T>): Array<out T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortWith(comparator) }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> ByteArray.sortedBy(crossinline selector: (Byte) -> R?): List<Byte> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> ShortArray.sortedBy(crossinline selector: (Short) -> R?): List<Short> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> IntArray.sortedBy(crossinline selector: (Int) -> R?): List<Int> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> LongArray.sortedBy(crossinline selector: (Long) -> R?): List<Long> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> FloatArray.sortedBy(crossinline selector: (Float) -> R?): List<Float> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> DoubleArray.sortedBy(crossinline selector: (Double) -> R?): List<Double> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> BooleanArray.sortedBy(crossinline selector: (Boolean) -> R?): List<Boolean> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> CharArray.sortedBy(crossinline selector: (Char) -> R?): List<Char> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> ByteArray.sortedByDescending(crossinline selector: (Byte) -> R?): List<Byte> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> ShortArray.sortedByDescending(crossinline selector: (Short) -> R?): List<Short> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> IntArray.sortedByDescending(crossinline selector: (Int) -> R?): List<Int> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> LongArray.sortedByDescending(crossinline selector: (Long) -> R?): List<Long> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> FloatArray.sortedByDescending(crossinline selector: (Float) -> R?): List<Float> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> DoubleArray.sortedByDescending(crossinline selector: (Double) -> R?): List<Double> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> BooleanArray.sortedByDescending(crossinline selector: (Boolean) -> R?): List<Boolean> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> CharArray.sortedByDescending(crossinline selector: (Char) -> R?): List<Char> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<out T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun ByteArray.sortedDescending(): List<Byte> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun ShortArray.sortedDescending(): List<Short> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun IntArray.sortedDescending(): List<Int> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun LongArray.sortedDescending(): List<Long> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun FloatArray.sortedDescending(): List<Float> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun DoubleArray.sortedDescending(): List<Double> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun CharArray.sortedDescending(): List<Char> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Array<out T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    return sortedArrayWith(comparator).asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun ByteArray.sortedWith(comparator: Comparator<in Byte>): List<Byte> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun ShortArray.sortedWith(comparator: Comparator<in Short>): List<Short> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun IntArray.sortedWith(comparator: Comparator<in Int>): List<Int> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun LongArray.sortedWith(comparator: Comparator<in Long>): List<Long> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun FloatArray.sortedWith(comparator: Comparator<in Float>): List<Float> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun DoubleArray.sortedWith(comparator: Comparator<in Double>): List<Double> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun BooleanArray.sortedWith(comparator: Comparator<in Boolean>): List<Boolean> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun CharArray.sortedWith(comparator: Comparator<in Char>): List<Char> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun <T> Array<out T>.asList(): List<T>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun ByteArray.asList(): List<Byte>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun ShortArray.asList(): List<Short>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun IntArray.asList(): List<Int>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun LongArray.asList(): List<Long>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun FloatArray.asList(): List<Float>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun DoubleArray.asList(): List<Double>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun BooleanArray.asList(): List<Boolean>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun CharArray.asList(): List<Char>\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\npublic expect infix fun <T> Array<out T>.contentDeepEquals(other: Array<out T>): Boolean\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.1\")\npublic expect fun <T> Array<out T>.contentDeepHashCode(): Int\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.1\")\npublic expect fun <T> Array<out T>.contentDeepToString(): String\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\npublic expect infix fun <T> Array<out T>.contentEquals(other: Array<out T>): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\npublic expect infix fun ByteArray.contentEquals(other: ByteArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\npublic expect infix fun ShortArray.contentEquals(other: ShortArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\npublic expect infix fun IntArray.contentEquals(other: IntArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\npublic expect infix fun LongArray.contentEquals(other: LongArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\npublic expect infix fun FloatArray.contentEquals(other: FloatArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\npublic expect infix fun DoubleArray.contentEquals(other: DoubleArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\npublic expect infix fun BooleanArray.contentEquals(other: BooleanArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\npublic expect infix fun CharArray.contentEquals(other: CharArray): Boolean\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\npublic expect fun <T> Array<out T>.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\npublic expect fun ByteArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\npublic expect fun ShortArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\npublic expect fun IntArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\npublic expect fun LongArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\npublic expect fun FloatArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\npublic expect fun DoubleArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\npublic expect fun BooleanArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\npublic expect fun CharArray.contentHashCode(): Int\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\npublic expect fun <T> Array<out T>.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\npublic expect fun ByteArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\npublic expect fun ShortArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\npublic expect fun IntArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\npublic expect fun LongArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\npublic expect fun FloatArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\npublic expect fun DoubleArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\npublic expect fun BooleanArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\npublic expect fun CharArray.contentToString(): String\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun <T> Array<out T>.copyInto(destination: Array<T>, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): Array<T>\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ByteArray.copyInto(destination: ByteArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ByteArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ShortArray.copyInto(destination: ShortArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ShortArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun IntArray.copyInto(destination: IntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): IntArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun LongArray.copyInto(destination: LongArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): LongArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun FloatArray.copyInto(destination: FloatArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): FloatArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun DoubleArray.copyInto(destination: DoubleArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): DoubleArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun BooleanArray.copyInto(destination: BooleanArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): BooleanArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun CharArray.copyInto(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): CharArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOf(): Array<T>\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun ByteArray.copyOf(): ByteArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun ShortArray.copyOf(): ShortArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun IntArray.copyOf(): IntArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun LongArray.copyOf(): LongArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun FloatArray.copyOf(): FloatArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun DoubleArray.copyOf(): DoubleArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun BooleanArray.copyOf(): BooleanArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun CharArray.copyOf(): CharArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun ByteArray.copyOf(newSize: Int): ByteArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun ShortArray.copyOf(newSize: Int): ShortArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun IntArray.copyOf(newSize: Int): IntArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun LongArray.copyOf(newSize: Int): LongArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun FloatArray.copyOf(newSize: Int): FloatArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun DoubleArray.copyOf(newSize: Int): DoubleArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `false` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `false` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun BooleanArray.copyOf(newSize: Int): BooleanArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with null char (`\\u0000`) values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with null char (`\\u0000`) values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun CharArray.copyOf(newSize: Int): CharArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `null` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `null` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizingCopyOf\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOf(newSize: Int): Array<T?>\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOfRange(fromIndex: Int, toIndex: Int): Array<T>\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic expect fun ByteArray.copyOfRange(fromIndex: Int, toIndex: Int): ByteArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic expect fun ShortArray.copyOfRange(fromIndex: Int, toIndex: Int): ShortArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic expect fun IntArray.copyOfRange(fromIndex: Int, toIndex: Int): IntArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic expect fun LongArray.copyOfRange(fromIndex: Int, toIndex: Int): LongArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic expect fun FloatArray.copyOfRange(fromIndex: Int, toIndex: Int): FloatArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic expect fun DoubleArray.copyOfRange(fromIndex: Int, toIndex: Int): DoubleArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic expect fun BooleanArray.copyOfRange(fromIndex: Int, toIndex: Int): BooleanArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic expect fun CharArray.copyOfRange(fromIndex: Int, toIndex: Int): CharArray\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive), 0 by default.\n * @param toIndex the end of the range (exclusive), size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun <T> Array<T>.fill(element: T, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive), 0 by default.\n * @param toIndex the end of the range (exclusive), size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ByteArray.fill(element: Byte, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive), 0 by default.\n * @param toIndex the end of the range (exclusive), size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ShortArray.fill(element: Short, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive), 0 by default.\n * @param toIndex the end of the range (exclusive), size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun IntArray.fill(element: Int, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive), 0 by default.\n * @param toIndex the end of the range (exclusive), size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun LongArray.fill(element: Long, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive), 0 by default.\n * @param toIndex the end of the range (exclusive), size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun FloatArray.fill(element: Float, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive), 0 by default.\n * @param toIndex the end of the range (exclusive), size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun DoubleArray.fill(element: Double, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive), 0 by default.\n * @param toIndex the end of the range (exclusive), size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun BooleanArray.fill(element: Boolean, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive), 0 by default.\n * @param toIndex the end of the range (exclusive), size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun CharArray.fill(element: Char, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val <T> Array<out T>.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val ByteArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val ShortArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val IntArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val LongArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val FloatArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val DoubleArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val BooleanArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val CharArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns the last valid index for the array.\n */\npublic val <T> Array<out T>.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val ByteArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val ShortArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val IntArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val LongArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val FloatArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val DoubleArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val BooleanArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val CharArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(element: T): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun ByteArray.plus(element: Byte): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun ShortArray.plus(element: Short): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun IntArray.plus(element: Int): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun LongArray.plus(element: Long): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun FloatArray.plus(element: Float): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun DoubleArray.plus(element: Double): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun BooleanArray.plus(element: Boolean): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun CharArray.plus(element: Char): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(elements: Collection<T>): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun ByteArray.plus(elements: Collection<Byte>): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun ShortArray.plus(elements: Collection<Short>): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun IntArray.plus(elements: Collection<Int>): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun LongArray.plus(elements: Collection<Long>): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun FloatArray.plus(elements: Collection<Float>): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun DoubleArray.plus(elements: Collection<Double>): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun BooleanArray.plus(elements: Collection<Boolean>): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun CharArray.plus(elements: Collection<Char>): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(elements: Array<out T>): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun ByteArray.plus(elements: ByteArray): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun ShortArray.plus(elements: ShortArray): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun IntArray.plus(elements: IntArray): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun LongArray.plus(elements: LongArray): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun FloatArray.plus(elements: FloatArray): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun DoubleArray.plus(elements: DoubleArray): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun BooleanArray.plus(elements: BooleanArray): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun CharArray.plus(elements: CharArray): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.plusElement(element: T): Array<T>\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun IntArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun LongArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun ByteArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun ShortArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun DoubleArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun FloatArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun CharArray.sort(): Unit\n\n/**\n * Sorts the array in-place according to the natural order of its elements.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Arrays.Sorting.sortArrayOfComparable\n */\npublic expect fun <T : Comparable<T>> Array<out T>.sort(): Unit\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic expect fun <T> Array<out T>.sortWith(comparator: Comparator<in T>): Unit\n\n/**\n * Returns an array of Boolean containing all of the elements of this generic array.\n */\npublic fun Array<out Boolean>.toBooleanArray(): BooleanArray {\n    return BooleanArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this generic array.\n */\npublic fun Array<out Byte>.toByteArray(): ByteArray {\n    return ByteArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Char containing all of the elements of this generic array.\n */\npublic fun Array<out Char>.toCharArray(): CharArray {\n    return CharArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Double containing all of the elements of this generic array.\n */\npublic fun Array<out Double>.toDoubleArray(): DoubleArray {\n    return DoubleArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Float containing all of the elements of this generic array.\n */\npublic fun Array<out Float>.toFloatArray(): FloatArray {\n    return FloatArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Int containing all of the elements of this generic array.\n */\npublic fun Array<out Int>.toIntArray(): IntArray {\n    return IntArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Long containing all of the elements of this generic array.\n */\npublic fun Array<out Long>.toLongArray(): LongArray {\n    return LongArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Short containing all of the elements of this generic array.\n */\npublic fun Array<out Short>.toShortArray(): ShortArray {\n    return ShortArray(size) { index -> this[index] }\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun ByteArray.toTypedArray(): Array<Byte>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun ShortArray.toTypedArray(): Array<Short>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun IntArray.toTypedArray(): Array<Int>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun LongArray.toTypedArray(): Array<Long>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun FloatArray.toTypedArray(): Array<Float>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun DoubleArray.toTypedArray(): Array<Double>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun BooleanArray.toTypedArray(): Array<Boolean>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun CharArray.toTypedArray(): Array<Char>\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <T, K, V> Array<out T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> ByteArray.associate(transform: (Byte) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> ShortArray.associate(transform: (Short) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> IntArray.associate(transform: (Int) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> LongArray.associate(transform: (Long) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> FloatArray.associate(transform: (Float) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> DoubleArray.associate(transform: (Double) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> BooleanArray.associate(transform: (Boolean) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> CharArray.associate(transform: (Char) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <T, K> Array<out T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> ByteArray.associateBy(keySelector: (Byte) -> K): Map<K, Byte> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Byte>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> ShortArray.associateBy(keySelector: (Short) -> K): Map<K, Short> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Short>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> IntArray.associateBy(keySelector: (Int) -> K): Map<K, Int> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Int>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> LongArray.associateBy(keySelector: (Long) -> K): Map<K, Long> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Long>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> FloatArray.associateBy(keySelector: (Float) -> K): Map<K, Float> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Float>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> DoubleArray.associateBy(keySelector: (Double) -> K): Map<K, Double> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Double>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> BooleanArray.associateBy(keySelector: (Boolean) -> K): Map<K, Boolean> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Boolean>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> CharArray.associateBy(keySelector: (Char) -> K): Map<K, Char> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Char>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <T, K, V> Array<out T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> ByteArray.associateBy(keySelector: (Byte) -> K, valueTransform: (Byte) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> ShortArray.associateBy(keySelector: (Short) -> K, valueTransform: (Short) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> IntArray.associateBy(keySelector: (Int) -> K, valueTransform: (Int) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> LongArray.associateBy(keySelector: (Long) -> K, valueTransform: (Long) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> FloatArray.associateBy(keySelector: (Float) -> K, valueTransform: (Float) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> DoubleArray.associateBy(keySelector: (Double) -> K, valueTransform: (Double) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> BooleanArray.associateBy(keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> CharArray.associateBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Array<out T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Byte>> ByteArray.associateByTo(destination: M, keySelector: (Byte) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Short>> ShortArray.associateByTo(destination: M, keySelector: (Short) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Int>> IntArray.associateByTo(destination: M, keySelector: (Int) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Long>> LongArray.associateByTo(destination: M, keySelector: (Long) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Float>> FloatArray.associateByTo(destination: M, keySelector: (Float) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Double>> DoubleArray.associateByTo(destination: M, keySelector: (Double) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Boolean>> BooleanArray.associateByTo(destination: M, keySelector: (Boolean) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Char>> CharArray.associateByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Array<out T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ByteArray.associateByTo(destination: M, keySelector: (Byte) -> K, valueTransform: (Byte) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ShortArray.associateByTo(destination: M, keySelector: (Short) -> K, valueTransform: (Short) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> IntArray.associateByTo(destination: M, keySelector: (Int) -> K, valueTransform: (Int) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> LongArray.associateByTo(destination: M, keySelector: (Long) -> K, valueTransform: (Long) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> FloatArray.associateByTo(destination: M, keySelector: (Float) -> K, valueTransform: (Float) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> DoubleArray.associateByTo(destination: M, keySelector: (Double) -> K, valueTransform: (Double) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> BooleanArray.associateByTo(destination: M, keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharArray.associateByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Array<out T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ByteArray.associateTo(destination: M, transform: (Byte) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ShortArray.associateTo(destination: M, transform: (Short) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> IntArray.associateTo(destination: M, transform: (Int) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> LongArray.associateTo(destination: M, transform: (Long) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> FloatArray.associateTo(destination: M, transform: (Float) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> DoubleArray.associateTo(destination: M, transform: (Double) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> BooleanArray.associateTo(destination: M, transform: (Boolean) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharArray.associateTo(destination: M, transform: (Char) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Array<out T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Byte>> ByteArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Short>> ShortArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Int>> IntArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Long>> LongArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Float>> FloatArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Double>> DoubleArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Boolean>> BooleanArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Char>> CharArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun <T> Array<out T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(size)))\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun ByteArray.toHashSet(): HashSet<Byte> {\n    return toCollection(HashSet<Byte>(mapCapacity(size)))\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun ShortArray.toHashSet(): HashSet<Short> {\n    return toCollection(HashSet<Short>(mapCapacity(size)))\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun IntArray.toHashSet(): HashSet<Int> {\n    return toCollection(HashSet<Int>(mapCapacity(size)))\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun LongArray.toHashSet(): HashSet<Long> {\n    return toCollection(HashSet<Long>(mapCapacity(size)))\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun FloatArray.toHashSet(): HashSet<Float> {\n    return toCollection(HashSet<Float>(mapCapacity(size)))\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun DoubleArray.toHashSet(): HashSet<Double> {\n    return toCollection(HashSet<Double>(mapCapacity(size)))\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun BooleanArray.toHashSet(): HashSet<Boolean> {\n    return toCollection(HashSet<Boolean>(mapCapacity(size)))\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun CharArray.toHashSet(): HashSet<Char> {\n    return toCollection(HashSet<Char>(mapCapacity(size)))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Array<out T>.toList(): List<T> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun ByteArray.toList(): List<Byte> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun ShortArray.toList(): List<Short> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun IntArray.toList(): List<Int> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun LongArray.toList(): List<Long> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun FloatArray.toList(): List<Float> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun DoubleArray.toList(): List<Double> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun BooleanArray.toList(): List<Boolean> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun CharArray.toList(): List<Char> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this array.\n */\npublic fun <T> Array<out T>.toMutableList(): MutableList<T> {\n    return ArrayList(this.asCollection())\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this array.\n */\npublic fun ByteArray.toMutableList(): MutableList<Byte> {\n    val list = ArrayList<Byte>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this array.\n */\npublic fun ShortArray.toMutableList(): MutableList<Short> {\n    val list = ArrayList<Short>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this array.\n */\npublic fun IntArray.toMutableList(): MutableList<Int> {\n    val list = ArrayList<Int>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this array.\n */\npublic fun LongArray.toMutableList(): MutableList<Long> {\n    val list = ArrayList<Long>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this array.\n */\npublic fun FloatArray.toMutableList(): MutableList<Float> {\n    val list = ArrayList<Float>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this array.\n */\npublic fun DoubleArray.toMutableList(): MutableList<Double> {\n    val list = ArrayList<Double>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this array.\n */\npublic fun BooleanArray.toMutableList(): MutableList<Boolean> {\n    val list = ArrayList<Boolean>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this array.\n */\npublic fun CharArray.toMutableList(): MutableList<Char> {\n    val list = ArrayList<Char>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun <T> Array<out T>.toSet(): Set<T> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ByteArray.toSet(): Set<Byte> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Byte>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ShortArray.toSet(): Set<Short> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Short>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun IntArray.toSet(): Set<Int> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Int>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun LongArray.toSet(): Set<Long> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Long>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun FloatArray.toSet(): Set<Float> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Float>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun DoubleArray.toSet(): Set<Double> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Double>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun BooleanArray.toSet(): Set<Boolean> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Boolean>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun CharArray.toSet(): Set<Char> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Char>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <T, R> Array<out T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> ByteArray.flatMap(transform: (Byte) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> ShortArray.flatMap(transform: (Short) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> IntArray.flatMap(transform: (Int) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> LongArray.flatMap(transform: (Long) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> FloatArray.flatMap(transform: (Float) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> DoubleArray.flatMap(transform: (Double) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> BooleanArray.flatMap(transform: (Boolean) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> CharArray.flatMap(transform: (Char) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.flatMapTo(destination: C, transform: (Byte) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.flatMapTo(destination: C, transform: (Short) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.flatMapTo(destination: C, transform: (Int) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.flatMapTo(destination: C, transform: (Long) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.flatMapTo(destination: C, transform: (Float) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.flatMapTo(destination: C, transform: (Double) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.flatMapTo(destination: C, transform: (Boolean) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.flatMapTo(destination: C, transform: (Char) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Array<out T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> ByteArray.groupBy(keySelector: (Byte) -> K): Map<K, List<Byte>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Byte>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> ShortArray.groupBy(keySelector: (Short) -> K): Map<K, List<Short>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Short>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> IntArray.groupBy(keySelector: (Int) -> K): Map<K, List<Int>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Int>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> LongArray.groupBy(keySelector: (Long) -> K): Map<K, List<Long>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Long>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> FloatArray.groupBy(keySelector: (Float) -> K): Map<K, List<Float>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Float>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> DoubleArray.groupBy(keySelector: (Double) -> K): Map<K, List<Double>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Double>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> BooleanArray.groupBy(keySelector: (Boolean) -> K): Map<K, List<Boolean>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Boolean>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> CharArray.groupBy(keySelector: (Char) -> K): Map<K, List<Char>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Char>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Array<out T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> ByteArray.groupBy(keySelector: (Byte) -> K, valueTransform: (Byte) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> ShortArray.groupBy(keySelector: (Short) -> K, valueTransform: (Short) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> IntArray.groupBy(keySelector: (Int) -> K, valueTransform: (Int) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> LongArray.groupBy(keySelector: (Long) -> K, valueTransform: (Long) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> FloatArray.groupBy(keySelector: (Float) -> K, valueTransform: (Float) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> DoubleArray.groupBy(keySelector: (Double) -> K, valueTransform: (Double) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> BooleanArray.groupBy(keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> CharArray.groupBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Array<out T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Byte>>> ByteArray.groupByTo(destination: M, keySelector: (Byte) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Byte>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Short>>> ShortArray.groupByTo(destination: M, keySelector: (Short) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Short>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Int>>> IntArray.groupByTo(destination: M, keySelector: (Int) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Int>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Long>>> LongArray.groupByTo(destination: M, keySelector: (Long) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Long>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Float>>> FloatArray.groupByTo(destination: M, keySelector: (Float) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Float>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Double>>> DoubleArray.groupByTo(destination: M, keySelector: (Double) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Double>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Boolean>>> BooleanArray.groupByTo(destination: M, keySelector: (Boolean) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Boolean>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Char>>> CharArray.groupByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Char>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Array<out T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> ByteArray.groupByTo(destination: M, keySelector: (Byte) -> K, valueTransform: (Byte) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> ShortArray.groupByTo(destination: M, keySelector: (Short) -> K, valueTransform: (Short) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> IntArray.groupByTo(destination: M, keySelector: (Int) -> K, valueTransform: (Int) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> LongArray.groupByTo(destination: M, keySelector: (Long) -> K, valueTransform: (Long) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> FloatArray.groupByTo(destination: M, keySelector: (Float) -> K, valueTransform: (Float) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> DoubleArray.groupByTo(destination: M, keySelector: (Double) -> K, valueTransform: (Double) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> BooleanArray.groupByTo(destination: M, keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> CharArray.groupByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from an array to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Array<out T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <T, R> Array<out T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> ByteArray.map(transform: (Byte) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> ShortArray.map(transform: (Short) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> IntArray.map(transform: (Int) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> LongArray.map(transform: (Long) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> FloatArray.map(transform: (Float) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> DoubleArray.map(transform: (Double) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> BooleanArray.map(transform: (Boolean) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> CharArray.map(transform: (Char) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Array<out T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> ByteArray.mapIndexed(transform: (index: Int, Byte) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> ShortArray.mapIndexed(transform: (index: Int, Short) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> IntArray.mapIndexed(transform: (index: Int, Int) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> LongArray.mapIndexed(transform: (index: Int, Long) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> FloatArray.mapIndexed(transform: (index: Int, Float) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> DoubleArray.mapIndexed(transform: (index: Int, Double) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> BooleanArray.mapIndexed(transform: (index: Int, Boolean) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> CharArray.mapIndexed(transform: (index: Int, Char) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Array<out T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Array<out T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.mapIndexedTo(destination: C, transform: (index: Int, Byte) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.mapIndexedTo(destination: C, transform: (index: Int, Short) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.mapIndexedTo(destination: C, transform: (index: Int, Int) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.mapIndexedTo(destination: C, transform: (index: Int, Long) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.mapIndexedTo(destination: C, transform: (index: Int, Float) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.mapIndexedTo(destination: C, transform: (index: Int, Double) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.mapIndexedTo(destination: C, transform: (index: Int, Boolean) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.mapIndexedTo(destination: C, transform: (index: Int, Char) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original array.\n */\npublic inline fun <T, R : Any> Array<out T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original array\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Array<out T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.mapTo(destination: C, transform: (Byte) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.mapTo(destination: C, transform: (Short) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.mapTo(destination: C, transform: (Int) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.mapTo(destination: C, transform: (Long) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.mapTo(destination: C, transform: (Float) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.mapTo(destination: C, transform: (Double) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.mapTo(destination: C, transform: (Boolean) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.mapTo(destination: C, transform: (Char) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun <T> Array<out T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun ByteArray.withIndex(): Iterable<IndexedValue<Byte>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun ShortArray.withIndex(): Iterable<IndexedValue<Short>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun IntArray.withIndex(): Iterable<IndexedValue<Int>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun LongArray.withIndex(): Iterable<IndexedValue<Long>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun FloatArray.withIndex(): Iterable<IndexedValue<Float>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun DoubleArray.withIndex(): Iterable<IndexedValue<Double>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun BooleanArray.withIndex(): Iterable<IndexedValue<Boolean>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun CharArray.withIndex(): Iterable<IndexedValue<Char>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Array<out T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun ByteArray.distinct(): List<Byte> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun ShortArray.distinct(): List<Short> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun IntArray.distinct(): List<Int> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun LongArray.distinct(): List<Long> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun FloatArray.distinct(): List<Float> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun DoubleArray.distinct(): List<Double> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun BooleanArray.distinct(): List<Boolean> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun CharArray.distinct(): List<Char> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <T, K> Array<out T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> ByteArray.distinctBy(selector: (Byte) -> K): List<Byte> {\n    val set = HashSet<K>()\n    val list = ArrayList<Byte>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> ShortArray.distinctBy(selector: (Short) -> K): List<Short> {\n    val set = HashSet<K>()\n    val list = ArrayList<Short>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> IntArray.distinctBy(selector: (Int) -> K): List<Int> {\n    val set = HashSet<K>()\n    val list = ArrayList<Int>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> LongArray.distinctBy(selector: (Long) -> K): List<Long> {\n    val set = HashSet<K>()\n    val list = ArrayList<Long>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> FloatArray.distinctBy(selector: (Float) -> K): List<Float> {\n    val set = HashSet<K>()\n    val list = ArrayList<Float>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> DoubleArray.distinctBy(selector: (Double) -> K): List<Double> {\n    val set = HashSet<K>()\n    val list = ArrayList<Double>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> BooleanArray.distinctBy(selector: (Boolean) -> K): List<Boolean> {\n    val set = HashSet<K>()\n    val list = ArrayList<Boolean>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> CharArray.distinctBy(selector: (Char) -> K): List<Char> {\n    val set = HashSet<K>()\n    val list = ArrayList<Char>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun <T> Array<out T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun ByteArray.intersect(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun ShortArray.intersect(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun IntArray.intersect(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun LongArray.intersect(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun FloatArray.intersect(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun DoubleArray.intersect(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun BooleanArray.intersect(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun CharArray.intersect(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun <T> Array<out T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun ByteArray.subtract(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun ShortArray.subtract(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun IntArray.subtract(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun LongArray.subtract(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun FloatArray.subtract(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun DoubleArray.subtract(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun BooleanArray.subtract(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun CharArray.subtract(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun <T> Array<out T>.toMutableSet(): MutableSet<T> {\n    val set = LinkedHashSet<T>(mapCapacity(size))\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ByteArray.toMutableSet(): MutableSet<Byte> {\n    val set = LinkedHashSet<Byte>(mapCapacity(size))\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ShortArray.toMutableSet(): MutableSet<Short> {\n    val set = LinkedHashSet<Short>(mapCapacity(size))\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun IntArray.toMutableSet(): MutableSet<Int> {\n    val set = LinkedHashSet<Int>(mapCapacity(size))\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun LongArray.toMutableSet(): MutableSet<Long> {\n    val set = LinkedHashSet<Long>(mapCapacity(size))\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun FloatArray.toMutableSet(): MutableSet<Float> {\n    val set = LinkedHashSet<Float>(mapCapacity(size))\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun DoubleArray.toMutableSet(): MutableSet<Double> {\n    val set = LinkedHashSet<Double>(mapCapacity(size))\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun BooleanArray.toMutableSet(): MutableSet<Boolean> {\n    val set = LinkedHashSet<Boolean>(mapCapacity(size))\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun CharArray.toMutableSet(): MutableSet<Char> {\n    val set = LinkedHashSet<Char>(mapCapacity(size))\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun <T> Array<out T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun ByteArray.union(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun ShortArray.union(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun IntArray.union(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun LongArray.union(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun FloatArray.union(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun DoubleArray.union(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun BooleanArray.union(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun CharArray.union(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Array<out T>.all(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun ByteArray.all(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun ShortArray.all(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun IntArray.all(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun LongArray.all(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun FloatArray.all(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun DoubleArray.all(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun BooleanArray.all(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun CharArray.all(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Array<out T>.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun ByteArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun ShortArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun IntArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun LongArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun FloatArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun DoubleArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun BooleanArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun CharArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Array<out T>.any(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun ByteArray.any(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun ShortArray.any(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun IntArray.any(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun LongArray.any(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun FloatArray.any(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun DoubleArray.any(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun BooleanArray.any(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun CharArray.any(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Array<out T>.count(predicate: (T) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun ByteArray.count(predicate: (Byte) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun ShortArray.count(predicate: (Short) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun IntArray.count(predicate: (Int) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun LongArray.count(predicate: (Long) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun FloatArray.count(predicate: (Float) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun DoubleArray.count(predicate: (Double) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun BooleanArray.count(predicate: (Boolean) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun CharArray.count(predicate: (Char) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <T, R> Array<out T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <R> ByteArray.fold(initial: R, operation: (acc: R, Byte) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <R> ShortArray.fold(initial: R, operation: (acc: R, Short) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <R> IntArray.fold(initial: R, operation: (acc: R, Int) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <R> LongArray.fold(initial: R, operation: (acc: R, Long) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <R> FloatArray.fold(initial: R, operation: (acc: R, Float) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <R> DoubleArray.fold(initial: R, operation: (acc: R, Double) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <R> BooleanArray.fold(initial: R, operation: (acc: R, Boolean) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <R> CharArray.fold(initial: R, operation: (acc: R, Char) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Byte) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Short) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Int) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Long) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Float) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Double) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Boolean) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <R> ByteArray.foldRight(initial: R, operation: (Byte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <R> ShortArray.foldRight(initial: R, operation: (Short, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <R> IntArray.foldRight(initial: R, operation: (Int, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <R> LongArray.foldRight(initial: R, operation: (Long, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <R> FloatArray.foldRight(initial: R, operation: (Float, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <R> DoubleArray.foldRight(initial: R, operation: (Double, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <R> BooleanArray.foldRight(initial: R, operation: (Boolean, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <R> CharArray.foldRight(initial: R, operation: (Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.foldRightIndexed(initial: R, operation: (index: Int, Byte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.foldRightIndexed(initial: R, operation: (index: Int, Short, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.foldRightIndexed(initial: R, operation: (index: Int, Int, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.foldRightIndexed(initial: R, operation: (index: Int, Long, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.foldRightIndexed(initial: R, operation: (index: Int, Float, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.foldRightIndexed(initial: R, operation: (index: Int, Double, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.foldRightIndexed(initial: R, operation: (index: Int, Boolean, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.foldRightIndexed(initial: R, operation: (index: Int, Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun <T> Array<out T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun ByteArray.forEach(action: (Byte) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun ShortArray.forEach(action: (Short) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun IntArray.forEach(action: (Int) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun LongArray.forEach(action: (Long) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun FloatArray.forEach(action: (Float) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun DoubleArray.forEach(action: (Double) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun BooleanArray.forEach(action: (Boolean) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun CharArray.forEach(action: (Char) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun <T> Array<out T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun ByteArray.forEachIndexed(action: (index: Int, Byte) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun ShortArray.forEachIndexed(action: (index: Int, Short) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun IntArray.forEachIndexed(action: (index: Int, Int) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun LongArray.forEachIndexed(action: (index: Int, Long) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun FloatArray.forEachIndexed(action: (index: Int, Float) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun DoubleArray.forEachIndexed(action: (index: Int, Double) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun BooleanArray.forEachIndexed(action: (index: Int, Boolean) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun CharArray.forEachIndexed(action: (index: Int, Char) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Array<out Double>.max(): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    if (max.isNaN()) return max\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Array<out Float>.max(): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    if (max.isNaN()) return max\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Array<out T>.max(): T? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun ByteArray.max(): Byte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun ShortArray.max(): Short? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun IntArray.max(): Int? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun LongArray.max(): Long? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\npublic fun FloatArray.max(): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    if (max.isNaN()) return max\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\npublic fun DoubleArray.max(): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    if (max.isNaN()) return max\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun CharArray.max(): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxBy(selector: (T) -> R): T? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <R : Comparable<R>> ByteArray.maxBy(selector: (Byte) -> R): Byte? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <R : Comparable<R>> ShortArray.maxBy(selector: (Short) -> R): Short? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <R : Comparable<R>> IntArray.maxBy(selector: (Int) -> R): Int? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <R : Comparable<R>> LongArray.maxBy(selector: (Long) -> R): Long? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <R : Comparable<R>> FloatArray.maxBy(selector: (Float) -> R): Float? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <R : Comparable<R>> DoubleArray.maxBy(selector: (Double) -> R): Double? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <R : Comparable<R>> BooleanArray.maxBy(selector: (Boolean) -> R): Boolean? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <R : Comparable<R>> CharArray.maxBy(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Array<out T>.maxWith(comparator: Comparator<in T>): T? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun ByteArray.maxWith(comparator: Comparator<in Byte>): Byte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun ShortArray.maxWith(comparator: Comparator<in Short>): Short? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun IntArray.maxWith(comparator: Comparator<in Int>): Int? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun LongArray.maxWith(comparator: Comparator<in Long>): Long? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun FloatArray.maxWith(comparator: Comparator<in Float>): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun DoubleArray.maxWith(comparator: Comparator<in Double>): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun BooleanArray.maxWith(comparator: Comparator<in Boolean>): Boolean? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun CharArray.maxWith(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Array<out Double>.min(): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    if (min.isNaN()) return min\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Array<out Float>.min(): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    if (min.isNaN()) return min\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Array<out T>.min(): T? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun ByteArray.min(): Byte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun ShortArray.min(): Short? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun IntArray.min(): Int? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun LongArray.min(): Long? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\npublic fun FloatArray.min(): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    if (min.isNaN()) return min\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\npublic fun DoubleArray.min(): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    if (min.isNaN()) return min\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun CharArray.min(): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.minBy(selector: (T) -> R): T? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <R : Comparable<R>> ByteArray.minBy(selector: (Byte) -> R): Byte? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <R : Comparable<R>> ShortArray.minBy(selector: (Short) -> R): Short? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <R : Comparable<R>> IntArray.minBy(selector: (Int) -> R): Int? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <R : Comparable<R>> LongArray.minBy(selector: (Long) -> R): Long? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <R : Comparable<R>> FloatArray.minBy(selector: (Float) -> R): Float? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <R : Comparable<R>> DoubleArray.minBy(selector: (Double) -> R): Double? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <R : Comparable<R>> BooleanArray.minBy(selector: (Boolean) -> R): Boolean? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <R : Comparable<R>> CharArray.minBy(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Array<out T>.minWith(comparator: Comparator<in T>): T? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun ByteArray.minWith(comparator: Comparator<in Byte>): Byte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun ShortArray.minWith(comparator: Comparator<in Short>): Short? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun IntArray.minWith(comparator: Comparator<in Int>): Int? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun LongArray.minWith(comparator: Comparator<in Long>): Long? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun FloatArray.minWith(comparator: Comparator<in Float>): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun DoubleArray.minWith(comparator: Comparator<in Double>): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun BooleanArray.minWith(comparator: Comparator<in Boolean>): Boolean? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun CharArray.minWith(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Array<out T>.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun ByteArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun ShortArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun IntArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun LongArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun FloatArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun DoubleArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun BooleanArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun CharArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Array<out T>.none(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun ByteArray.none(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun ShortArray.none(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun IntArray.none(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun LongArray.none(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun FloatArray.none(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun DoubleArray.none(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun BooleanArray.none(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun CharArray.none(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Array<out T>.reduce(operation: (acc: S, T) -> S): S {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ByteArray.reduce(operation: (acc: Byte, Byte) -> Byte): Byte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ShortArray.reduce(operation: (acc: Short, Short) -> Short): Short {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun IntArray.reduce(operation: (acc: Int, Int) -> Int): Int {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun LongArray.reduce(operation: (acc: Long, Long) -> Long): Long {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun FloatArray.reduce(operation: (acc: Float, Float) -> Float): Float {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun DoubleArray.reduce(operation: (acc: Double, Double) -> Double): Double {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun BooleanArray.reduce(operation: (acc: Boolean, Boolean) -> Boolean): Boolean {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharArray.reduce(operation: (acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Array<out T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ByteArray.reduceIndexed(operation: (index: Int, acc: Byte, Byte) -> Byte): Byte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ShortArray.reduceIndexed(operation: (index: Int, acc: Short, Short) -> Short): Short {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun IntArray.reduceIndexed(operation: (index: Int, acc: Int, Int) -> Int): Int {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun LongArray.reduceIndexed(operation: (index: Int, acc: Long, Long) -> Long): Long {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun FloatArray.reduceIndexed(operation: (index: Int, acc: Float, Float) -> Float): Float {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun DoubleArray.reduceIndexed(operation: (index: Int, acc: Double, Double) -> Double): Double {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun BooleanArray.reduceIndexed(operation: (index: Int, acc: Boolean, Boolean) -> Boolean): Boolean {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharArray.reduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element. Returns null if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun <S, T : S> Array<out T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    if (isEmpty())\n        return null\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element. Returns null if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun ByteArray.reduceOrNull(operation: (acc: Byte, Byte) -> Byte): Byte? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element. Returns null if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun ShortArray.reduceOrNull(operation: (acc: Short, Short) -> Short): Short? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element. Returns null if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun IntArray.reduceOrNull(operation: (acc: Int, Int) -> Int): Int? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element. Returns null if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun LongArray.reduceOrNull(operation: (acc: Long, Long) -> Long): Long? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element. Returns null if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun FloatArray.reduceOrNull(operation: (acc: Float, Float) -> Float): Float? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element. Returns null if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun DoubleArray.reduceOrNull(operation: (acc: Double, Double) -> Double): Double? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element. Returns null if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun BooleanArray.reduceOrNull(operation: (acc: Boolean, Boolean) -> Boolean): Boolean? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element. Returns null if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun CharArray.reduceOrNull(operation: (acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> Array<out T>.reduceRight(operation: (T, acc: S) -> S): S {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ByteArray.reduceRight(operation: (Byte, acc: Byte) -> Byte): Byte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ShortArray.reduceRight(operation: (Short, acc: Short) -> Short): Short {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun IntArray.reduceRight(operation: (Int, acc: Int) -> Int): Int {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun LongArray.reduceRight(operation: (Long, acc: Long) -> Long): Long {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun FloatArray.reduceRight(operation: (Float, acc: Float) -> Float): Float {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun DoubleArray.reduceRight(operation: (Double, acc: Double) -> Double): Double {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun BooleanArray.reduceRight(operation: (Boolean, acc: Boolean) -> Boolean): Boolean {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharArray.reduceRight(operation: (Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> Array<out T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ByteArray.reduceRightIndexed(operation: (index: Int, Byte, acc: Byte) -> Byte): Byte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ShortArray.reduceRightIndexed(operation: (index: Int, Short, acc: Short) -> Short): Short {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun IntArray.reduceRightIndexed(operation: (index: Int, Int, acc: Int) -> Int): Int {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun LongArray.reduceRightIndexed(operation: (index: Int, Long, acc: Long) -> Long): Long {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun FloatArray.reduceRightIndexed(operation: (index: Int, Float, acc: Float) -> Float): Float {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun DoubleArray.reduceRightIndexed(operation: (index: Int, Double, acc: Double) -> Double): Double {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun BooleanArray.reduceRightIndexed(operation: (index: Int, Boolean, acc: Boolean) -> Boolean): Boolean {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharArray.reduceRightIndexed(operation: (index: Int, Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value. Returns null if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun <S, T : S> Array<out T>.reduceRightOrNull(operation: (T, acc: S) -> S): S? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value. Returns null if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun ByteArray.reduceRightOrNull(operation: (Byte, acc: Byte) -> Byte): Byte? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value. Returns null if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun ShortArray.reduceRightOrNull(operation: (Short, acc: Short) -> Short): Short? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value. Returns null if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun IntArray.reduceRightOrNull(operation: (Int, acc: Int) -> Int): Int? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value. Returns null if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun LongArray.reduceRightOrNull(operation: (Long, acc: Long) -> Long): Long? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value. Returns null if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun FloatArray.reduceRightOrNull(operation: (Float, acc: Float) -> Float): Float? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value. Returns null if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun DoubleArray.reduceRightOrNull(operation: (Double, acc: Double) -> Double): Double? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value. Returns null if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun BooleanArray.reduceRightOrNull(operation: (Boolean, acc: Boolean) -> Boolean): Boolean? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value. Returns null if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun CharArray.reduceRightOrNull(operation: (Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun <T, R> Array<out T>.scan(initial: R, operation: (acc: R, T) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.scan(initial: R, operation: (acc: R, Byte) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.scan(initial: R, operation: (acc: R, Short) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.scan(initial: R, operation: (acc: R, Int) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.scan(initial: R, operation: (acc: R, Long) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.scan(initial: R, operation: (acc: R, Float) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.scan(initial: R, operation: (acc: R, Double) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.scan(initial: R, operation: (acc: R, Boolean) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.scan(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun <T, R> Array<out T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Byte) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Short) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Int) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Long) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Float) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Double) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Boolean) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scanReduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun <S, T : S> Array<out T>.scanReduce(operation: (acc: S, T) -> S): List<S> {\n    if (isEmpty()) return emptyList()\n    var accumulator: S = this[0]\n    val result = ArrayList<S>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scanReduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.scanReduce(operation: (acc: Byte, Byte) -> Byte): List<Byte> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Byte>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scanReduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.scanReduce(operation: (acc: Short, Short) -> Short): List<Short> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Short>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scanReduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.scanReduce(operation: (acc: Int, Int) -> Int): List<Int> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Int>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scanReduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.scanReduce(operation: (acc: Long, Long) -> Long): List<Long> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Long>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scanReduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.scanReduce(operation: (acc: Float, Float) -> Float): List<Float> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Float>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scanReduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.scanReduce(operation: (acc: Double, Double) -> Double): List<Double> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Double>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scanReduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.scanReduce(operation: (acc: Boolean, Boolean) -> Boolean): List<Boolean> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Boolean>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scanReduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.scanReduce(operation: (acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scanReduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun <S, T : S> Array<out T>.scanReduceIndexed(operation: (index: Int, acc: S, T) -> S): List<S> {\n    if (isEmpty()) return emptyList()\n    var accumulator: S = this[0]\n    val result = ArrayList<S>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scanReduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.scanReduceIndexed(operation: (index: Int, acc: Byte, Byte) -> Byte): List<Byte> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Byte>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scanReduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.scanReduceIndexed(operation: (index: Int, acc: Short, Short) -> Short): List<Short> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Short>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scanReduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.scanReduceIndexed(operation: (index: Int, acc: Int, Int) -> Int): List<Int> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Int>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scanReduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.scanReduceIndexed(operation: (index: Int, acc: Long, Long) -> Long): List<Long> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Long>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scanReduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.scanReduceIndexed(operation: (index: Int, acc: Float, Float) -> Float): List<Float> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Float>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scanReduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.scanReduceIndexed(operation: (index: Int, acc: Double, Double) -> Double): List<Double> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Double>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scanReduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.scanReduceIndexed(operation: (index: Int, acc: Boolean, Boolean) -> Boolean): List<Boolean> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Boolean>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scanReduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.scanReduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun <T> Array<out T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun ByteArray.sumBy(selector: (Byte) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun ShortArray.sumBy(selector: (Short) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun IntArray.sumBy(selector: (Int) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun LongArray.sumBy(selector: (Long) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun FloatArray.sumBy(selector: (Float) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun DoubleArray.sumBy(selector: (Double) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun BooleanArray.sumBy(selector: (Boolean) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun CharArray.sumBy(selector: (Char) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun <T> Array<out T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun ByteArray.sumByDouble(selector: (Byte) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun ShortArray.sumByDouble(selector: (Short) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun IntArray.sumByDouble(selector: (Int) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun LongArray.sumByDouble(selector: (Long) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun FloatArray.sumByDouble(selector: (Float) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun DoubleArray.sumByDouble(selector: (Double) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun BooleanArray.sumByDouble(selector: (Boolean) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun CharArray.sumByDouble(selector: (Char) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Array<T?>.requireNoNulls(): Array<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Array<T>\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun <T> Array<out T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun ByteArray.partition(predicate: (Byte) -> Boolean): Pair<List<Byte>, List<Byte>> {\n    val first = ArrayList<Byte>()\n    val second = ArrayList<Byte>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun ShortArray.partition(predicate: (Short) -> Boolean): Pair<List<Short>, List<Short>> {\n    val first = ArrayList<Short>()\n    val second = ArrayList<Short>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun IntArray.partition(predicate: (Int) -> Boolean): Pair<List<Int>, List<Int>> {\n    val first = ArrayList<Int>()\n    val second = ArrayList<Int>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun LongArray.partition(predicate: (Long) -> Boolean): Pair<List<Long>, List<Long>> {\n    val first = ArrayList<Long>()\n    val second = ArrayList<Long>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun FloatArray.partition(predicate: (Float) -> Boolean): Pair<List<Float>, List<Float>> {\n    val first = ArrayList<Float>()\n    val second = ArrayList<Float>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun DoubleArray.partition(predicate: (Double) -> Boolean): Pair<List<Double>, List<Double>> {\n    val first = ArrayList<Double>()\n    val second = ArrayList<Double>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun BooleanArray.partition(predicate: (Boolean) -> Boolean): Pair<List<Boolean>, List<Boolean>> {\n    val first = ArrayList<Boolean>()\n    val second = ArrayList<Boolean>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun CharArray.partition(predicate: (Char) -> Boolean): Pair<List<Char>, List<Char>> {\n    val first = ArrayList<Char>()\n    val second = ArrayList<Char>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Array<out T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ByteArray.zip(other: Array<out R>): List<Pair<Byte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ShortArray.zip(other: Array<out R>): List<Pair<Short, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> IntArray.zip(other: Array<out R>): List<Pair<Int, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> LongArray.zip(other: Array<out R>): List<Pair<Long, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> FloatArray.zip(other: Array<out R>): List<Pair<Float, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> DoubleArray.zip(other: Array<out R>): List<Pair<Double, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> BooleanArray.zip(other: Array<out R>): List<Pair<Boolean, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> CharArray.zip(other: Array<out R>): List<Pair<Char, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Array<out T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ByteArray.zip(other: Array<out R>, transform: (a: Byte, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ShortArray.zip(other: Array<out R>, transform: (a: Short, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> IntArray.zip(other: Array<out R>, transform: (a: Int, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> LongArray.zip(other: Array<out R>, transform: (a: Long, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> FloatArray.zip(other: Array<out R>, transform: (a: Float, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> DoubleArray.zip(other: Array<out R>, transform: (a: Double, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> BooleanArray.zip(other: Array<out R>, transform: (a: Boolean, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> CharArray.zip(other: Array<out R>, transform: (a: Char, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Array<out T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ByteArray.zip(other: Iterable<R>): List<Pair<Byte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ShortArray.zip(other: Iterable<R>): List<Pair<Short, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> IntArray.zip(other: Iterable<R>): List<Pair<Int, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> LongArray.zip(other: Iterable<R>): List<Pair<Long, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> FloatArray.zip(other: Iterable<R>): List<Pair<Float, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> DoubleArray.zip(other: Iterable<R>): List<Pair<Double, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> BooleanArray.zip(other: Iterable<R>): List<Pair<Boolean, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> CharArray.zip(other: Iterable<R>): List<Pair<Char, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Array<out T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ByteArray.zip(other: Iterable<R>, transform: (a: Byte, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ShortArray.zip(other: Iterable<R>, transform: (a: Short, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> IntArray.zip(other: Iterable<R>, transform: (a: Int, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> LongArray.zip(other: Iterable<R>, transform: (a: Long, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> FloatArray.zip(other: Iterable<R>, transform: (a: Float, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> DoubleArray.zip(other: Iterable<R>, transform: (a: Double, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> BooleanArray.zip(other: Iterable<R>, transform: (a: Boolean, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> CharArray.zip(other: Iterable<R>, transform: (a: Char, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun ByteArray.zip(other: ByteArray): List<Pair<Byte, Byte>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun ShortArray.zip(other: ShortArray): List<Pair<Short, Short>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun IntArray.zip(other: IntArray): List<Pair<Int, Int>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun LongArray.zip(other: LongArray): List<Pair<Long, Long>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun FloatArray.zip(other: FloatArray): List<Pair<Float, Float>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun DoubleArray.zip(other: DoubleArray): List<Pair<Double, Double>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun BooleanArray.zip(other: BooleanArray): List<Pair<Boolean, Boolean>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun CharArray.zip(other: CharArray): List<Pair<Char, Char>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> ByteArray.zip(other: ByteArray, transform: (a: Byte, b: Byte) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> ShortArray.zip(other: ShortArray, transform: (a: Short, b: Short) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> IntArray.zip(other: IntArray, transform: (a: Int, b: Int) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> LongArray.zip(other: LongArray, transform: (a: Long, b: Long) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> FloatArray.zip(other: FloatArray, transform: (a: Float, b: Float) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> DoubleArray.zip(other: DoubleArray, transform: (a: Double, b: Double) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> BooleanArray.zip(other: BooleanArray, transform: (a: Boolean, b: Boolean) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> CharArray.zip(other: CharArray, transform: (a: Char, b: Char) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Array<out T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> ByteArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Byte) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> ShortArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Short) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> IntArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Int) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> LongArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Long) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> FloatArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Float) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> DoubleArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Double) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> BooleanArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Boolean) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> CharArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Char) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Array<out T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun ByteArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Byte) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun ShortArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Short) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun IntArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Int) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun LongArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Long) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun FloatArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Float) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun DoubleArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Double) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun BooleanArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Boolean) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun CharArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Char) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun <T> Array<out T>.asIterable(): Iterable<T> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun ByteArray.asIterable(): Iterable<Byte> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun ShortArray.asIterable(): Iterable<Short> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun IntArray.asIterable(): Iterable<Int> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun LongArray.asIterable(): Iterable<Long> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun FloatArray.asIterable(): Iterable<Float> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun DoubleArray.asIterable(): Iterable<Double> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun BooleanArray.asIterable(): Iterable<Boolean> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun CharArray.asIterable(): Iterable<Char> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun <T> Array<out T>.asSequence(): Sequence<T> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun ByteArray.asSequence(): Sequence<Byte> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun ShortArray.asSequence(): Sequence<Short> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun IntArray.asSequence(): Sequence<Int> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun LongArray.asSequence(): Sequence<Long> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun FloatArray.asSequence(): Sequence<Float> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun DoubleArray.asSequence(): Sequence<Double> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun BooleanArray.asSequence(): Sequence<Boolean> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun CharArray.asSequence(): Sequence<Char> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Array<out Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Array<out Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Array<out Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Array<out Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Array<out Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Array<out Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun ByteArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun ShortArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun IntArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun LongArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun FloatArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun DoubleArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Array<out Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Array<out Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Array<out Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Array<out Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Array<out Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Array<out Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun ByteArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun ShortArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun IntArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun LongArray.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun FloatArray.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun DoubleArray.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"RangesKt\")\n\npackage kotlin.ranges\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns a random element from this range.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun IntRange.random(): Int {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this range.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun LongRange.random(): Long {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this range.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun CharRange.random(): Char {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun IntRange.random(random: Random): Int {\n    try {\n        return random.nextInt(this)\n    } catch(e: IllegalArgumentException) {\n        throw NoSuchElementException(e.message)\n    }\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun LongRange.random(random: Random): Long {\n    try {\n        return random.nextLong(this)\n    } catch(e: IllegalArgumentException) {\n        throw NoSuchElementException(e.message)\n    }\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun CharRange.random(random: Random): Char {\n    try {\n        return random.nextInt(first.toInt(), last.toInt() + 1).toChar()\n    } catch(e: IllegalArgumentException) {\n        throw NoSuchElementException(e.message)\n    }\n}\n\n/**\n * Returns a random element from this range, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun IntRange.randomOrNull(): Int? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this range, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun LongRange.randomOrNull(): Long? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this range, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun CharRange.randomOrNull(): Char? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun IntRange.randomOrNull(random: Random): Int? {\n    if (isEmpty())\n        return null\n    return random.nextInt(this)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun LongRange.randomOrNull(random: Random): Long? {\n    if (isEmpty())\n        return null\n    return random.nextLong(this)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun CharRange.randomOrNull(random: Random): Char? {\n    if (isEmpty())\n        return null\n    return random.nextInt(first.toInt(), last.toInt() + 1).toChar()\n}\n\n/**\n * Returns `true` if this range contains the specified [element].\n * \n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun IntRange.contains(element: Int?): Boolean {\n    return element != null && contains(element)\n}\n\n/**\n * Returns `true` if this range contains the specified [element].\n * \n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun LongRange.contains(element: Long?): Boolean {\n    return element != null && contains(element)\n}\n\n/**\n * Returns `true` if this range contains the specified [element].\n * \n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun CharRange.contains(element: Char?): Boolean {\n    return element != null && contains(element)\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Byte): Boolean {\n    return contains(value.toInt())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Byte): Boolean {\n    return contains(value.toLong())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Byte): Boolean {\n    return contains(value.toShort())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Byte): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Byte): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Double): Boolean {\n    return value.toIntExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Double): Boolean {\n    return value.toLongExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Double): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Double): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Double): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Float): Boolean {\n    return value.toIntExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Float): Boolean {\n    return value.toLongExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Float): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Float): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Float): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Int): Boolean {\n    return contains(value.toLong())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Int): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Int): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Int): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Int): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Long): Boolean {\n    return value.toIntExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Long): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Long): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Long): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Long): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Short): Boolean {\n    return contains(value.toInt())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Short): Boolean {\n    return contains(value.toLong())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Short): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Short): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Short): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Byte): IntProgression {\n    return IntProgression.fromClosedRange(this, to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Byte): LongProgression {\n    return LongProgression.fromClosedRange(this, to.toLong(), -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Byte): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Byte): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Char.downTo(to: Char): CharProgression {\n    return CharProgression.fromClosedRange(this, to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Int): IntProgression {\n    return IntProgression.fromClosedRange(this, to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Int): LongProgression {\n    return LongProgression.fromClosedRange(this, to.toLong(), -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Int): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Int): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this.toLong(), to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this, to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this.toLong(), to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this.toLong(), to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Short): IntProgression {\n    return IntProgression.fromClosedRange(this, to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Short): LongProgression {\n    return LongProgression.fromClosedRange(this, to.toLong(), -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Short): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Short): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression that goes over the same range in the opposite direction with the same step.\n */\npublic fun IntProgression.reversed(): IntProgression {\n    return IntProgression.fromClosedRange(last, first, -step)\n}\n\n/**\n * Returns a progression that goes over the same range in the opposite direction with the same step.\n */\npublic fun LongProgression.reversed(): LongProgression {\n    return LongProgression.fromClosedRange(last, first, -step)\n}\n\n/**\n * Returns a progression that goes over the same range in the opposite direction with the same step.\n */\npublic fun CharProgression.reversed(): CharProgression {\n    return CharProgression.fromClosedRange(last, first, -step)\n}\n\n/**\n * Returns a progression that goes over the same range with the given step.\n */\npublic infix fun IntProgression.step(step: Int): IntProgression {\n    checkStepIsPositive(step > 0, step)\n    return IntProgression.fromClosedRange(first, last, if (this.step > 0) step else -step)\n}\n\n/**\n * Returns a progression that goes over the same range with the given step.\n */\npublic infix fun LongProgression.step(step: Long): LongProgression {\n    checkStepIsPositive(step > 0, step)\n    return LongProgression.fromClosedRange(first, last, if (this.step > 0) step else -step)\n}\n\n/**\n * Returns a progression that goes over the same range with the given step.\n */\npublic infix fun CharProgression.step(step: Int): CharProgression {\n    checkStepIsPositive(step > 0, step)\n    return CharProgression.fromClosedRange(first, last, if (this.step > 0) step else -step)\n}\n\ninternal fun Int.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toInt()..Byte.MAX_VALUE.toInt()) this.toByte() else null\n}\n\ninternal fun Long.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toLong()..Byte.MAX_VALUE.toLong()) this.toByte() else null\n}\n\ninternal fun Short.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toShort()..Byte.MAX_VALUE.toShort()) this.toByte() else null\n}\n\ninternal fun Double.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toDouble()..Byte.MAX_VALUE.toDouble()) this.toByte() else null\n}\n\ninternal fun Float.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toFloat()..Byte.MAX_VALUE.toFloat()) this.toByte() else null\n}\n\ninternal fun Long.toIntExactOrNull(): Int? {\n    return if (this in Int.MIN_VALUE.toLong()..Int.MAX_VALUE.toLong()) this.toInt() else null\n}\n\ninternal fun Double.toIntExactOrNull(): Int? {\n    return if (this in Int.MIN_VALUE.toDouble()..Int.MAX_VALUE.toDouble()) this.toInt() else null\n}\n\ninternal fun Float.toIntExactOrNull(): Int? {\n    return if (this in Int.MIN_VALUE.toFloat()..Int.MAX_VALUE.toFloat()) this.toInt() else null\n}\n\ninternal fun Double.toLongExactOrNull(): Long? {\n    return if (this in Long.MIN_VALUE.toDouble()..Long.MAX_VALUE.toDouble()) this.toLong() else null\n}\n\ninternal fun Float.toLongExactOrNull(): Long? {\n    return if (this in Long.MIN_VALUE.toFloat()..Long.MAX_VALUE.toFloat()) this.toLong() else null\n}\n\ninternal fun Int.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toInt()..Short.MAX_VALUE.toInt()) this.toShort() else null\n}\n\ninternal fun Long.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toLong()..Short.MAX_VALUE.toLong()) this.toShort() else null\n}\n\ninternal fun Double.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toDouble()..Short.MAX_VALUE.toDouble()) this.toShort() else null\n}\n\ninternal fun Float.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toFloat()..Short.MAX_VALUE.toFloat()) this.toShort() else null\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Byte): IntRange {\n    return this .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Byte): LongRange {\n    return this .. (to.toLong() - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Byte): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Byte): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Char.until(to: Char): CharRange {\n    if (to <= '\\u0000') return CharRange.EMPTY\n    return this .. (to - 1).toChar()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Int): IntRange {\n    if (to <= Int.MIN_VALUE) return IntRange.EMPTY\n    return this .. (to - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Int): LongRange {\n    return this .. (to.toLong() - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Int): IntRange {\n    if (to <= Int.MIN_VALUE) return IntRange.EMPTY\n    return this.toInt() .. (to - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Int): IntRange {\n    if (to <= Int.MIN_VALUE) return IntRange.EMPTY\n    return this.toInt() .. (to - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this.toLong() .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this.toLong() .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this.toLong() .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Short): IntRange {\n    return this .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Short): LongRange {\n    return this .. (to.toLong() - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Short): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Short): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeastComparable\n */\npublic fun <T : Comparable<T>> T.coerceAtLeast(minimumValue: T): T {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Byte.coerceAtLeast(minimumValue: Byte): Byte {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Short.coerceAtLeast(minimumValue: Short): Short {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Int.coerceAtLeast(minimumValue: Int): Int {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Long.coerceAtLeast(minimumValue: Long): Long {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Float.coerceAtLeast(minimumValue: Float): Float {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Double.coerceAtLeast(minimumValue: Double): Double {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMostComparable\n */\npublic fun <T : Comparable<T>> T.coerceAtMost(maximumValue: T): T {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Byte.coerceAtMost(maximumValue: Byte): Byte {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Short.coerceAtMost(maximumValue: Short): Short {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Int.coerceAtMost(maximumValue: Int): Int {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Long.coerceAtMost(maximumValue: Long): Long {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Float.coerceAtMost(maximumValue: Float): Float {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Double.coerceAtMost(maximumValue: Double): Double {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceInComparable\n */\npublic fun <T : Comparable<T>> T.coerceIn(minimumValue: T?, maximumValue: T?): T {\n    if (minimumValue !== null && maximumValue !== null) {\n        if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n        if (this < minimumValue) return minimumValue\n        if (this > maximumValue) return maximumValue\n    }\n    else {\n        if (minimumValue !== null && this < minimumValue) return minimumValue\n        if (maximumValue !== null && this > maximumValue) return maximumValue\n    }\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Byte.coerceIn(minimumValue: Byte, maximumValue: Byte): Byte {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Short.coerceIn(minimumValue: Short, maximumValue: Short): Short {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Int.coerceIn(minimumValue: Int, maximumValue: Int): Int {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Long.coerceIn(minimumValue: Long, maximumValue: Long): Long {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Float.coerceIn(minimumValue: Float, maximumValue: Float): Float {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Double.coerceIn(minimumValue: Double, maximumValue: Double): Double {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceInFloatingPointRange\n */\n@SinceKotlin(\"1.1\")\npublic fun <T : Comparable<T>> T.coerceIn(range: ClosedFloatingPointRange<T>): T {\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        // this < start equiv to this <= start && !(this >= start)\n        range.lessThanOrEquals(this, range.start) && !range.lessThanOrEquals(range.start, this) -> range.start\n        // this > end equiv to this >= end && !(this <= end)\n        range.lessThanOrEquals(range.endInclusive, this) && !range.lessThanOrEquals(this, range.endInclusive) -> range.endInclusive\n        else -> this\n    }\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceInComparable\n */\npublic fun <T : Comparable<T>> T.coerceIn(range: ClosedRange<T>): T {\n    if (range is ClosedFloatingPointRange) {\n        return this.coerceIn<T>(range)\n    }\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        this < range.start -> range.start\n        this > range.endInclusive -> range.endInclusive\n        else -> this\n    }\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Int.coerceIn(range: ClosedRange<Int>): Int {\n    if (range is ClosedFloatingPointRange) {\n        return this.coerceIn<Int>(range)\n    }\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        this < range.start -> range.start\n        this > range.endInclusive -> range.endInclusive\n        else -> this\n    }\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Long.coerceIn(range: ClosedRange<Long>): Long {\n    if (range is ClosedFloatingPointRange) {\n        return this.coerceIn<Long>(range)\n    }\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        this < range.start -> range.start\n        this > range.endInclusive -> range.endInclusive\n        else -> this\n    }\n}\n\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\n\n@Suppress(\"NON_PUBLIC_PRIMARY_CONSTRUCTOR_OF_INLINE_CLASS\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline class UByte @PublishedApi internal constructor(@PublishedApi internal val data: Byte) : Comparable<UByte> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UByte can have.\n         */\n        public const val MIN_VALUE: UByte = UByte(0)\n\n        /**\n         * A constant holding the maximum value an instance of UByte can have.\n         */\n        public const val MAX_VALUE: UByte = UByte(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UByte in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 1\n\n        /**\n         * The number of bits used to represent an instance of UByte in a binary form.\n         */\n        public const val SIZE_BITS: Int = 8\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UByte): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UShort): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UInt): Int = this.toUInt().compareTo(other)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = this.toUInt().plus(other)\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = this.toUInt().minus(other)\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = this.toUInt().times(other)\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = this.toUInt().div(other)\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.toUInt().rem(other.toUInt())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.toUInt().rem(other.toUInt())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = this.toUInt().rem(other)\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /** Increments this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UByte = UByte(data.inc())\n    /** Decrements this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UByte = UByte(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UByte): UIntRange = UIntRange(this.toUInt(), other.toUInt())\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UByte): UByte = UByte(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UByte): UByte = UByte(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UByte): UByte = UByte(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UByte = UByte(data.inv())\n\n    /**\n     * Converts this [UByte] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UByte`. Otherwise the result is negative.\n     *\n     * The resulting `Byte` value has the same binary representation as this `UByte` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data\n    /**\n     * Converts this [UByte] value to [Short].\n     *\n     * The resulting `Short` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Short` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 8 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data.toShort() and 0xFF\n    /**\n     * Converts this [UByte] value to [Int].\n     *\n     * The resulting `Int` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Int` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 24 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data.toInt() and 0xFF\n    /**\n     * Converts this [UByte] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Long` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 56 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFF\n\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = this\n    /**\n     * Converts this [UByte] value to [UShort].\n     *\n     * The resulting `UShort` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `UShort` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 8 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = UShort(data.toShort() and 0xFF)\n    /**\n     * Converts this [UByte] value to [UInt].\n     *\n     * The resulting `UInt` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `UInt` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 24 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = UInt(data.toInt() and 0xFF)\n    /**\n     * Converts this [UByte] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `ULong` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 56 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFF)\n\n    /**\n     * Converts this [UByte] value to [Float].\n     *\n     * The resulting `Float` value represents the same numerical value as this `UByte`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toInt().toFloat()\n    /**\n     * Converts this [UByte] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UByte`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = this.toInt().toDouble()\n\n    public override fun toString(): String = toInt().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UByte].\n *\n * If this value is positive, the resulting `UByte` value represents the same numerical value as this `Byte`.\n *\n * The resulting `UByte` value has the same binary representation as this `Byte` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUByte(): UByte = UByte(this)\n/**\n * Converts this [Short] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Short`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Short` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUByte(): UByte = UByte(this.toByte())\n/**\n * Converts this [Int] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Int`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Int` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUByte(): UByte = UByte(this.toByte())\n/**\n * Converts this [Long] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Long` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUByte(): UByte = UByte(this.toByte())\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\n\n@Suppress(\"NON_PUBLIC_PRIMARY_CONSTRUCTOR_OF_INLINE_CLASS\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline class UInt @PublishedApi internal constructor(@PublishedApi internal val data: Int) : Comparable<UInt> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UInt can have.\n         */\n        public const val MIN_VALUE: UInt = UInt(0)\n\n        /**\n         * A constant holding the maximum value an instance of UInt can have.\n         */\n        public const val MAX_VALUE: UInt = UInt(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UInt in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 4\n\n        /**\n         * The number of bits used to represent an instance of UInt in a binary form.\n         */\n        public const val SIZE_BITS: Int = 32\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UByte): Int = this.compareTo(other.toUInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UShort): Int = this.compareTo(other.toUInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UInt): Int = uintCompare(this.data, other.data)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = UInt(this.data.plus(other.data))\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = UInt(this.data.minus(other.data))\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = UInt(this.data.times(other.data))\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.div(other.toUInt())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.div(other.toUInt())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = uintDivide(this, other)\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.rem(other.toUInt())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.rem(other.toUInt())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = uintRemainder(this, other)\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /** Increments this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UInt = UInt(data.inc())\n    /** Decrements this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UInt = UInt(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UInt): UIntRange = UIntRange(this, other)\n\n    /** Shifts this value left by the [bitCount] number of bits. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shl(bitCount: Int): UInt = UInt(data shl bitCount)\n    /** Shifts this value right by the [bitCount] number of bits, filling the leftmost bits with zeros. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shr(bitCount: Int): UInt = UInt(data ushr bitCount)\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UInt): UInt = UInt(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UInt): UInt = UInt(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UInt): UInt = UInt(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UInt = UInt(data.inv())\n\n    /**\n     * Converts this [UInt] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `Byte` value is represented by the least significant 8 bits of this `UInt` value.\n     * Note that the resulting `Byte` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data.toByte()\n    /**\n     * Converts this [UInt] value to [Short].\n     *\n     * If this value is less than or equals to [Short.MAX_VALUE], the resulting `Short` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `Short` value is represented by the least significant 16 bits of this `UInt` value.\n     * Note that the resulting `Short` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data.toShort()\n    /**\n     * Converts this [UInt] value to [Int].\n     *\n     * If this value is less than or equals to [Int.MAX_VALUE], the resulting `Int` value represents\n     * the same numerical value as this `UInt`. Otherwise the result is negative.\n     *\n     * The resulting `Int` value has the same binary representation as this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data\n    /**\n     * Converts this [UInt] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UInt`.\n     *\n     * The least significant 32 bits of the resulting `Long` value are the same as the bits of this `UInt` value,\n     * whereas the most significant 32 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFFFF_FFFF\n\n    /**\n     * Converts this [UInt] value to [UByte].\n     *\n     * If this value is less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `UByte` value is represented by the least significant 8 bits of this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = data.toUByte()\n    /**\n     * Converts this [UInt] value to [UShort].\n     *\n     * If this value is less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `UShort` value is represented by the least significant 16 bits of this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = data.toUShort()\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = this\n    /**\n     * Converts this [UInt] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UInt`.\n     *\n     * The least significant 32 bits of the resulting `ULong` value are the same as the bits of this `UInt` value,\n     * whereas the most significant 32 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFFFF_FFFF)\n\n    /**\n     * Converts this [UInt] value to [Float].\n     *\n     * The resulting value is the closest `Float` to this `UInt` value.\n     * In case when this `UInt` value is exactly between two `Float`s,\n     * the one with zero at least significant bit of mantissa is selected.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toDouble().toFloat()\n    /**\n     * Converts this [UInt] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UInt`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = uintToDouble(data)\n\n    public override fun toString(): String = toLong().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Byte`.\n *\n * The least significant 8 bits of the resulting `UInt` value are the same as the bits of this `Byte` value,\n * whereas the most significant 24 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUInt(): UInt = UInt(this.toInt())\n/**\n * Converts this [Short] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Short`.\n *\n * The least significant 16 bits of the resulting `UInt` value are the same as the bits of this `Short` value,\n * whereas the most significant 16 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUInt(): UInt = UInt(this.toInt())\n/**\n * Converts this [Int] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Int`.\n *\n * The resulting `UInt` value has the same binary representation as this `Int` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUInt(): UInt = UInt(this)\n/**\n * Converts this [Long] value to [UInt].\n *\n * If this value is positive and less than or equals to [UInt.MAX_VALUE], the resulting `UInt` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UInt` value is represented by the least significant 32 bits of this `Long` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUInt(): UInt = UInt(this.toInt())\n\n/**\n * Converts this [Float] value to [UInt].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Float` value is negative or `NaN`, [UInt.MAX_VALUE] if it's bigger than `UInt.MAX_VALUE`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Float.toUInt(): UInt = doubleToUInt(this.toDouble())\n/**\n * Converts this [Double] value to [UInt].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Double` value is negative or `NaN`, [UInt.MAX_VALUE] if it's bigger than `UInt.MAX_VALUE`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Double.toUInt(): UInt = doubleToUInt(this)\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\n\n@Suppress(\"NON_PUBLIC_PRIMARY_CONSTRUCTOR_OF_INLINE_CLASS\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline class UShort @PublishedApi internal constructor(@PublishedApi internal val data: Short) : Comparable<UShort> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UShort can have.\n         */\n        public const val MIN_VALUE: UShort = UShort(0)\n\n        /**\n         * A constant holding the maximum value an instance of UShort can have.\n         */\n        public const val MAX_VALUE: UShort = UShort(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UShort in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 2\n\n        /**\n         * The number of bits used to represent an instance of UShort in a binary form.\n         */\n        public const val SIZE_BITS: Int = 16\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UByte): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UShort): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UInt): Int = this.toUInt().compareTo(other)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = this.toUInt().plus(other)\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = this.toUInt().minus(other)\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = this.toUInt().times(other)\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = this.toUInt().div(other)\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.toUInt().rem(other.toUInt())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.toUInt().rem(other.toUInt())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = this.toUInt().rem(other)\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /** Increments this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UShort = UShort(data.inc())\n    /** Decrements this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UShort = UShort(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UShort): UIntRange = UIntRange(this.toUInt(), other.toUInt())\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UShort): UShort = UShort(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UShort): UShort = UShort(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UShort): UShort = UShort(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UShort = UShort(data.inv())\n\n    /**\n     * Converts this [UShort] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UShort`.\n     *\n     * The resulting `Byte` value is represented by the least significant 8 bits of this `UShort` value.\n     * Note that the resulting `Byte` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data.toByte()\n    /**\n     * Converts this [UShort] value to [Short].\n     *\n     * If this value is less than or equals to [Short.MAX_VALUE], the resulting `Short` value represents\n     * the same numerical value as this `UShort`. Otherwise the result is negative.\n     *\n     * The resulting `Short` value has the same binary representation as this `UShort` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data\n    /**\n     * Converts this [UShort] value to [Int].\n     *\n     * The resulting `Int` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `Int` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 16 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data.toInt() and 0xFFFF\n    /**\n     * Converts this [UShort] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `Long` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 48 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFFFF\n\n    /**\n     * Converts this [UShort] value to [UByte].\n     *\n     * If this value is less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n     * the same numerical value as this `UShort`.\n     *\n     * The resulting `UByte` value is represented by the least significant 8 bits of this `UShort` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = data.toUByte()\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = this\n    /**\n     * Converts this [UShort] value to [UInt].\n     *\n     * The resulting `UInt` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `UInt` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 16 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = UInt(data.toInt() and 0xFFFF)\n    /**\n     * Converts this [UShort] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `ULong` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 48 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFFFF)\n\n    /**\n     * Converts this [UShort] value to [Float].\n     *\n     * The resulting `Float` value represents the same numerical value as this `UShort`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toInt().toFloat()\n    /**\n     * Converts this [UShort] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UShort`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = this.toInt().toDouble()\n\n    public override fun toString(): String = toInt().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UShort].\n *\n * If this value is positive, the resulting `UShort` value represents the same numerical value as this `Byte`.\n *\n * The least significant 8 bits of the resulting `UShort` value are the same as the bits of this `Byte` value,\n * whereas the most significant 8 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUShort(): UShort = UShort(this.toShort())\n/**\n * Converts this [Short] value to [UShort].\n *\n * If this value is positive, the resulting `UShort` value represents the same numerical value as this `Short`.\n *\n * The resulting `UShort` value has the same binary representation as this `Short` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUShort(): UShort = UShort(this)\n/**\n * Converts this [Int] value to [UShort].\n *\n * If this value is positive and less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n * the same numerical value as this `Int`.\n *\n * The resulting `UShort` value is represented by the least significant 16 bits of this `Int` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUShort(): UShort = UShort(this.toShort())\n/**\n * Converts this [Long] value to [UShort].\n *\n * If this value is positive and less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UShort` value is represented by the least significant 16 bits of this `Long` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUShort(): UShort = UShort(this.toShort())\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.ranges\n\n/**\n * A range of values of type `Char`.\n */\npublic class CharRange(start: Char, endInclusive: Char) : CharProgression(start, endInclusive, 1), ClosedRange<Char> {\n    override val start: Char get() = first\n    override val endInclusive: Char get() = last\n\n    override fun contains(value: Char): Boolean = first <= value && value <= last\n\n    override fun isEmpty(): Boolean = first > last\n\n    override fun equals(other: Any?): Boolean =\n        other is CharRange && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * first.toInt() + last.toInt())\n\n    override fun toString(): String = \"$first..$last\"\n\n    companion object {\n        /** An empty range of values of type Char. */\n        public val EMPTY: CharRange = CharRange(1.toChar(), 0.toChar())\n    }\n}\n\n/**\n * A range of values of type `Int`.\n */\npublic class IntRange(start: Int, endInclusive: Int) : IntProgression(start, endInclusive, 1), ClosedRange<Int> {\n    override val start: Int get() = first\n    override val endInclusive: Int get() = last\n\n    override fun contains(value: Int): Boolean = first <= value && value <= last\n\n    override fun isEmpty(): Boolean = first > last\n\n    override fun equals(other: Any?): Boolean =\n        other is IntRange && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * first + last)\n\n    override fun toString(): String = \"$first..$last\"\n\n    companion object {\n        /** An empty range of values of type Int. */\n        public val EMPTY: IntRange = IntRange(1, 0)\n    }\n}\n\n/**\n * A range of values of type `Long`.\n */\npublic class LongRange(start: Long, endInclusive: Long) : LongProgression(start, endInclusive, 1), ClosedRange<Long> {\n    override val start: Long get() = first\n    override val endInclusive: Long get() = last\n\n    override fun contains(value: Long): Boolean = first <= value && value <= last\n\n    override fun isEmpty(): Boolean = first > last\n\n    override fun equals(other: Any?): Boolean =\n        other is LongRange && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (first xor (first ushr 32)) + (last xor (last ushr 32))).toInt()\n\n    override fun toString(): String = \"$first..$last\"\n\n    companion object {\n        /** An empty range of values of type Long. */\n        public val EMPTY: LongRange = LongRange(1, 0)\n    }\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n@file:UseExperimental(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\ninternal object EmptyIterator : ListIterator<Nothing> {\n    override fun hasNext(): Boolean = false\n    override fun hasPrevious(): Boolean = false\n    override fun nextIndex(): Int = 0\n    override fun previousIndex(): Int = -1\n    override fun next(): Nothing = throw NoSuchElementException()\n    override fun previous(): Nothing = throw NoSuchElementException()\n}\n\ninternal object EmptyList : List<Nothing>, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n\n    override fun equals(other: Any?): Boolean = other is List<*> && other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun listIterator(): ListIterator<Nothing> = EmptyIterator\n    override fun listIterator(index: Int): ListIterator<Nothing> {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<Nothing> {\n        if (fromIndex == 0 && toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}\n\ninternal fun <T> Array<out T>.asCollection(): Collection<T> = ArrayAsCollection(this, isVarargs = false)\n\nprivate class ArrayAsCollection<T>(val values: Array<out T>, val isVarargs: Boolean) : Collection<T> {\n    override val size: Int get() = values.size\n    override fun isEmpty(): Boolean = values.isEmpty()\n    override fun contains(element: T): Boolean = values.contains(element)\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n    override fun iterator(): Iterator<T> = values.iterator()\n    // override hidden toArray implementation to prevent copying of values array\n    public fun toArray(): Array<out Any?> = values.copyToArrayOfAny(isVarargs)\n}\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\npublic fun <T> emptyList(): List<T> = EmptyList\n\n/**\n * Returns a new read-only list of given elements.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.readOnlyList\n */\npublic fun <T> listOf(vararg elements: T): List<T> = if (elements.size > 0) elements.asList() else emptyList()\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> listOf(): List<T> = emptyList()\n\n/**\n * Returns an empty new [MutableList].\n * @sample samples.collections.Collections.Lists.emptyMutableList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableListOf(): MutableList<T> = ArrayList()\n\n/**\n * Returns an empty new [ArrayList].\n * @sample samples.collections.Collections.Lists.emptyArrayList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> arrayListOf(): ArrayList<T> = ArrayList()\n\n/**\n * Returns a new [MutableList] with the given elements.\n * @sample samples.collections.Collections.Lists.mutableList\n */\npublic fun <T> mutableListOf(vararg elements: T): MutableList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new [ArrayList] with the given elements.\n * @sample samples.collections.Collections.Lists.arrayList\n */\npublic fun <T> arrayListOf(vararg elements: T): ArrayList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new read-only list either of single given element, if it is not null, or empty list if the element is null. The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(element: T?): List<T> = if (element != null) listOf(element) else emptyList()\n\n/**\n * Returns a new read-only list only of those given elements, that are not null.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(vararg elements: T?): List<T> = elements.filterNotNull()\n\n/**\n * Creates a new read-only list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.readOnlyListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)\n\n/**\n * Creates a new mutable list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.mutableListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {\n    val list = ArrayList<T>(size)\n    repeat(size) { index -> list.add(init(index)) }\n    return list\n}\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * @sample samples.collections.Builders.Lists.buildListSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildList(@BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return ArrayList<E>().apply(builderAction)\n}\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * [capacity] is used to hint the expected number of elements added in the [builderAction].\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Lists.buildListSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildList(capacity: Int, @BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    checkBuilderCapacity(capacity)\n    return ArrayList<E>(capacity).apply(builderAction)\n}\n\n\n/**\n * Returns an [IntRange] of the valid indices for this collection.\n * @sample samples.collections.Collections.Collections.indicesOfCollection\n */\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\n/**\n * Returns the index of the last item in the list or -1 if the list is empty.\n *\n * @sample samples.collections.Collections.Lists.lastIndexOfList\n */\npublic val <T> List<T>.lastIndex: Int\n    get() = this.size - 1\n\n/**\n * Returns `true` if the collection is not empty.\n * @sample samples.collections.Collections.Collections.collectionIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable collection is either null or empty.\n * @sample samples.collections.Collections.Collections.collectionIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.isEmpty()\n}\n\n/**\n * Returns this Collection if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Collections.collectionOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.orEmpty(): Collection<T> = this ?: emptyList()\n\n/**\n * Returns this List if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Lists.listOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>?.orEmpty(): List<T> = this ?: emptyList()\n\n/**\n * Returns this collection if it's not empty\n * or the result of calling [defaultValue] function if the collection is empty.\n *\n * @sample samples.collections.Collections.Collections.collectionIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : Collection<*>, C : R =\n    if (isEmpty()) defaultValue() else this\n\n\n/**\n * Checks if all elements in the specified collection are contained in this collection.\n *\n * Allows to overcome type-safety restriction of `containsAll` that requires to pass a collection of type `Collection<E>`.\n * @sample samples.collections.Collections.Collections.collectionContainsAll\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> Collection<T>.containsAll(elements: Collection<T>): Boolean = this.containsAll(elements)\n\ninternal fun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList()\n    1 -> listOf(this[0])\n    else -> this\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of its elements,\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchOnComparable\n * @sample samples.collections.Collections.Lists.binarySearchWithBoundaries\n */\npublic fun <T : Comparable<T>> List<T?>.binarySearch(element: T?, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = compareValues(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the specified [comparator],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted according to the specified [comparator].\n * @sample samples.collections.Collections.Lists.binarySearchWithComparator\n */\npublic fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparator.compare(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for an element having the key returned by the specified [selector] function\n * equal to the provided [key] value using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of keys of its elements.\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements with the specified [key], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element with the specified [key], if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchByKey\n */\npublic inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(\n    key: K?,\n    fromIndex: Int = 0,\n    toIndex: Int = size,\n    crossinline selector: (T) -> K?\n): Int =\n    binarySearch(fromIndex, toIndex) { compareValues(selector(it), key) }\n\n// do not introduce this overload --- too rare\n//public fun <T, K> List<T>.binarySearchBy(key: K, comparator: Comparator<K>, fromIndex: Int = 0, toIndex: Int = size(), selector: (T) -> K): Int =\n//        binarySearch(fromIndex, toIndex) { comparator.compare(selector(it), key) }\n\n\n/**\n * Searches this list or its range for an element for which the given [comparison] function returns zero using the binary search algorithm.\n *\n * The list is expected to be sorted so that the signs of the [comparison] function's return values ascend on the list elements,\n * i.e. negative values come before zero and zeroes come before positive values.\n * Otherwise, the result is undefined.\n *\n * If the list contains multiple elements for which [comparison] returns zero, there is no guarantee which one will be found.\n *\n * @param comparison function that returns zero when called on the list element being searched.\n * On the elements coming before the target element, the function must return negative values;\n * on the elements coming after the target element, the function must return positive values.\n *\n * @return the index of the found element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchWithComparisonFunction\n */\npublic fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, comparison: (T) -> Int): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparison(midVal)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Checks that `from` and `to` are in\n * the range of [0..size] and throws an appropriate exception, if they aren't.\n */\nprivate fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n    when {\n        fromIndex > toIndex -> throw IllegalArgumentException(\"fromIndex ($fromIndex) is greater than toIndex ($toIndex).\")\n        fromIndex < 0 -> throw IndexOutOfBoundsException(\"fromIndex ($fromIndex) is less than zero.\")\n        toIndex > size -> throw IndexOutOfBoundsException(\"toIndex ($toIndex) is greater than size ($size).\")\n    }\n}\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkIndexOverflow(index: Int): Int\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkCountOverflow(count: Int): Int\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwIndexOverflow() { throw ArithmeticException(\"Index overflow has happened.\") }\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwCountOverflow() { throw ArithmeticException(\"Count overflow has happened.\") }\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n@file:UseExperimental(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\nprivate object EmptyMap : Map<Any?, Nothing>, Serializable {\n    private const val serialVersionUID: Long = 8246714829545688274\n\n    override fun equals(other: Any?): Boolean = other is Map<*, *> && other.isEmpty()\n    override fun hashCode(): Int = 0\n    override fun toString(): String = \"{}\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n\n    override fun containsKey(key: Any?): Boolean = false\n    override fun containsValue(value: Nothing): Boolean = false\n    override fun get(key: Any?): Nothing? = null\n    override val entries: Set<Map.Entry<Any?, Nothing>> get() = EmptySet\n    override val keys: Set<Any?> get() = EmptySet\n    override val values: Collection<Nothing> get() = EmptyList\n\n    private fun readResolve(): Any = EmptyMap\n}\n\n/**\n * Returns an empty read-only map of specified type.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\npublic fun <K, V> emptyMap(): Map<K, V> = @Suppress(\"UNCHECKED_CAST\") (EmptyMap as Map<K, V>)\n\n/**\n * Returns a new read-only map with the specified contents, given as a list of pairs\n * where the first value is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * The returned map is serializable (JVM).\n *\n * @sample samples.collections.Maps.Instantiation.mapFromPairs\n */\npublic fun <K, V> mapOf(vararg pairs: Pair<K, V>): Map<K, V> =\n    if (pairs.size > 0) pairs.toMap(LinkedHashMap(mapCapacity(pairs.size))) else emptyMap()\n\n/**\n * Returns an empty read-only map.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mapOf(): Map<K, V> = emptyMap()\n\n/**\n * Returns an empty new [MutableMap].\n *\n * The returned map preserves the entry iteration order.\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mutableMapOf(): MutableMap<K, V> = LinkedHashMap()\n\n/**\n * Returns a new [MutableMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.mutableMapFromPairs\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\npublic fun <K, V> mutableMapOf(vararg pairs: Pair<K, V>): MutableMap<K, V> =\n    LinkedHashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [HashMap].\n *\n * @sample samples.collections.Maps.Instantiation.emptyHashMap\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> hashMapOf(): HashMap<K, V> = HashMap<K, V>()\n\n/**\n * Returns a new [HashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * @sample samples.collections.Maps.Instantiation.hashMapFromPairs\n */\npublic fun <K, V> hashMapOf(vararg pairs: Pair<K, V>): HashMap<K, V> = HashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [LinkedHashMap].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> linkedMapOf(): LinkedHashMap<K, V> = LinkedHashMap<K, V>()\n\n/**\n * Returns a new [LinkedHashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.linkedMapFromPairs\n */\npublic fun <K, V> linkedMapOf(vararg pairs: Pair<K, V>): LinkedHashMap<K, V> = pairs.toMap(LinkedHashMap(mapCapacity(pairs.size)))\n\n/**\n * Builds a new read-only [Map] by populating a [MutableMap] using the given [builderAction]\n * and returning a read-only map with the same key-value pairs.\n *\n * The map passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * Entries of the map are iterated in the order they were added by the [builderAction].\n *\n * @sample samples.collections.Builders.Maps.buildMapSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> buildMap(@BuilderInference builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return LinkedHashMap<K, V>().apply(builderAction)\n}\n\n/**\n * Builds a new read-only [Map] by populating a [MutableMap] using the given [builderAction]\n * and returning a read-only map with the same key-value pairs.\n *\n * The map passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * [capacity] is used to hint the expected number of pairs added in the [builderAction].\n *\n * Entries of the map are iterated in the order they were added by the [builderAction].\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Maps.buildMapSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> buildMap(capacity: Int, @BuilderInference builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    checkBuilderCapacity(capacity)\n    return LinkedHashMap<K, V>(mapCapacity(capacity)).apply(builderAction)\n}\n\n/**\n * Calculate the initial capacity of a map.\n */\n@PublishedApi\ninternal expect fun mapCapacity(expectedSize: Int): Int\n\n/**\n * Checks a collection builder function capacity argument.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@PublishedApi\ninternal expect fun checkBuilderCapacity(capacity: Int)\n\n/** Returns `true` if this map is not empty. */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable map is either null or empty.\n * @sample samples.collections.Maps.Usage.mapIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || isEmpty()\n}\n\n/**\n * Returns the [Map] if its not `null`, or the empty [Map] otherwise.\n *\n * @sample samples.collections.Maps.Usage.mapOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>?.orEmpty(): Map<K, V> = this ?: emptyMap()\n\n/**\n * Returns this map if it's not empty\n * or the result of calling [defaultValue] function if the map is empty.\n *\n * @sample samples.collections.Maps.Usage.mapIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <M, R> M.ifEmpty(defaultValue: () -> R): R where M : Map<*, *>, M : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Checks if the map contains the given key.\n *\n * This method allows to use the `x in map` syntax for checking whether an object is contained in the map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.contains(key: K): Boolean = containsKey(key)\n\n/**\n * Returns the value corresponding to the given [key], or `null` if such a key is not present in the map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.get(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, V>).get(key)\n\n/**\n * Allows to use the index operator for storing values in a mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.set(key: K, value: V): Unit {\n    put(key, value)\n}\n\n/**\n * Returns `true` if the map contains the specified [key].\n *\n * Allows to overcome type-safety restriction of `containsKey` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K> Map<out K, *>.containsKey(key: K): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, *>).containsKey(key)\n\n/**\n * Returns `true` if the map maps one or more keys to the specified [value].\n *\n * Allows to overcome type-safety restriction of `containsValue` that requires to pass a value of type `V`.\n *\n * @sample samples.collections.Maps.Usage.containsValue\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <K, @kotlin.internal.OnlyInputTypes V> Map<K, V>.containsValue(value: V): Boolean = this.containsValue(value)\n\n\n/**\n * Removes the specified key and its corresponding value from this map.\n *\n * @return the previous value associated with the key, or `null` if the key was not present in the map.\n\n * Allows to overcome type-safety restriction of `remove` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K, V> MutableMap<out K, V>.remove(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableMap<K, V>).remove(key)\n\n/**\n * Returns the key component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component1(): K = key\n\n/**\n * Returns the value component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component2(): V = value\n\n/**\n * Converts entry to [Pair] with key being first component and value being second.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map.Entry<K, V>.toPair(): Pair<K, V> = Pair(key, value)\n\n/**\n * Returns the value for the given key, or the result of the [defaultValue] function if there was no entry for the given key.\n *\n * @sample samples.collections.Maps.Usage.getOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>.getOrElse(key: K, defaultValue: () -> V): V = get(key) ?: defaultValue()\n\n\ninternal inline fun <K, V> Map<K, V>.getOrElseNullable(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    if (value == null && !containsKey(key)) {\n        return defaultValue()\n    } else {\n        @Suppress(\"UNCHECKED_CAST\")\n        return value as V\n    }\n}\n\n/**\n * Returns the value for the given [key] or throws an exception if there is no such key in the map.\n *\n * If the map was created by [withDefault], resorts to its `defaultValue` provider function\n * instead of throwing an exception.\n *\n * @throws NoSuchElementException when the map doesn't contain a value for the specified key and\n * no implicit default value was provided for that map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<K, V>.getValue(key: K): V = getOrImplicitDefault(key)\n\n/**\n * Returns the value for the given key. If the key is not found in the map, calls the [defaultValue] function,\n * puts its result into the map under the given key and returns it.\n *\n * Note that the operation is not guaranteed to be atomic if the map is being modified concurrently.\n *\n * @sample samples.collections.Maps.Usage.getOrPut\n */\npublic inline fun <K, V> MutableMap<K, V>.getOrPut(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    return if (value == null) {\n        val answer = defaultValue()\n        put(key, answer)\n        answer\n    } else {\n        value\n    }\n}\n\n/**\n * Returns an [Iterator] over the entries in the [Map].\n *\n * @sample samples.collections.Maps.Usage.forOverEntries\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map<out K, V>.iterator(): Iterator<Map.Entry<K, V>> = entries.iterator()\n\n/**\n * Returns a [MutableIterator] over the mutable entries in the [MutableMap].\n *\n */\n@kotlin.jvm.JvmName(\"mutableIterator\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.iterator(): MutableIterator<MutableMap.MutableEntry<K, V>> = entries.iterator()\n\n/**\n * Populates the given [destination] map with entries having the keys of this map and the values obtained\n * by applying the [transform] function to each entry in this [Map].\n */\npublic inline fun <K, V, R, M : MutableMap<in K, in R>> Map<out K, V>.mapValuesTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, { it.key }, transform)\n}\n\n/**\n * Populates the given [destination] map with entries having the keys obtained\n * by applying the [transform] function to each entry in this [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n */\npublic inline fun <K, V, R, M : MutableMap<in R, in V>> Map<out K, V>.mapKeysTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, transform, { it.value })\n}\n\n/**\n * Puts all the given [pairs] into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Array<out Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given collection into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Iterable<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given sequence into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Sequence<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Returns a new map with entries having the keys of this map and the values obtained by applying the [transform]\n * function to each entry in this [Map].\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapValues\n */\npublic inline fun <K, V, R> Map<out K, V>.mapValues(transform: (Map.Entry<K, V>) -> R): Map<K, R> {\n    return mapValuesTo(LinkedHashMap<K, R>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a new Map with entries having the keys obtained by applying the [transform] function to each entry in this\n * [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapKeys\n */\npublic inline fun <K, V, R> Map<out K, V>.mapKeys(transform: (Map.Entry<K, V>) -> R): Map<R, V> {\n    return mapKeysTo(LinkedHashMap<R, V>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a map containing all key-value pairs with keys matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterKeys\n */\npublic inline fun <K, V> Map<out K, V>.filterKeys(predicate: (K) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.key)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n/**\n * Returns a map containing all key-value pairs with values matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n *  @sample samples.collections.Maps.Filtering.filterValues\n */\npublic inline fun <K, V> Map<out K, V>.filterValues(predicate: (V) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.value)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n\n/**\n * Appends all entries matching the given [predicate] into the mutable map given as [destination] parameter.\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filter\n */\npublic inline fun <K, V> Map<out K, V>.filter(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Appends all entries not matching the given [predicate] into the given [destination].\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterNotTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterNotTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (!predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs not matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterNot\n */\npublic inline fun <K, V> Map<out K, V>.filterNot(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterNotTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Returns a new map containing all key-value pairs from the given collection of pairs.\n *\n * The returned map preserves the entry iteration order of the original collection.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Iterable<Pair<K, V>>.toMap(): Map<K, V> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyMap()\n            1 -> mapOf(if (this is List) this[0] else iterator().next())\n            else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n        }\n    }\n    return toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given collection of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Iterable<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given array of pairs.\n *\n * The returned map preserves the entry iteration order of the original array.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Array<out Pair<K, V>>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> mapOf(this[0])\n    else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n}\n\n/**\n *  Populates and returns the [destination] mutable map with key-value pairs from the given array of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Array<out Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given sequence of pairs.\n *\n * The returned map preserves the entry iteration order of the original sequence.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Sequence<Pair<K, V>>.toMap(): Map<K, V> = toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given sequence of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Sequence<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new read-only map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMap()\n    else -> toMutableMap()\n}\n\n/**\n * Returns a new mutable map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMutableMap(): MutableMap<K, V> = LinkedHashMap(this)\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Creates a new read-only map by replacing or adding an entry to this map from a given key-value [pair].\n *\n * The returned map preserves the entry iteration order of the original map.\n * The [pair] is iterated in the end if it has a unique key.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pair: Pair<K, V>): Map<K, V> =\n    if (this.isEmpty()) mapOf(pair) else LinkedHashMap(this).apply { put(pair.first, pair.second) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given collection of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] collection.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Iterable<Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given array of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] array.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Array<out Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given sequence of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] sequence.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Sequence<Pair<K, V>>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(pairs) }.optimizeReadOnlyMap()\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from another [map].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those entries of another [map] that are missing in this map are iterated in the end in the order of that [map].\n */\npublic operator fun <K, V> Map<out K, V>.plus(map: Map<out K, V>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(map) }\n\n\n/**\n * Appends or replaces the given [pair] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pair: Pair<K, V>) {\n    put(pair.first, pair.second)\n}\n\n/**\n * Appends or replaces all pairs from the given collection of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Iterable<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given array of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Array<out Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given sequence of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Sequence<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all entries from the given [map] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(map: Map<K, V>) {\n    putAll(map)\n}\n\n/**\n * Returns a map containing all entries of the original map except the entry with the given [key].\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(key: K): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(key) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] collection.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Iterable<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] array.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Array<out K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] sequence.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Sequence<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Removes the entry with the given [key] from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(key: K) {\n    remove(key)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] collection from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Iterable<K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] array from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Array<out K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries from the keys of which are contained in the given [keys] sequence from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Sequence<K>) {\n    this.keys.removeAll(keys)\n}\n\n\n// do not expose for now @PublishedApi\ninternal fun <K, V> Map<K, V>.optimizeReadOnlyMap() = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMapOrSelf()\n    else -> this\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SetsKt\")\n@file:UseExperimental(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\ninternal object EmptySet : Set<Nothing>, Serializable {\n    private const val serialVersionUID: Long = 3406603774387020532\n\n    override fun equals(other: Any?): Boolean = other is Set<*> && other.isEmpty()\n    override fun hashCode(): Int = 0\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n\n    private fun readResolve(): Any = EmptySet\n}\n\n\n/**\n * Returns an empty read-only set.  The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.emptyReadOnlySet\n */\npublic fun <T> emptySet(): Set<T> = EmptySet\n\n/**\n * Returns a new read-only set with the given elements.\n * Elements of the set are iterated in the order they were specified.\n * The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.readOnlySet\n */\npublic fun <T> setOf(vararg elements: T): Set<T> = if (elements.size > 0) elements.toSet() else emptySet()\n\n/**\n * Returns an empty read-only set.  The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.emptyReadOnlySet\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> setOf(): Set<T> = emptySet()\n\n/**\n * Returns an empty new [MutableSet].\n *\n * The returned set preserves the element iteration order.\n * @sample samples.collections.Collections.Sets.emptyMutableSet\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableSetOf(): MutableSet<T> = LinkedHashSet()\n\n/**\n * Returns a new [MutableSet] with the given elements.\n * Elements of the set are iterated in the order they were specified.\n * @sample samples.collections.Collections.Sets.mutableSet\n */\npublic fun <T> mutableSetOf(vararg elements: T): MutableSet<T> = elements.toCollection(LinkedHashSet(mapCapacity(elements.size)))\n\n/** Returns an empty new [HashSet]. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> hashSetOf(): HashSet<T> = HashSet()\n\n/** Returns a new [HashSet] with the given elements. */\npublic fun <T> hashSetOf(vararg elements: T): HashSet<T> = elements.toCollection(HashSet(mapCapacity(elements.size)))\n\n/**\n * Returns an empty new [LinkedHashSet].\n * @sample samples.collections.Collections.Sets.emptyLinkedHashSet\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> linkedSetOf(): LinkedHashSet<T> = LinkedHashSet()\n\n/**\n * Returns a new [LinkedHashSet] with the given elements.\n * Elements of the set are iterated in the order they were specified.\n * @sample samples.collections.Collections.Sets.linkedHashSet\n */\npublic fun <T> linkedSetOf(vararg elements: T): LinkedHashSet<T> = elements.toCollection(LinkedHashSet(mapCapacity(elements.size)))\n\n/**\n * Builds a new read-only [Set] by populating a [MutableSet] using the given [builderAction]\n * and returning a read-only set with the same elements.\n *\n * The set passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * Elements of the set are iterated in the order they were added by the [builderAction].\n *\n * @sample samples.collections.Builders.Sets.buildSetSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildSet(@BuilderInference builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return LinkedHashSet<E>().apply(builderAction)\n}\n\n/**\n * Builds a new read-only [Set] by populating a [MutableSet] using the given [builderAction]\n * and returning a read-only set with the same elements.\n *\n * The set passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * [capacity] is used to hint the expected number of elements added in the [builderAction].\n *\n * Elements of the set are iterated in the order they were added by the [builderAction].\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Sets.buildSetSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildSet(capacity: Int, @BuilderInference builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    checkBuilderCapacity(capacity)\n    return LinkedHashSet<E>(mapCapacity(capacity)).apply(builderAction)\n}\n\n\n/** Returns this Set if it's not `null` and the empty set otherwise. */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Set<T>?.orEmpty(): Set<T> = this ?: emptySet()\n\ninternal fun <T> Set<T>.optimizeReadOnlySet() = when (size) {\n    0 -> emptySet()\n    1 -> setOf(iterator().next())\n    else -> this\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n@file:Suppress(\"PLATFORM_CLASS_MAPPED_TO_KOTLIN\")\n\npackage kotlin.text\n\n/**\n * Parses the string as a signed [Byte] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toByteOrNull(): Byte? = toByteOrNull(radix = 10)\n\n/**\n * Parses the string as a signed [Byte] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toByteOrNull(radix: Int): Byte? {\n    val int = this.toIntOrNull(radix) ?: return null\n    if (int < Byte.MIN_VALUE || int > Byte.MAX_VALUE) return null\n    return int.toByte()\n}\n\n/**\n * Parses the string as a [Short] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toShortOrNull(): Short? = toShortOrNull(radix = 10)\n\n/**\n * Parses the string as a [Short] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toShortOrNull(radix: Int): Short? {\n    val int = this.toIntOrNull(radix) ?: return null\n    if (int < Short.MIN_VALUE || int > Short.MAX_VALUE) return null\n    return int.toShort()\n}\n\n/**\n * Parses the string as an [Int] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toIntOrNull(): Int? = toIntOrNull(radix = 10)\n\n/**\n * Parses the string as an [Int] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toIntOrNull(radix: Int): Int? {\n    checkRadix(radix)\n\n    val length = this.length\n    if (length == 0) return null\n\n    val start: Int\n    val isNegative: Boolean\n    val limit: Int\n\n    val firstChar = this[0]\n    if (firstChar < '0') {  // Possible leading sign\n        if (length == 1) return null  // non-digit (possible sign) only, no digits after\n\n        start = 1\n\n        if (firstChar == '-') {\n            isNegative = true\n            limit = Int.MIN_VALUE\n        } else if (firstChar == '+') {\n            isNegative = false\n            limit = -Int.MAX_VALUE\n        } else\n            return null\n    } else {\n        start = 0\n        isNegative = false\n        limit = -Int.MAX_VALUE\n    }\n\n\n    val limitForMaxRadix = (-Int.MAX_VALUE) / 36\n\n    var limitBeforeMul = limitForMaxRadix\n    var result = 0\n    for (i in start until length) {\n        val digit = digitOf(this[i], radix)\n\n        if (digit < 0) return null\n        if (result < limitBeforeMul) {\n            if (limitBeforeMul == limitForMaxRadix) {\n                limitBeforeMul = limit / radix\n\n                if (result < limitBeforeMul) {\n                    return null\n                }\n            } else {\n                return null\n            }\n        }\n\n        result *= radix\n\n        if (result < limit + digit) return null\n\n        result -= digit\n    }\n\n    return if (isNegative) result else -result\n}\n\n/**\n * Parses the string as a [Long] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toLongOrNull(): Long? = toLongOrNull(radix = 10)\n\n/**\n * Parses the string as a [Long] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toLongOrNull(radix: Int): Long? {\n    checkRadix(radix)\n\n    val length = this.length\n    if (length == 0) return null\n\n    val start: Int\n    val isNegative: Boolean\n    val limit: Long\n\n    val firstChar = this[0]\n    if (firstChar < '0') {  // Possible leading sign\n        if (length == 1) return null  // non-digit (possible sign) only, no digits after\n\n        start = 1\n\n        if (firstChar == '-') {\n            isNegative = true\n            limit = Long.MIN_VALUE\n        } else if (firstChar == '+') {\n            isNegative = false\n            limit = -Long.MAX_VALUE\n        } else\n            return null\n    } else {\n        start = 0\n        isNegative = false\n        limit = -Long.MAX_VALUE\n    }\n\n\n    val limitForMaxRadix = (-Long.MAX_VALUE) / 36\n\n    var limitBeforeMul = limitForMaxRadix\n    var result = 0L\n    for (i in start until length) {\n        val digit = digitOf(this[i], radix)\n\n        if (digit < 0) return null\n        if (result < limitBeforeMul) {\n            if (limitBeforeMul == limitForMaxRadix) {\n                limitBeforeMul = limit / radix\n\n                if (result < limitBeforeMul) {\n                    return null\n                }\n            } else {\n                return null\n            }\n        }\n\n        result *= radix\n\n        if (result < limit + digit) return null\n\n        result -= digit\n    }\n\n    return if (isNegative) result else -result\n}\n\n\ninternal fun numberFormatError(input: String): Nothing = throw NumberFormatException(\"Invalid number format: '$input'\")\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 1.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 2.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 3.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 4.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 5.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the collection.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.contains(element: T): Boolean {\n    if (this is Collection)\n        return contains(element)\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Iterable<T>.elementAt(index: Int): T {\n    if (this is List)\n        return get(index)\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Collection doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAt(index: Int): T {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Iterable<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (this is List)\n        return this.getOrElse(index, defaultValue)\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Iterable<T>.elementAtOrNull(index: Int): T? {\n    if (this is List)\n        return this.getOrNull(index)\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.first(): T {\n    when (this) {\n        is List -> return this.first()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.firstOrNull(): T? {\n    when (this) {\n        is List -> {\n            if (isEmpty())\n                return null\n            else\n                return this[0]\n        }\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns the first element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Iterable<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n */\npublic fun <T> List<T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.indexOf(element: T): Int {\n    if (this is List) return this.indexOf(element)\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.indexOf(element: T): Int {\n    return indexOf(element)\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (predicate(iterator.previous())) {\n            return iterator.nextIndex()\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.last(): T {\n    when (this) {\n        is List -> return this.last()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> List<T>.last(predicate: (T) -> Boolean): T {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"List contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.lastIndexOf(element: T): Int {\n    if (this is List) return this.lastIndexOf(element)\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns last index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.lastIndexOf(element: T): Int {\n    return lastIndexOf(element)\n}\n\n/**\n * Returns the last element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.lastOrNull(): T? {\n    when (this) {\n        is List -> return if (isEmpty()) null else this[size - 1]\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> Iterable<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> List<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this collection.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Collection<T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Collection is empty.\")\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this collection, or `null` if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.randomOrNull(): T? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness, or `null` if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun <T> Collection<T>.randomOrNull(random: Random): T? {\n    if (isEmpty())\n        return null\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.single(): T {\n    when (this) {\n        is List -> return this.single()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            val single = iterator.next()\n            if (iterator.hasNext())\n                throw IllegalArgumentException(\"Collection has more than one element.\")\n            return single\n        }\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"List is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"List has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Iterable<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Collection contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.singleOrNull(): T? {\n    when (this) {\n        is List -> return if (size == 1) this[0] else null\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            val single = iterator.next()\n            if (iterator.hasNext())\n                return null\n            return single\n        }\n    }\n}\n\n/**\n * Returns single element, or `null` if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Iterable<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Iterable<T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return toList()\n    val list: ArrayList<T>\n    if (this is Collection<*>) {\n        val resultSize = size - n\n        if (resultSize <= 0)\n            return emptyList()\n        if (resultSize == 1)\n            return listOf(last())\n        list = ArrayList<T>(resultSize)\n        if (this is List<T>) {\n            if (this is RandomAccess) {\n                for (index in n until size)\n                    list.add(this[index])\n            } else {\n                for (item in listIterator(n))\n                    list.add(item)\n            }\n            return list\n        }\n    }\n    else {\n        list = ArrayList<T>()\n    }\n    var count = 0\n    for (item in this) {\n        if (count >= n) list.add(item) else ++count\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> List<T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> List<T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            if (!predicate(iterator.previous())) {\n                return take(iterator.nextIndex() + 1)\n            }\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Iterable<T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T> Iterable<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n */\npublic inline fun <reified R> Iterable<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Iterable<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n */\npublic fun <T : Any> Iterable<T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n */\npublic fun <C : MutableCollection<in T>, T : Any> Iterable<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> List<T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return this.subList(indices.start, indices.endInclusive + 1).toList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> List<T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Iterable<T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (this is Collection<T>) {\n        if (n >= size) return toList()\n        if (n == 1) return listOf(first())\n    }\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> List<T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(last())\n    val list = ArrayList<T>(n)\n    if (this is RandomAccess) {\n        for (index in size - n until size)\n            list.add(this[index])\n    } else {\n        for (item in listIterator(size - n))\n            list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> List<T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (isEmpty())\n        return emptyList()\n    val iterator = listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (!predicate(iterator.previous())) {\n            iterator.next()\n            val expectedSize = size - iterator.nextIndex()\n            if (expectedSize == 0) return emptyList()\n            return ArrayList<T>(expectedSize).apply {\n                while (iterator.hasNext())\n                    add(iterator.next())\n            }\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Iterable<T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the list in-place.\n */\npublic expect fun <T> MutableList<T>.reverse(): Unit\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Iterable<T>.reversed(): List<T> {\n    if (this is Collection && size <= 1) return toList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Sorts elements in the list in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> MutableList<T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sorted(): List<T> {\n    if (this is Collection) {\n        if (size <= 1) return this.toList()\n        @Suppress(\"UNCHECKED_CAST\")\n        return (toTypedArray<Comparable<T>>() as Array<T>).apply { sort() }.asList()\n    }\n    return toMutableList().apply { sort() }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Iterable<T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    if (this is Collection) {\n       if (size <= 1) return this.toList()\n       @Suppress(\"UNCHECKED_CAST\")\n       return (toTypedArray<Any?>() as Array<T>).apply { sortWith(comparator) }.asList()\n    }\n    return toMutableList().apply { sortWith(comparator) }\n}\n\n/**\n * Returns an array of Boolean containing all of the elements of this collection.\n */\npublic fun Collection<Boolean>.toBooleanArray(): BooleanArray {\n    val result = BooleanArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this collection.\n */\npublic fun Collection<Byte>.toByteArray(): ByteArray {\n    val result = ByteArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Char containing all of the elements of this collection.\n */\npublic fun Collection<Char>.toCharArray(): CharArray {\n    val result = CharArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Double containing all of the elements of this collection.\n */\npublic fun Collection<Double>.toDoubleArray(): DoubleArray {\n    val result = DoubleArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Float containing all of the elements of this collection.\n */\npublic fun Collection<Float>.toFloatArray(): FloatArray {\n    val result = FloatArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Int containing all of the elements of this collection.\n */\npublic fun Collection<Int>.toIntArray(): IntArray {\n    val result = IntArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Long containing all of the elements of this collection.\n */\npublic fun Collection<Long>.toLongArray(): LongArray {\n    val result = LongArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Short containing all of the elements of this collection.\n */\npublic fun Collection<Short>.toShortArray(): ShortArray {\n    val result = ShortArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associate\n */\npublic inline fun <T, K, V> Iterable<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given collection indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateBy\n */\npublic inline fun <T, K> Iterable<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateByWithValueTransform\n */\npublic inline fun <T, K, V> Iterable<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given collection\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given collection and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Iterable<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given collection,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Iterable<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Iterable<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun <T> Iterable<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(collectionSizeOrDefault(12))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Iterable<T>.toList(): List<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyList()\n            1 -> listOf(if (this is List) get(0) else iterator().next())\n            else -> this.toMutableList()\n        }\n    }\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Iterable<T>.toMutableList(): MutableList<T> {\n    if (this is Collection<T>)\n        return this.toMutableList()\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Collection<T>.toMutableList(): MutableList<T> {\n    return ArrayList(this)\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toSet(): Set<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptySet()\n            1 -> setOf(if (this is List) this[0] else iterator().next())\n            else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n        }\n    }\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Iterable<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a collection to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Iterable<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Iterable<T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original collection.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original collection\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original collection\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original collection\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun <T> Iterable<T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given collection.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Iterable<T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given collection\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <T, K> Iterable<T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this collection and the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun <T> Iterable<T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this collection and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toMutableSet(): MutableSet<T> {\n    return when (this) {\n        is Collection<T> -> LinkedHashSet(this)\n        else -> toCollection(LinkedHashSet<T>())\n    }\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original collection.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun <T> Iterable<T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Iterable<T>.all(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if collection has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Iterable<T>.any(): Boolean {\n    if (this is Collection) return !isEmpty()\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Iterable<T>.any(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this collection.\n */\npublic fun <T> Iterable<T>.count(): Int {\n    if (this is Collection) return size\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements in this collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.count(predicate: (T) -> Boolean): Int {\n    if (this is Collection && isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <T, R> Iterable<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            accumulator = operation(iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            val index = iterator.previousIndex()\n            accumulator = operation(index, iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <T> Iterable<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun <T> Iterable<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.max(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.max(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.max(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.maxWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.min(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.min(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.min(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.minWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the collection has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Iterable<T>.none(): Boolean {\n    if (this is Collection) return isEmpty()\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Iterable<T>.none(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the collection itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, C : Iterable<T>> C.onEach(action: (T) -> Unit): C {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Iterable<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Iterable<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element. Returns null if the collection is empty.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun <S, T : S> Iterable<T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> List<T>.reduceRight(operation: (T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> List<T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value. Returns null if the list is empty.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun <S, T : S> List<T>.reduceRightOrNull(operation: (T, acc: S) -> S): S? {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        return null\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun <T, R> Iterable<T>.scan(initial: R, operation: (acc: R, T) -> R): List<R> {\n    val estimatedSize = collectionSizeOrDefault(9)\n    if (estimatedSize == 0) return listOf(initial)\n    val result = ArrayList<R>(estimatedSize + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun <T, R> Iterable<T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    val estimatedSize = collectionSizeOrDefault(9)\n    if (estimatedSize == 0) return listOf(initial)\n    val result = ArrayList<R>(estimatedSize + 1).apply { add(initial) }\n    var index = 0\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(index++, accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this collection.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scanReduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun <S, T : S> Iterable<T>.scanReduce(operation: (acc: S, T) -> S): List<S> {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return emptyList()\n    var accumulator: S = iterator.next()\n    val result = ArrayList<S>(collectionSizeOrDefault(10)).apply { add(accumulator) }\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with the first element of this collection.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scanReduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun <S, T : S> Iterable<T>.scanReduceIndexed(operation: (index: Int, acc: S, T) -> S): List<S> {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return emptyList()\n    var accumulator: S = iterator.next()\n    val result = ArrayList<S>(collectionSizeOrDefault(10)).apply { add(accumulator) }\n    var index = 1\n    while (iterator.hasNext()) {\n        accumulator = operation(index++, accumulator, iterator.next())\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Iterable<T?>.requireNoNulls(): Iterable<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Iterable<T>\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> List<T?>.requireNoNulls(): List<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as List<T>\n}\n\n/**\n * Splits this collection into a list of lists each not exceeding the given [size].\n * \n * The last list in the resulting list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.chunked(size: Int): List<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this collection into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.chunked(size: Int, transform: (List<T>) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\npublic operator fun <T> Iterable<T>.minus(element: T): List<T> {\n    val result = ArrayList<T>(collectionSizeOrDefault(10))\n    var removed = false\n    return this.filterTo(result) { if (!removed && it == element) { removed = true; false } else true }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] array.\n * \n * The [elements] array may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Array<out T>): List<T> {\n    if (elements.isEmpty()) return this.toList()\n    val other = elements.toHashSet()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] collection.\n * \n * The [elements] collection may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Iterable<T>): List<T> {\n    val other = elements.convertToSetForSetOperationWith(this)\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] sequence.\n * \n * The [elements] sequence may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Sequence<T>): List<T> {\n    val other = elements.toHashSet()\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minusElement(element: T): List<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original collection into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun <T> Iterable<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Iterable<T>.plus(element: T): List<T> {\n    if (this is Collection) return this.plus(element)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Collection<T>.plus(element: T): List<T> {\n    val result = ArrayList<T>(size + 1)\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Array<out T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Collection<T>.plus(elements: Array<out T>): List<T> {\n    val result = ArrayList<T>(this.size + elements.size)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Iterable<T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Collection<T>.plus(elements: Iterable<T>): List<T> {\n    if (elements is Collection) {\n        val result = ArrayList<T>(this.size + elements.size)\n        result.addAll(this)\n        result.addAll(elements)\n        return result\n    } else {\n        val result = ArrayList<T>(this)\n        result.addAll(elements)\n        return result\n    }\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Collection<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>(this.size + 10)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this collection with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<List<T>> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<List<T>>(resultCapacity)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (windowSize < size && !partialWindows) break\n            result.add(List(windowSize) { this[it + index] })\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<List<T>>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = false).forEach {\n        result.add(it)\n    }\n    return result\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this collection with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<R>(resultCapacity)\n        val window = MovingSubList(this)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (!partialWindows && windowSize < size) break\n            window.move(index, index + windowSize)\n            result.add(transform(window))\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<R>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = true).forEach {\n        result.add(transform(it))\n    }\n    return result\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = other.size\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in this) {\n        if (i >= arraySize) break\n        list.add(transform(element, other[i++]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] collection with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val first = iterator()\n    val second = other.iterator()\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), other.collectionSizeOrDefault(10)))\n    while (first.hasNext() && second.hasNext()) {\n        list.add(transform(first.next(), second.next()))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.zipWithNext(): List<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <T, R> Iterable<T>.zipWithNext(transform: (a: T, b: T) -> R): List<R> {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return emptyList()\n    val result = mutableListOf<R>()\n    var current = iterator.next()\n    while (iterator.hasNext()) {\n        val next = iterator.next()\n        result.add(transform(current, next))\n        current = next\n    }\n    return result\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Iterable<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Iterable<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Returns this collection as an [Iterable].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.asIterable(): Iterable<T> {\n    return this\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original collection returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromCollection\n */\npublic fun <T> Iterable<T>.asSequence(): Sequence<T> {\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Iterable<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Iterable<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Iterable<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Iterable<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Iterable<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Iterable<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Iterable<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Iterable<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Iterable<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Iterable<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Iterable<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Iterable<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.collections\n\n/** An iterator over a sequence of values of type `Byte`. */\npublic abstract class ByteIterator : Iterator<Byte> {\n    override final fun next() = nextByte()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextByte(): Byte\n}\n\n/** An iterator over a sequence of values of type `Char`. */\npublic abstract class CharIterator : Iterator<Char> {\n    override final fun next() = nextChar()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextChar(): Char\n}\n\n/** An iterator over a sequence of values of type `Short`. */\npublic abstract class ShortIterator : Iterator<Short> {\n    override final fun next() = nextShort()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextShort(): Short\n}\n\n/** An iterator over a sequence of values of type `Int`. */\npublic abstract class IntIterator : Iterator<Int> {\n    override final fun next() = nextInt()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextInt(): Int\n}\n\n/** An iterator over a sequence of values of type `Long`. */\npublic abstract class LongIterator : Iterator<Long> {\n    override final fun next() = nextLong()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextLong(): Long\n}\n\n/** An iterator over a sequence of values of type `Float`. */\npublic abstract class FloatIterator : Iterator<Float> {\n    override final fun next() = nextFloat()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextFloat(): Float\n}\n\n/** An iterator over a sequence of values of type `Double`. */\npublic abstract class DoubleIterator : Iterator<Double> {\n    override final fun next() = nextDouble()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextDouble(): Double\n}\n\n/** An iterator over a sequence of values of type `Boolean`. */\npublic abstract class BooleanIterator : Iterator<Boolean> {\n    override final fun next() = nextBoolean()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextBoolean(): Boolean\n}\n\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.ranges\n\n/**\n * An iterator over a progression of values of type `Char`.\n * @property step the number by which the value is incremented on each step.\n */\ninternal class CharProgressionIterator(first: Char, last: Char, val step: Int) : CharIterator() {\n    private val finalElement = last.toInt()\n    private var hasNext: Boolean = if (step > 0) first <= last else first >= last\n    private var next = if (hasNext) first.toInt() else finalElement\n\n    override fun hasNext(): Boolean = hasNext\n\n    override fun nextChar(): Char {\n        val value = next\n        if (value == finalElement) {\n            if (!hasNext) throw kotlin.NoSuchElementException()\n            hasNext = false\n        }\n        else {\n            next += step\n        }\n        return value.toChar()\n    }\n}\n\n/**\n * An iterator over a progression of values of type `Int`.\n * @property step the number by which the value is incremented on each step.\n */\ninternal class IntProgressionIterator(first: Int, last: Int, val step: Int) : IntIterator() {\n    private val finalElement = last\n    private var hasNext: Boolean = if (step > 0) first <= last else first >= last\n    private var next = if (hasNext) first else finalElement\n\n    override fun hasNext(): Boolean = hasNext\n\n    override fun nextInt(): Int {\n        val value = next\n        if (value == finalElement) {\n            if (!hasNext) throw kotlin.NoSuchElementException()\n            hasNext = false\n        }\n        else {\n            next += step\n        }\n        return value\n    }\n}\n\n/**\n * An iterator over a progression of values of type `Long`.\n * @property step the number by which the value is incremented on each step.\n */\ninternal class LongProgressionIterator(first: Long, last: Long, val step: Long) : LongIterator() {\n    private val finalElement = last\n    private var hasNext: Boolean = if (step > 0) first <= last else first >= last\n    private var next = if (hasNext) first else finalElement\n\n    override fun hasNext(): Boolean = hasNext\n\n    override fun nextLong(): Long {\n        val value = next\n        if (value == finalElement) {\n            if (!hasNext) throw kotlin.NoSuchElementException()\n            hasNext = false\n        }\n        else {\n            next += step\n        }\n        return value\n    }\n}\n\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.ranges\n\nimport kotlin.internal.getProgressionLastElement\n\n/**\n * A progression of values of type `Char`.\n */\npublic open class CharProgression\n    internal constructor\n    (\n            start: Char,\n            endInclusive: Char,\n            step: Int\n    ) : Iterable<Char> {\n    init {\n        if (step == 0) throw kotlin.IllegalArgumentException(\"Step must be non-zero.\")\n        if (step == Int.MIN_VALUE) throw kotlin.IllegalArgumentException(\"Step must be greater than Int.MIN_VALUE to avoid overflow on negation.\")\n    }\n\n    /**\n     * The first element in the progression.\n     */\n    public val first: Char = start\n\n    /**\n     * The last element in the progression.\n     */\n    public val last: Char = getProgressionLastElement(start.toInt(), endInclusive.toInt(), step).toChar()\n\n    /**\n     * The step of the progression.\n     */\n    public val step: Int = step\n\n    override fun iterator(): CharIterator = CharProgressionIterator(first, last, step)\n\n    /** Checks if the progression is empty. */\n    public open fun isEmpty(): Boolean = if (step > 0) first > last else first < last\n\n    override fun equals(other: Any?): Boolean =\n        other is CharProgression && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last && step == other.step)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (31 * first.toInt() + last.toInt()) + step)\n\n    override fun toString(): String = if (step > 0) \"$first..$last step $step\" else \"$first downTo $last step ${-step}\"\n\n    companion object {\n        /**\n         * Creates CharProgression within the specified bounds of a closed range.\n\n         * The progression starts with the [rangeStart] value and goes toward the [rangeEnd] value not excluding it, with the specified [step].\n         * In order to go backwards the [step] must be negative.\n         *\n         * [step] must be greater than `Int.MIN_VALUE` and not equal to zero.\n         */\n        public fun fromClosedRange(rangeStart: Char, rangeEnd: Char, step: Int): CharProgression = CharProgression(rangeStart, rangeEnd, step)\n    }\n}\n\n/**\n * A progression of values of type `Int`.\n */\npublic open class IntProgression\n    internal constructor\n    (\n            start: Int,\n            endInclusive: Int,\n            step: Int\n    ) : Iterable<Int> {\n    init {\n        if (step == 0) throw kotlin.IllegalArgumentException(\"Step must be non-zero.\")\n        if (step == Int.MIN_VALUE) throw kotlin.IllegalArgumentException(\"Step must be greater than Int.MIN_VALUE to avoid overflow on negation.\")\n    }\n\n    /**\n     * The first element in the progression.\n     */\n    public val first: Int = start\n\n    /**\n     * The last element in the progression.\n     */\n    public val last: Int = getProgressionLastElement(start.toInt(), endInclusive.toInt(), step).toInt()\n\n    /**\n     * The step of the progression.\n     */\n    public val step: Int = step\n\n    override fun iterator(): IntIterator = IntProgressionIterator(first, last, step)\n\n    /** Checks if the progression is empty. */\n    public open fun isEmpty(): Boolean = if (step > 0) first > last else first < last\n\n    override fun equals(other: Any?): Boolean =\n        other is IntProgression && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last && step == other.step)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (31 * first + last) + step)\n\n    override fun toString(): String = if (step > 0) \"$first..$last step $step\" else \"$first downTo $last step ${-step}\"\n\n    companion object {\n        /**\n         * Creates IntProgression within the specified bounds of a closed range.\n\n         * The progression starts with the [rangeStart] value and goes toward the [rangeEnd] value not excluding it, with the specified [step].\n         * In order to go backwards the [step] must be negative.\n         *\n         * [step] must be greater than `Int.MIN_VALUE` and not equal to zero.\n         */\n        public fun fromClosedRange(rangeStart: Int, rangeEnd: Int, step: Int): IntProgression = IntProgression(rangeStart, rangeEnd, step)\n    }\n}\n\n/**\n * A progression of values of type `Long`.\n */\npublic open class LongProgression\n    internal constructor\n    (\n            start: Long,\n            endInclusive: Long,\n            step: Long\n    ) : Iterable<Long> {\n    init {\n        if (step == 0L) throw kotlin.IllegalArgumentException(\"Step must be non-zero.\")\n        if (step == Long.MIN_VALUE) throw kotlin.IllegalArgumentException(\"Step must be greater than Long.MIN_VALUE to avoid overflow on negation.\")\n    }\n\n    /**\n     * The first element in the progression.\n     */\n    public val first: Long = start\n\n    /**\n     * The last element in the progression.\n     */\n    public val last: Long = getProgressionLastElement(start.toLong(), endInclusive.toLong(), step).toLong()\n\n    /**\n     * The step of the progression.\n     */\n    public val step: Long = step\n\n    override fun iterator(): LongIterator = LongProgressionIterator(first, last, step)\n\n    /** Checks if the progression is empty. */\n    public open fun isEmpty(): Boolean = if (step > 0) first > last else first < last\n\n    override fun equals(other: Any?): Boolean =\n        other is LongProgression && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last && step == other.step)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (31 * (first xor (first ushr 32)) + (last xor (last ushr 32))) + (step xor (step ushr 32))).toInt()\n\n    override fun toString(): String = if (step > 0) \"$first..$last step $step\" else \"$first downTo $last step ${-step}\"\n\n    companion object {\n        /**\n         * Creates LongProgression within the specified bounds of a closed range.\n\n         * The progression starts with the [rangeStart] value and goes toward the [rangeEnd] value not excluding it, with the specified [step].\n         * In order to go backwards the [step] must be negative.\n         *\n         * [step] must be greater than `Long.MIN_VALUE` and not equal to zero.\n         */\n        public fun fromClosedRange(rangeStart: Long, rangeEnd: Long, step: Long): LongProgression = LongProgression(rangeStart, rangeEnd, step)\n    }\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:kotlin.jvm.JvmName(\"UnsignedKt\")\n@file:UseExperimental(ExperimentalUnsignedTypes::class)\npackage kotlin\n\n@PublishedApi\ninternal fun uintCompare(v1: Int, v2: Int): Int = (v1 xor Int.MIN_VALUE).compareTo(v2 xor Int.MIN_VALUE)\n@PublishedApi\ninternal fun ulongCompare(v1: Long, v2: Long): Int = (v1 xor Long.MIN_VALUE).compareTo(v2 xor Long.MIN_VALUE)\n\n@PublishedApi\ninternal fun uintDivide(v1: UInt, v2: UInt): UInt = (v1.toLong() / v2.toLong()).toUInt()\n@PublishedApi\ninternal fun uintRemainder(v1: UInt, v2: UInt): UInt = (v1.toLong() % v2.toLong()).toUInt()\n\n// Division and remainder are based on Guava's UnsignedLongs implementation\n// Copyright 2011 The Guava Authors\n\n@PublishedApi\ninternal fun ulongDivide(v1: ULong, v2: ULong): ULong {\n    val dividend = v1.toLong()\n    val divisor = v2.toLong()\n    if (divisor < 0) { // i.e., divisor >= 2^63:\n        return if (v1 < v2) ULong(0) else ULong(1)\n    }\n\n    // Optimization - use signed division if both dividend and divisor < 2^63\n    if (dividend >= 0) {\n        return ULong(dividend / divisor)\n    }\n\n    // Otherwise, approximate the quotient, check, and correct if necessary.\n    val quotient = ((dividend ushr 1) / divisor) shl 1\n    val rem = dividend - quotient * divisor\n    return ULong(quotient + if (ULong(rem) >= ULong(divisor)) 1 else 0)\n\n}\n\n@PublishedApi\ninternal fun ulongRemainder(v1: ULong, v2: ULong): ULong {\n    val dividend = v1.toLong()\n    val divisor = v2.toLong()\n    if (divisor < 0) { // i.e., divisor >= 2^63:\n        return if (v1 < v2) {\n            v1 // dividend < divisor\n        } else {\n            v1 - v2 // dividend >= divisor\n        }\n    }\n\n    // Optimization - use signed modulus if both dividend and divisor < 2^63\n    if (dividend >= 0) {\n        return ULong(dividend % divisor)\n    }\n\n    // Otherwise, approximate the quotient, check, and correct if necessary.\n    val quotient = ((dividend ushr 1) / divisor) shl 1\n    val rem = dividend - quotient * divisor\n    return ULong(rem - if (ULong(rem) >= ULong(divisor)) divisor else 0)\n}\n\n@PublishedApi\ninternal fun doubleToUInt(v: Double): UInt = when {\n    v.isNaN() -> 0u\n    v <= UInt.MIN_VALUE.toDouble() -> UInt.MIN_VALUE\n    v >= UInt.MAX_VALUE.toDouble() -> UInt.MAX_VALUE\n    v <= Int.MAX_VALUE -> v.toInt().toUInt()\n    else -> (v - Int.MAX_VALUE).toInt().toUInt() + Int.MAX_VALUE.toUInt()      // Int.MAX_VALUE < v < UInt.MAX_VALUE\n}\n\n@PublishedApi\ninternal fun doubleToULong(v: Double): ULong = when {\n    v.isNaN() -> 0u\n    v <= ULong.MIN_VALUE.toDouble() -> ULong.MIN_VALUE\n    v >= ULong.MAX_VALUE.toDouble() -> ULong.MAX_VALUE\n    v < Long.MAX_VALUE -> v.toLong().toULong()\n\n    // Real values from Long.MAX_VALUE to (Long.MAX_VALUE + 1) are not representable in Double, so don't handle them.\n    else -> (v - 9223372036854775808.0).toLong().toULong() + 9223372036854775808uL      // Long.MAX_VALUE + 1 < v < ULong.MAX_VALUE\n}\n\n\n@PublishedApi\ninternal fun uintToDouble(v: Int): Double = (v and Int.MAX_VALUE).toDouble() + (v ushr 31 shl 30).toDouble() * 2\n\n@PublishedApi\ninternal fun ulongToDouble(v: Long): Double = (v ushr 11).toDouble() * 2048 + (v and 2047)\n\n\ninternal fun ulongToString(v: Long): String = ulongToString(v, 10)\n\ninternal fun ulongToString(v: Long, base: Int): String {\n    if (v >= 0) return v.toString(base)\n\n    var quotient = ((v ushr 1) / base) shl 1\n    var rem = v - quotient * base\n    if (rem >= base) {\n        rem -= base\n        quotient += 1\n    }\n    return quotient.toString(base) + rem.toString(base)\n}\n\n","/*\n * Copyright 2010-2015 JetBrains s.r.o.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage kotlin.collections\n\nimport kotlin.internal.PlatformDependent\n\n/**\n * Classes that inherit from this interface can be represented as a sequence of elements that can\n * be iterated over.\n * @param T the type of element being iterated over. The iterator is covariant on its element type.\n */\npublic interface Iterable<out T> {\n    /**\n     * Returns an iterator over the elements of this object.\n     */\n    public operator fun iterator(): Iterator<T>\n}\n\n/**\n * Classes that inherit from this interface can be represented as a sequence of elements that can\n * be iterated over and that supports removing elements during iteration.\n * @param T the type of element being iterated over. The mutable iterator is invariant on its element type.\n */\npublic interface MutableIterable<out T> : Iterable<T> {\n    /**\n     * Returns an iterator over the elements of this sequence that supports removing elements during iteration.\n     */\n    override fun iterator(): MutableIterator<T>\n}\n\n/**\n * A generic collection of elements. Methods in this interface support only read-only access to the collection;\n * read/write access is supported through the [MutableCollection] interface.\n * @param E the type of elements contained in the collection. The collection is covariant on its element type.\n */\npublic interface Collection<out E> : Iterable<E> {\n    // Query Operations\n    /**\n     * Returns the size of the collection.\n     */\n    public val size: Int\n\n    /**\n     * Returns `true` if the collection is empty (contains no elements), `false` otherwise.\n     */\n    public fun isEmpty(): Boolean\n\n    /**\n     * Checks if the specified element is contained in this collection.\n     */\n    public operator fun contains(element: @UnsafeVariance E): Boolean\n\n    override fun iterator(): Iterator<E>\n\n    // Bulk Operations\n    /**\n     * Checks if all elements in the specified collection are contained in this collection.\n     */\n    public fun containsAll(elements: Collection<@UnsafeVariance E>): Boolean\n}\n\n/**\n * A generic collection of elements that supports adding and removing elements.\n *\n * @param E the type of elements contained in the collection. The mutable collection is invariant on its element type.\n */\npublic interface MutableCollection<E> : Collection<E>, MutableIterable<E> {\n    // Query Operations\n    override fun iterator(): MutableIterator<E>\n\n    // Modification Operations\n    /**\n     * Adds the specified element to the collection.\n     *\n     * @return `true` if the element has been added, `false` if the collection does not support duplicates\n     * and the element is already contained in the collection.\n     */\n    public fun add(element: E): Boolean\n\n    /**\n     * Removes a single instance of the specified element from this\n     * collection, if it is present.\n     *\n     * @return `true` if the element has been successfully removed; `false` if it was not present in the collection.\n     */\n    public fun remove(element: E): Boolean\n\n    // Bulk Modification Operations\n    /**\n     * Adds all of the elements of the specified collection to this collection.\n     *\n     * @return `true` if any of the specified elements was added to the collection, `false` if the collection was not modified.\n     */\n    public fun addAll(elements: Collection<E>): Boolean\n\n    /**\n     * Removes all of this collection's elements that are also contained in the specified collection.\n     *\n     * @return `true` if any of the specified elements was removed from the collection, `false` if the collection was not modified.\n     */\n    public fun removeAll(elements: Collection<E>): Boolean\n\n    /**\n     * Retains only the elements in this collection that are contained in the specified collection.\n     *\n     * @return `true` if any element was removed from the collection, `false` if the collection was not modified.\n     */\n    public fun retainAll(elements: Collection<E>): Boolean\n\n    /**\n     * Removes all elements from this collection.\n     */\n    public fun clear(): Unit\n}\n\n/**\n * A generic ordered collection of elements. Methods in this interface support only read-only access to the list;\n * read/write access is supported through the [MutableList] interface.\n * @param E the type of elements contained in the list. The list is covariant on its element type.\n */\npublic interface List<out E> : Collection<E> {\n    // Query Operations\n\n    override val size: Int\n    override fun isEmpty(): Boolean\n    override fun contains(element: @UnsafeVariance E): Boolean\n    override fun iterator(): Iterator<E>\n\n    // Bulk Operations\n    override fun containsAll(elements: Collection<@UnsafeVariance E>): Boolean\n\n    // Positional Access Operations\n    /**\n     * Returns the element at the specified index in the list.\n     */\n    public operator fun get(index: Int): E\n\n    // Search Operations\n    /**\n     * Returns the index of the first occurrence of the specified element in the list, or -1 if the specified\n     * element is not contained in the list.\n     */\n    public fun indexOf(element: @UnsafeVariance E): Int\n\n    /**\n     * Returns the index of the last occurrence of the specified element in the list, or -1 if the specified\n     * element is not contained in the list.\n     */\n    public fun lastIndexOf(element: @UnsafeVariance E): Int\n\n    // List Iterators\n    /**\n     * Returns a list iterator over the elements in this list (in proper sequence).\n     */\n    public fun listIterator(): ListIterator<E>\n\n    /**\n     * Returns a list iterator over the elements in this list (in proper sequence), starting at the specified [index].\n     */\n    public fun listIterator(index: Int): ListIterator<E>\n\n    // View\n    /**\n     * Returns a view of the portion of this list between the specified [fromIndex] (inclusive) and [toIndex] (exclusive).\n     * The returned list is backed by this list, so non-structural changes in the returned list are reflected in this list, and vice-versa.\n     *\n     * Structural changes in the base list make the behavior of the view undefined.\n     */\n    public fun subList(fromIndex: Int, toIndex: Int): List<E>\n}\n\n/**\n * A generic ordered collection of elements that supports adding and removing elements.\n * @param E the type of elements contained in the list. The mutable list is invariant on its element type.\n */\npublic interface MutableList<E> : List<E>, MutableCollection<E> {\n    // Modification Operations\n    /**\n     * Adds the specified element to the end of this list.\n     *\n     * @return `true` because the list is always modified as the result of this operation.\n     */\n    override fun add(element: E): Boolean\n\n    override fun remove(element: E): Boolean\n\n    // Bulk Modification Operations\n    /**\n     * Adds all of the elements of the specified collection to the end of this list.\n     *\n     * The elements are appended in the order they appear in the [elements] collection.\n     *\n     * @return `true` if the list was changed as the result of the operation.\n     */\n    override fun addAll(elements: Collection<E>): Boolean\n\n    /**\n     * Inserts all of the elements of the specified collection [elements] into this list at the specified [index].\n     *\n     * @return `true` if the list was changed as the result of the operation.\n     */\n    public fun addAll(index: Int, elements: Collection<E>): Boolean\n\n    override fun removeAll(elements: Collection<E>): Boolean\n    override fun retainAll(elements: Collection<E>): Boolean\n    override fun clear(): Unit\n\n    // Positional Access Operations\n    /**\n     * Replaces the element at the specified position in this list with the specified element.\n     *\n     * @return the element previously at the specified position.\n     */\n    public operator fun set(index: Int, element: E): E\n\n    /**\n     * Inserts an element into the list at the specified [index].\n     */\n    public fun add(index: Int, element: E): Unit\n\n    /**\n     * Removes an element at the specified [index] from the list.\n     *\n     * @return the element that has been removed.\n     */\n    public fun removeAt(index: Int): E\n\n    // List Iterators\n    override fun listIterator(): MutableListIterator<E>\n\n    override fun listIterator(index: Int): MutableListIterator<E>\n\n    // View\n    override fun subList(fromIndex: Int, toIndex: Int): MutableList<E>\n}\n\n/**\n * A generic unordered collection of elements that does not support duplicate elements.\n * Methods in this interface support only read-only access to the set;\n * read/write access is supported through the [MutableSet] interface.\n * @param E the type of elements contained in the set. The set is covariant on its element type.\n */\npublic interface Set<out E> : Collection<E> {\n    // Query Operations\n\n    override val size: Int\n    override fun isEmpty(): Boolean\n    override fun contains(element: @UnsafeVariance E): Boolean\n    override fun iterator(): Iterator<E>\n\n    // Bulk Operations\n    override fun containsAll(elements: Collection<@UnsafeVariance E>): Boolean\n}\n\n/**\n * A generic unordered collection of elements that does not support duplicate elements, and supports\n * adding and removing elements.\n * @param E the type of elements contained in the set. The mutable set is invariant on its element type.\n */\npublic interface MutableSet<E> : Set<E>, MutableCollection<E> {\n    // Query Operations\n    override fun iterator(): MutableIterator<E>\n\n    // Modification Operations\n\n    /**\n     * Adds the specified element to the set.\n     *\n     * @return `true` if the element has been added, `false` if the element is already contained in the set.\n     */\n    override fun add(element: E): Boolean\n\n    override fun remove(element: E): Boolean\n\n    // Bulk Modification Operations\n\n    override fun addAll(elements: Collection<E>): Boolean\n    override fun removeAll(elements: Collection<E>): Boolean\n    override fun retainAll(elements: Collection<E>): Boolean\n    override fun clear(): Unit\n}\n\n/**\n * A collection that holds pairs of objects (keys and values) and supports efficiently retrieving\n * the value corresponding to each key. Map keys are unique; the map holds only one value for each key.\n * Methods in this interface support only read-only access to the map; read-write access is supported through\n * the [MutableMap] interface.\n * @param K the type of map keys. The map is invariant on its key type, as it\n *          can accept key as a parameter (of [containsKey] for example) and return it in [keys] set.\n * @param V the type of map values. The map is covariant on its value type.\n */\npublic interface Map<K, out V> {\n    // Query Operations\n    /**\n     * Returns the number of key/value pairs in the map.\n     */\n    public val size: Int\n\n    /**\n     * Returns `true` if the map is empty (contains no elements), `false` otherwise.\n     */\n    public fun isEmpty(): Boolean\n\n    /**\n     * Returns `true` if the map contains the specified [key].\n     */\n    public fun containsKey(key: K): Boolean\n\n    /**\n     * Returns `true` if the map maps one or more keys to the specified [value].\n     */\n    public fun containsValue(value: @UnsafeVariance V): Boolean\n\n    /**\n     * Returns the value corresponding to the given [key], or `null` if such a key is not present in the map.\n     */\n    public operator fun get(key: K): V?\n\n    /**\n     * Returns the value corresponding to the given [key], or [defaultValue] if such a key is not present in the map.\n     *\n     * @since JDK 1.8\n     */\n    @SinceKotlin(\"1.1\")\n    @PlatformDependent\n    public fun getOrDefault(key: K, defaultValue: @UnsafeVariance V): V {\n        // See default implementation in JDK sources\n        return null as V\n    }\n\n    // Views\n    /**\n     * Returns a read-only [Set] of all keys in this map.\n     */\n    public val keys: Set<K>\n\n    /**\n     * Returns a read-only [Collection] of all values in this map. Note that this collection may contain duplicate values.\n     */\n    public val values: Collection<V>\n\n    /**\n     * Returns a read-only [Set] of all key/value pairs in this map.\n     */\n    public val entries: Set<Map.Entry<K, V>>\n\n    /**\n     * Represents a key/value pair held by a [Map].\n     */\n    public interface Entry<out K, out V> {\n        /**\n         * Returns the key of this key/value pair.\n         */\n        public val key: K\n\n        /**\n         * Returns the value of this key/value pair.\n         */\n        public val value: V\n    }\n}\n\n/**\n * A modifiable collection that holds pairs of objects (keys and values) and supports efficiently retrieving\n * the value corresponding to each key. Map keys are unique; the map holds only one value for each key.\n * @param K the type of map keys. The map is invariant on its key type.\n * @param V the type of map values. The mutable map is invariant on its value type.\n */\npublic interface MutableMap<K, V> : Map<K, V> {\n    // Modification Operations\n    /**\n     * Associates the specified [value] with the specified [key] in the map.\n     *\n     * @return the previous value associated with the key, or `null` if the key was not present in the map.\n     */\n    public fun put(key: K, value: V): V?\n\n    /**\n     * Removes the specified key and its corresponding value from this map.\n     *\n     * @return the previous value associated with the key, or `null` if the key was not present in the map.\n     */\n    public fun remove(key: K): V?\n\n    /**\n     * Removes the entry for the specified key only if it is mapped to the specified value.\n     *\n     * @return true if entry was removed\n     */\n    @SinceKotlin(\"1.1\")\n    @PlatformDependent\n    public fun remove(key: K, value: V): Boolean {\n        // See default implementation in JDK sources\n        return true\n    }\n\n    // Bulk Modification Operations\n    /**\n     * Updates this map with key/value pairs from the specified map [from].\n     */\n    public fun putAll(from: Map<out K, V>): Unit\n\n    /**\n     * Removes all elements from this map.\n     */\n    public fun clear(): Unit\n\n    // Views\n    /**\n     * Returns a [MutableSet] of all keys in this map.\n     */\n    override val keys: MutableSet<K>\n\n    /**\n     * Returns a [MutableCollection] of all values in this map. Note that this collection may contain duplicate values.\n     */\n    override val values: MutableCollection<V>\n\n    /**\n     * Returns a [MutableSet] of all key/value pairs in this map.\n     */\n    override val entries: MutableSet<MutableMap.MutableEntry<K, V>>\n\n    /**\n     * Represents a key/value pair held by a [MutableMap].\n     */\n    public interface MutableEntry<K, V> : Map.Entry<K, V> {\n        /**\n         * Changes the value associated with the key of this entry.\n         *\n         * @return the previous value corresponding to the key.\n         */\n        public fun setValue(newValue: V): V\n    }\n}\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.ranges\n\n/**\n * Represents a range of values (for example, numbers or characters).\n * See the [Kotlin language documentation](https://kotlinlang.org/docs/reference/ranges.html) for more information.\n */\npublic interface ClosedRange<T: Comparable<T>> {\n    /**\n     * The minimum value in the range.\n     */\n    public val start: T\n\n    /**\n     * The maximum value in the range (inclusive).\n     */\n    public val endInclusive: T\n\n    /**\n     * Checks whether the specified [value] belongs to the range.\n     */\n    public operator fun contains(value: T): Boolean = value >= start && value <= endInclusive\n\n    /**\n     * Checks whether the range is empty.\n     */\n    public fun isEmpty(): Boolean = start > endInclusive\n}\n","/*\n * Copyright 2010-2015 JetBrains s.r.o.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage kotlin\n\n/**\n * The type with only one value: the `Unit` object. This type corresponds to the `void` type in Java.\n */\npublic object Unit {\n    override fun toString() = \"kotlin.Unit\"\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.internal\n\n// a mod b (in arithmetical sense)\nprivate fun mod(a: Int, b: Int): Int {\n    val mod = a % b\n    return if (mod >= 0) mod else mod + b\n}\n\nprivate fun mod(a: Long, b: Long): Long {\n    val mod = a % b\n    return if (mod >= 0) mod else mod + b\n}\n\n// (a - b) mod c\nprivate fun differenceModulo(a: Int, b: Int, c: Int): Int {\n    return mod(mod(a, c) - mod(b, c), c)\n}\n\nprivate fun differenceModulo(a: Long, b: Long, c: Long): Long {\n    return mod(mod(a, c) - mod(b, c), c)\n}\n\n/**\n * Calculates the final element of a bounded arithmetic progression, i.e. the last element of the progression which is in the range\n * from [start] to [end] in case of a positive [step], or from [end] to [start] in case of a negative\n * [step].\n *\n * No validation on passed parameters is performed. The given parameters should satisfy the condition:\n *\n * - either `step > 0` and `start <= end`,\n * - or `step < 0` and `start >= end`.\n *\n * @param start first element of the progression\n * @param end ending bound for the progression\n * @param step increment, or difference of successive elements in the progression\n * @return the final element of the progression\n * @suppress\n */\n@PublishedApi\ninternal fun getProgressionLastElement(start: Int, end: Int, step: Int): Int = when {\n    step > 0 -> if (start >= end) end else end - differenceModulo(end, start, step)\n    step < 0 -> if (start <= end) end else end + differenceModulo(start, end, -step)\n    else -> throw kotlin.IllegalArgumentException(\"Step is zero.\")\n}\n\n/**\n * Calculates the final element of a bounded arithmetic progression, i.e. the last element of the progression which is in the range\n * from [start] to [end] in case of a positive [step], or from [end] to [start] in case of a negative\n * [step].\n *\n * No validation on passed parameters is performed. The given parameters should satisfy the condition:\n *\n * - either `step > 0` and `start <= end`,\n * - or `step < 0` and `start >= end`.\n *\n * @param start first element of the progression\n * @param end ending bound for the progression\n * @param step increment, or difference of successive elements in the progression\n * @return the final element of the progression\n * @suppress\n */\n@PublishedApi\ninternal fun getProgressionLastElement(start: Long, end: Long, step: Long): Long = when {\n    step > 0 -> if (start >= end) end else end - differenceModulo(end, start, step)\n    step < 0 -> if (start <= end) end else end + differenceModulo(start, end, -step)\n    else -> throw kotlin.IllegalArgumentException(\"Step is zero.\")\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@JsName(\"arrayIterator\")\ninternal fun arrayIterator(array: dynamic, type: String?) = when (type) {\n    null -> {\n        val arr: Array<dynamic> = array\n        object : Iterator<dynamic> {\n            var index = 0\n            override fun hasNext() = index < arr.size\n            override fun next() = if (index < arr.size) arr[index++] else throw NoSuchElementException(\"$index\")\n        }\n    }\n    \"BooleanArray\" -> booleanArrayIterator(array)\n    \"ByteArray\" -> byteArrayIterator(array)\n    \"ShortArray\" -> shortArrayIterator(array)\n    \"CharArray\" -> charArrayIterator(array)\n    \"IntArray\" -> intArrayIterator(array)\n    \"LongArray\" -> longArrayIterator(array)\n    \"FloatArray\" -> floatArrayIterator(array)\n    \"DoubleArray\" -> doubleArrayIterator(array)\n    else -> throw IllegalStateException(\"Unsupported type argument for arrayIterator: $type\")\n}\n\n@JsName(\"booleanArrayIterator\")\ninternal fun booleanArrayIterator(array: BooleanArray) = object : BooleanIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextBoolean() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"byteArrayIterator\")\ninternal fun byteArrayIterator(array: ByteArray) = object : ByteIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextByte() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"shortArrayIterator\")\ninternal fun shortArrayIterator(array: ShortArray) = object : ShortIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextShort() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"charArrayIterator\")\ninternal fun charArrayIterator(array: CharArray) = object : CharIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextChar() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"intArrayIterator\")\ninternal fun intArrayIterator(array: IntArray) = object : IntIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextInt() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"floatArrayIterator\")\ninternal fun floatArrayIterator(array: FloatArray) = object : FloatIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextFloat() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"doubleArrayIterator\")\ninternal fun doubleArrayIterator(array: DoubleArray) = object : DoubleIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextDouble() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"longArrayIterator\")\ninternal fun longArrayIterator(array: LongArray) = object : LongIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextLong() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"PropertyMetadata\")\ninternal class PropertyMetadata(@JsName(\"callableName\") val name: String)\n\n@JsName(\"noWhenBranchMatched\")\ninternal fun noWhenBranchMatched(): Nothing = throw NoWhenBranchMatchedException()\n\n@JsName(\"subSequence\")\ninternal fun subSequence(c: CharSequence, startIndex: Int, endIndex: Int): CharSequence {\n    if (c is String) {\n        return c.substring(startIndex, endIndex)\n    } else {\n        return c.asDynamic().`subSequence_vux9f0$`(startIndex, endIndex)\n    }\n}\n\n@JsName(\"captureStack\")\ninternal fun captureStack(baseClass: JsClass<in Throwable>, instance: Throwable) {\n    if (js(\"Error\").captureStackTrace) {\n        js(\"Error\").captureStackTrace(instance, instance::class.js);\n    } else {\n        instance.asDynamic().stack = js(\"new Error()\").stack;\n    }\n}\n\n@JsName(\"newThrowable\")\ninternal fun newThrowable(message: String?, cause: Throwable?): Throwable {\n    val throwable = js(\"new Error()\")\n    throwable.message = if (jsTypeOf(message) == \"undefined\") {\n        if (cause != null) cause.toString() else null\n    } else {\n        message\n    }\n    throwable.cause = cause\n    throwable.name = \"Throwable\"\n    return throwable\n}\n\n@JsName(\"BoxedChar\")\ninternal class BoxedChar(val c: Int) : Comparable<Int> {\n    override fun equals(other: Any?): Boolean {\n        return other is BoxedChar && c == other.c\n    }\n\n    override fun hashCode(): Int {\n        return c\n    }\n\n    override fun toString(): String {\n        return js(\"this.c\").unsafeCast<Char>().toString()\n    }\n\n    override fun compareTo(other: Int): Int {\n        return js(\"this.c - other\").unsafeCast<Int>()\n    }\n\n    @JsName(\"valueOf\")\n    public fun valueOf(): Int {\n        return c\n    }\n}\n\n@kotlin.internal.InlineOnly\ninternal inline fun <T> concat(args: Array<T>): T {\n    val typed = js(\"Array\")(args.size)\n    for (i in args.indices) {\n        val arr = args[i]\n        if (arr !is Array<*>) {\n            typed[i] = js(\"[]\").slice.call(arr)\n        } else {\n            typed[i] = arr\n        }\n    }\n    return js(\"[]\").concat.apply(js(\"[]\"), typed);\n}\n\n/** Concat regular Array's and TypedArray's into an Array.\n */\n@PublishedApi\n@JsName(\"arrayConcat\")\n@Suppress(\"UNUSED_PARAMETER\")\ninternal fun <T> arrayConcat(a: T, b: T): T {\n    return concat(js(\"arguments\"))\n}\n\n/** Concat primitive arrays. Main use: prepare vararg arguments.\n *  For compatibility with 1.1.0 the arguments may be a mixture of Array's and TypedArray's.\n *\n *  If the first argument is TypedArray (Byte-, Short-, Char-, Int-, Float-, and DoubleArray) returns a TypedArray, otherwise an Array.\n *  If the first argument has the $type$ property (Boolean-, Char-, and LongArray) copy its value to result.$type$.\n *  If the first argument is a regular Array without the $type$ property default to arrayConcat.\n */\n@PublishedApi\n@JsName(\"primitiveArrayConcat\")\n@Suppress(\"UNUSED_PARAMETER\")\ninternal fun <T> primitiveArrayConcat(a: T, b: T): T {\n    val args: Array<T> = js(\"arguments\")\n    if (a is Array<*> && a.asDynamic().`$type$` === undefined) {\n        return concat(args)\n    } else {\n        var size = 0\n        for (i in args.indices) {\n            size += args[i].asDynamic().length as Int\n        }\n        val result = js(\"new a.constructor(size)\")\n        kotlin.copyArrayType(a, result)\n        size = 0\n        for (i in args.indices) {\n            val arr = args[i].asDynamic()\n            for (j in 0 until arr.length) {\n                result[size++] = arr[j]\n            }\n        }\n        return result\n    }\n}\n\n@JsName(\"booleanArrayOf\")\ninternal fun booleanArrayOf() = withType(\"BooleanArray\", js(\"[].slice.call(arguments)\"))\n\n@JsName(\"charArrayOf\") // The arguments have to be slice'd here because of Rhino (see KT-16974)\ninternal fun charArrayOf() = withType(\"CharArray\", js(\"new Uint16Array([].slice.call(arguments))\"))\n\n@JsName(\"longArrayOf\")\ninternal fun longArrayOf() = withType(\"LongArray\", js(\"[].slice.call(arguments)\"))\n\n@JsName(\"withType\")\n@kotlin.internal.InlineOnly\ninternal inline fun withType(type: String, array: dynamic): dynamic {\n    array.`$type$` = type\n    return array\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.coroutines.intrinsics.COROUTINE_SUSPENDED\n\n@SinceKotlin(\"1.3\")\n@JsName(\"CoroutineImpl\")\ninternal abstract class CoroutineImpl(private val resultContinuation: Continuation<Any?>) : Continuation<Any?> {\n    protected var state = 0\n    protected var exceptionState = 0\n    protected var result: Any? = null\n    protected var exception: Throwable? = null\n    protected var finallyPath: Array<Int>? = null\n\n    public override val context: CoroutineContext = resultContinuation.context\n\n    private var intercepted_: Continuation<Any?>? = null\n\n    public fun intercepted(): Continuation<Any?> =\n        intercepted_\n            ?: (context[ContinuationInterceptor]?.interceptContinuation(this) ?: this)\n                .also { intercepted_ = it }\n\n    override fun resumeWith(result: Result<Any?>) {\n        var current = this\n        var currentResult: Any? = result.getOrNull()\n        var currentException: Throwable? = result.exceptionOrNull()\n\n        // This loop unrolls recursion in current.resumeWith(param) to make saner and shorter stack traces on resume\n        while (true) {\n            with(current) {\n                val completion = resultContinuation\n\n                // Set result and exception fields in the current continuation\n                if (currentException == null) {\n                    this.result = currentResult\n                } else {\n                    state = exceptionState\n                    exception = currentException\n                }\n\n                try {\n                    val outcome = doResume()\n                    if (outcome === COROUTINE_SUSPENDED) return\n                    currentResult = outcome\n                    currentException = null\n                } catch (exception: dynamic) { // Catch all exceptions\n                    currentResult = null\n                    currentException = exception.unsafeCast<Throwable>()\n                }\n\n                releaseIntercepted() // this state machine instance is terminating\n\n                if (completion is CoroutineImpl) {\n                    // unrolling recursion via loop\n                    current = completion\n                } else {\n                    // top-level completion reached -- invoke and return\n                    currentException?.let {\n                        completion.resumeWithException(it)\n                    } ?: completion.resume(currentResult)\n                    return\n                }\n            }\n        }\n    }\n\n    private fun releaseIntercepted() {\n        val intercepted = intercepted_\n        if (intercepted != null && intercepted !== this) {\n            context[ContinuationInterceptor]!!.releaseInterceptedContinuation(intercepted)\n        }\n        this.intercepted_ = CompletedContinuation // just in case\n    }\n\n    protected abstract fun doResume(): Any?\n}\n\ninternal object CompletedContinuation : Continuation<Any?> {\n    override val context: CoroutineContext\n        get() = error(\"This continuation is already complete\")\n\n    override fun resumeWith(result: Result<Any?>) {\n        error(\"This continuation is already complete\")\n    }\n\n    override fun toString(): String = \"This continuation is already complete\"\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:Suppress(\"UNCHECKED_CAST\", \"RedundantVisibilityModifier\")\n\npackage kotlin\n\nimport kotlin.contracts.*\nimport kotlin.internal.InlineOnly\nimport kotlin.jvm.JvmField\n\n/**\n * A discriminated union that encapsulates a successful outcome with a value of type [T]\n * or a failure with an arbitrary [Throwable] exception.\n */\n@Suppress(\"NON_PUBLIC_PRIMARY_CONSTRUCTOR_OF_INLINE_CLASS\")\n@SinceKotlin(\"1.3\")\npublic inline class Result<out T> @PublishedApi internal constructor(\n    @PublishedApi\n    internal val value: Any?\n) : Serializable {\n    // discovery\n\n    /**\n     * Returns `true` if this instance represents a successful outcome.\n     * In this case [isFailure] returns `false`.\n     */\n    public val isSuccess: Boolean get() = value !is Failure\n\n    /**\n     * Returns `true` if this instance represents a failed outcome.\n     * In this case [isSuccess] returns `false`.\n     */\n    public val isFailure: Boolean get() = value is Failure\n\n    // value & exception retrieval\n\n    /**\n     * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or `null`\n     * if it is [failure][Result.isFailure].\n     *\n     * This function is a shorthand for `getOrElse { null }` (see [getOrElse]) or\n     * `fold(onSuccess = { it }, onFailure = { null })` (see [fold]).\n     */\n    @InlineOnly\n    public inline fun getOrNull(): T? =\n        when {\n            isFailure -> null\n            else -> value as T\n        }\n\n    /**\n     * Returns the encapsulated [Throwable] exception if this instance represents [failure][isFailure] or `null`\n     * if it is [success][isSuccess].\n     *\n     * This function is a shorthand for `fold(onSuccess = { null }, onFailure = { it })` (see [fold]).\n     */\n    public fun exceptionOrNull(): Throwable? =\n        when (value) {\n            is Failure -> value.exception\n            else -> null\n        }\n\n    /**\n     * Returns a string `Success(v)` if this instance represents [success][Result.isSuccess]\n     * where `v` is a string representation of the value or a string `Failure(x)` if\n     * it is [failure][isFailure] where `x` is a string representation of the exception.\n     */\n    public override fun toString(): String =\n        when (value) {\n            is Failure -> value.toString() // \"Failure($exception)\"\n            else -> \"Success($value)\"\n        }\n\n    // companion with constructors\n\n    /**\n     * Companion object for [Result] class that contains its constructor functions\n     * [success] and [failure].\n     */\n    public companion object {\n        /**\n         * Returns an instance that encapsulates the given [value] as successful value.\n         */\n        @InlineOnly\n        public inline fun <T> success(value: T): Result<T> =\n            Result(value)\n\n        /**\n         * Returns an instance that encapsulates the given [Throwable] [exception] as failure.\n         */\n        @InlineOnly\n        public inline fun <T> failure(exception: Throwable): Result<T> =\n            Result(createFailure(exception))\n    }\n\n    internal class Failure(\n        @JvmField\n        val exception: Throwable\n    ) : Serializable {\n        override fun equals(other: Any?): Boolean = other is Failure && exception == other.exception\n        override fun hashCode(): Int = exception.hashCode()\n        override fun toString(): String = \"Failure($exception)\"\n    }\n}\n\n/**\n * Creates an instance of internal marker [Result.Failure] class to\n * make sure that this class is not exposed in ABI.\n */\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun createFailure(exception: Throwable): Any =\n    Result.Failure(exception)\n\n/**\n * Throws exception if the result is failure. This internal function minimizes\n * inlined bytecode for [getOrThrow] and makes sure that in the future we can\n * add some exception-augmenting logic here (if needed).\n */\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun Result<*>.throwOnFailure() {\n    if (value is Result.Failure) throw value.exception\n}\n\n/**\n * Calls the specified function [block] and returns its encapsulated result if invocation was successful,\n * catching any [Throwable] exception that was thrown from the [block] function execution and encapsulating it as a failure.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R> runCatching(block: () -> R): Result<R> {\n    return try {\n        Result.success(block())\n    } catch (e: Throwable) {\n        Result.failure(e)\n    }\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its encapsulated result if invocation was successful,\n * catching any [Throwable] exception that was thrown from the [block] function execution and encapsulating it as a failure.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T, R> T.runCatching(block: T.() -> R): Result<R> {\n    return try {\n        Result.success(block())\n    } catch (e: Throwable) {\n        Result.failure(e)\n    }\n}\n\n// -- extensions ---\n\n/**\n * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or throws the encapsulated [Throwable] exception\n * if it is [failure][Result.isFailure].\n *\n * This function is a shorthand for `getOrElse { throw it }` (see [getOrElse]).\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T> Result<T>.getOrThrow(): T {\n    throwOnFailure()\n    return value as T\n}\n\n/**\n * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or the\n * result of [onFailure] function for the encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [onFailure] function.\n *\n * This function is a shorthand for `fold(onSuccess = { it }, onFailure = onFailure)` (see [fold]).\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.getOrElse(onFailure: (exception: Throwable) -> R): R {\n    contract {\n        callsInPlace(onFailure, InvocationKind.AT_MOST_ONCE)\n    }\n    return when (val exception = exceptionOrNull()) {\n        null -> value as T\n        else -> onFailure(exception)\n    }\n}\n\n/**\n * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or the\n * [defaultValue] if it is [failure][Result.isFailure].\n *\n * This function is a shorthand for `getOrElse { defaultValue }` (see [getOrElse]).\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.getOrDefault(defaultValue: R): R {\n    if (isFailure) return defaultValue\n    return value as T\n}\n\n/**\n * Returns the result of [onSuccess] for the encapsulated value if this instance represents [success][Result.isSuccess]\n * or the result of [onFailure] function for the encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [onSuccess] or by [onFailure] function.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T> Result<T>.fold(\n    onSuccess: (value: T) -> R,\n    onFailure: (exception: Throwable) -> R\n): R {\n    contract {\n        callsInPlace(onSuccess, InvocationKind.AT_MOST_ONCE)\n        callsInPlace(onFailure, InvocationKind.AT_MOST_ONCE)\n    }\n    return when (val exception = exceptionOrNull()) {\n        null -> onSuccess(value as T)\n        else -> onFailure(exception)\n    }\n}\n\n// transformation\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated value\n * if this instance represents [success][Result.isSuccess] or the\n * original encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [transform] function.\n * See [mapCatching] for an alternative that encapsulates exceptions.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T> Result<T>.map(transform: (value: T) -> R): Result<R> {\n    contract {\n        callsInPlace(transform, InvocationKind.AT_MOST_ONCE)\n    }\n    return when {\n        isSuccess -> Result.success(transform(value as T))\n        else -> Result(value)\n    }\n}\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated value\n * if this instance represents [success][Result.isSuccess] or the\n * original encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * This function catches any [Throwable] exception thrown by [transform] function and encapsulates it as a failure.\n * See [map] for an alternative that rethrows exceptions from `transform` function.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T> Result<T>.mapCatching(transform: (value: T) -> R): Result<R> {\n    return when {\n        isSuccess -> runCatching { transform(value as T) }\n        else -> Result(value)\n    }\n}\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated [Throwable] exception\n * if this instance represents [failure][Result.isFailure] or the\n * original encapsulated value if it is [success][Result.isSuccess].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [transform] function.\n * See [recoverCatching] for an alternative that encapsulates exceptions.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.recover(transform: (exception: Throwable) -> R): Result<R> {\n    contract {\n        callsInPlace(transform, InvocationKind.AT_MOST_ONCE)\n    }\n    return when (val exception = exceptionOrNull()) {\n        null -> this\n        else -> Result.success(transform(exception))\n    }\n}\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated [Throwable] exception\n * if this instance represents [failure][Result.isFailure] or the\n * original encapsulated value if it is [success][Result.isSuccess].\n *\n * This function catches any [Throwable] exception thrown by [transform] function and encapsulates it as a failure.\n * See [recover] for an alternative that rethrows exceptions.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.recoverCatching(transform: (exception: Throwable) -> R): Result<R> {\n    val value = value // workaround for inline classes BE bug\n    return when (val exception = exceptionOrNull()) {\n        null -> this\n        else -> runCatching { transform(exception) }\n    }\n}\n\n// \"peek\" onto value/exception and pipe\n\n/**\n * Performs the given [action] on the encapsulated [Throwable] exception if this instance represents [failure][Result.isFailure].\n * Returns the original `Result` unchanged.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T> Result<T>.onFailure(action: (exception: Throwable) -> Unit): Result<T> {\n    contract {\n        callsInPlace(action, InvocationKind.AT_MOST_ONCE)\n    }\n    exceptionOrNull()?.let { action(it) }\n    return this\n}\n\n/**\n * Performs the given [action] on the encapsulated value if this instance represents [success][Result.isSuccess].\n * Returns the original `Result` unchanged.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T> Result<T>.onSuccess(action: (value: T) -> Unit): Result<T> {\n    contract {\n        callsInPlace(action, InvocationKind.AT_MOST_ONCE)\n    }\n    if (isSuccess) action(value as T)\n    return this\n}\n\n// -------------------\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.coroutines.intrinsics.*\nimport kotlin.internal.InlineOnly\n\n/**\n * Interface representing a continuation after a suspension point that returns a value of type `T`.\n */\n@SinceKotlin(\"1.3\")\npublic interface Continuation<in T> {\n    /**\n     * The context of the coroutine that corresponds to this continuation.\n     */\n    public val context: CoroutineContext\n\n    /**\n     * Resumes the execution of the corresponding coroutine passing a successful or failed [result] as the\n     * return value of the last suspension point.\n     */\n    public fun resumeWith(result: Result<T>)\n}\n\n/**\n * Classes and interfaces marked with this annotation are restricted when used as receivers for extension\n * `suspend` functions. These `suspend` extensions can only invoke other member or extension `suspend` functions on this particular\n * receiver and are restricted from calling arbitrary suspension functions.\n */\n@SinceKotlin(\"1.3\")\n@Target(AnnotationTarget.CLASS)\n@Retention(AnnotationRetention.BINARY)\npublic annotation class RestrictsSuspension\n\n/**\n * Resumes the execution of the corresponding coroutine passing [value] as the return value of the last suspension point.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun <T> Continuation<T>.resume(value: T): Unit =\n    resumeWith(Result.success(value))\n\n/**\n * Resumes the execution of the corresponding coroutine so that the [exception] is re-thrown right after the\n * last suspension point.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun <T> Continuation<T>.resumeWithException(exception: Throwable): Unit =\n    resumeWith(Result.failure(exception))\n\n\n/**\n * Creates a [Continuation] instance with the given [context] and implementation of [resumeWith] method.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun <T> Continuation(\n    context: CoroutineContext,\n    crossinline resumeWith: (Result<T>) -> Unit\n): Continuation<T> =\n    object : Continuation<T> {\n        override val context: CoroutineContext\n            get() = context\n\n        override fun resumeWith(result: Result<T>) =\n            resumeWith(result)\n    }\n\n/**\n * Creates a coroutine without a receiver and with result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n * Subsequent invocation of any resume function on the resulting continuation will produce an [IllegalStateException].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <T> (suspend () -> T).createCoroutine(\n    completion: Continuation<T>\n): Continuation<Unit> =\n    SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED)\n\n/**\n * Creates a coroutine with receiver type [R] and result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n * Subsequent invocation of any resume function on the resulting continuation will produce an [IllegalStateException].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <R, T> (suspend R.() -> T).createCoroutine(\n    receiver: R,\n    completion: Continuation<T>\n): Continuation<Unit> =\n    SafeContinuation(createCoroutineUnintercepted(receiver, completion).intercepted(), COROUTINE_SUSPENDED)\n\n/**\n * Starts a coroutine without a receiver and with result type [T].\n * This function creates and starts a new, fresh instance of suspendable computation every time it is invoked.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <T> (suspend () -> T).startCoroutine(\n    completion: Continuation<T>\n) {\n    createCoroutineUnintercepted(completion).intercepted().resume(Unit)\n}\n\n/**\n * Starts a coroutine with receiver type [R] and result type [T].\n * This function creates and starts a new, fresh instance of suspendable computation every time it is invoked.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <R, T> (suspend R.() -> T).startCoroutine(\n    receiver: R,\n    completion: Continuation<T>\n) {\n    createCoroutineUnintercepted(receiver, completion).intercepted().resume(Unit)\n}\n\n/**\n * Obtains the current continuation instance inside suspend functions and suspends\n * the currently running coroutine.\n *\n * In this function both [Continuation.resume] and [Continuation.resumeWithException] can be used either synchronously in\n * the same stack-frame where the suspension function is run or asynchronously later in the same thread or\n * from a different thread of execution. Subsequent invocation of any resume function will produce an [IllegalStateException].\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic suspend inline fun <T> suspendCoroutine(crossinline block: (Continuation<T>) -> Unit): T =\n    suspendCoroutineUninterceptedOrReturn { c: Continuation<T> ->\n        val safe = SafeContinuation(c.intercepted())\n        block(safe)\n        safe.getOrThrow()\n    }\n\n/**\n * Returns the context of the current coroutine.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"WRONG_MODIFIER_TARGET\")\n@InlineOnly\npublic suspend inline val coroutineContext: CoroutineContext\n    get() {\n        throw NotImplementedError(\"Implemented as intrinsic\")\n    }\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"PreconditionsKt\")\n\npackage kotlin\n\nimport kotlin.contracts.contract\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    require(value) { \"Failed requirement.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is null. Otherwise returns the not null value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return requireNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    } else {\n        return value\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    check(value) { \"Check failed.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return checkNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage]  if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    } else {\n        return value\n    }\n}\n\n\n/**\n * Throws an [IllegalStateException] with the given [message].\n *\n * @sample samples.misc.Preconditions.failWithError\n */\n@kotlin.internal.InlineOnly\npublic inline fun error(message: Any): Nothing = throw IllegalStateException(message.toString())\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines.intrinsics\n\nimport kotlin.coroutines.*\nimport kotlin.internal.InlineOnly\n\n/**\n * Starts an unintercepted coroutine without a receiver and with result type [T] and executes it until its first suspension.\n * Returns the result of the coroutine or throws its exception if it does not suspend or [COROUTINE_SUSPENDED] if it suspends.\n * In the latter case, the [completion] continuation is invoked when the coroutine completes with a result or an exception.\n *\n * The coroutine is started directly in the invoker's thread without going through the [ContinuationInterceptor] that might\n * be present in the completion's [CoroutineContext]. It is the invoker's responsibility to ensure that a proper invocation\n * context is established.\n *\n * This function is designed to be used from inside of [suspendCoroutineUninterceptedOrReturn] to resume the execution of the suspended\n * coroutine using a reference to the suspending function.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic actual inline fun <T> (suspend () -> T).startCoroutineUninterceptedOrReturn(\n    completion: Continuation<T>\n): Any? = this.asDynamic()(completion, false)\n\n/**\n * Starts an unintercepted coroutine with receiver type [R] and result type [T] and executes it until its first suspension.\n * Returns the result of the coroutine or throws its exception if it does not suspend or [COROUTINE_SUSPENDED] if it suspends.\n * In the latter case, the [completion] continuation is invoked when the coroutine completes with a result or an exception.\n *\n * The coroutine is started directly in the invoker's thread without going through the [ContinuationInterceptor] that might\n * be present in the completion's [CoroutineContext]. It is the invoker's responsibility to ensure that a proper invocation\n * context is established.\n *\n * This function is designed to be used from inside of [suspendCoroutineUninterceptedOrReturn] to resume the execution of the suspended\n * coroutine using a reference to the suspending function.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic actual inline fun <R, T> (suspend R.() -> T).startCoroutineUninterceptedOrReturn(\n    receiver: R,\n    completion: Continuation<T>\n): Any? = this.asDynamic()(receiver, completion, false)\n\n\n/**\n * Creates unintercepted coroutine without receiver and with result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when coroutine completes with result or exception.\n *\n * This function returns unintercepted continuation.\n * Invocation of `resume(Unit)` starts coroutine immediately in the invoker's call stack without going through the\n * [ContinuationInterceptor] that might be present in the completion's [CoroutineContext].\n * It is the invoker's responsibility to ensure that a proper invocation context is established.\n * Note that [completion] of this function may get invoked in an arbitrary context.\n *\n * [Continuation.intercepted] can be used to acquire the intercepted continuation.\n * Invocation of `resume(Unit)` on intercepted continuation guarantees that execution of\n * both the coroutine and [completion] happens in the invocation context established by\n * [ContinuationInterceptor].\n *\n * Repeated invocation of any resume function on the resulting continuation corrupts the\n * state machine of the coroutine and may result in arbitrary behaviour or exception.\n */\n@SinceKotlin(\"1.3\")\npublic actual fun <T> (suspend () -> T).createCoroutineUnintercepted(\n    completion: Continuation<T>\n): Continuation<Unit> =\n    // Kotlin/JS suspend lambdas have an extra parameter `suspended`\n    if (this.asDynamic().length == 2) {\n        // When `suspended` is true the continuation is created, but not executed\n        this.asDynamic()(completion, true)\n    } else {\n        createCoroutineFromSuspendFunction(completion) {\n            this.asDynamic()(completion)\n        }\n    }\n\n/**\n * Creates unintercepted coroutine with receiver type [R] and result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when coroutine completes with result or exception.\n *\n * This function returns unintercepted continuation.\n * Invocation of `resume(Unit)` starts coroutine immediately in the invoker's call stack without going through the\n * [ContinuationInterceptor] that might be present in the completion's [CoroutineContext].\n * It is the invoker's responsibility to ensure that a proper invocation context is established.\n * Note that [completion] of this function may get invoked in an arbitrary context.\n *\n * [Continuation.intercepted] can be used to acquire the intercepted continuation.\n * Invocation of `resume(Unit)` on intercepted continuation guarantees that execution of\n * both the coroutine and [completion] happens in the invocation context established by\n * [ContinuationInterceptor].\n *\n * Repeated invocation of any resume function on the resulting continuation corrupts the\n * state machine of the coroutine and may result in arbitrary behaviour or exception.\n */\n@SinceKotlin(\"1.3\")\npublic actual fun <R, T> (suspend R.() -> T).createCoroutineUnintercepted(\n    receiver: R,\n    completion: Continuation<T>\n): Continuation<Unit> =\n    // Kotlin/JS suspend lambdas have an extra parameter `suspended`\n    if (this.asDynamic().length == 3) {\n        // When `suspended` is true the continuation is created, but not executed\n        this.asDynamic()(receiver, completion, true)\n    } else {\n        createCoroutineFromSuspendFunction(completion) {\n            this.asDynamic()(receiver, completion)\n        }\n    }\n\n/**\n * Intercepts this continuation with [ContinuationInterceptor].\n *\n * This function shall be used on the immediate result of [createCoroutineUnintercepted] or [suspendCoroutineUninterceptedOrReturn],\n * in which case it checks for [ContinuationInterceptor] in the continuation's [context][Continuation.context],\n * invokes [ContinuationInterceptor.interceptContinuation], caches and returns the result.\n *\n * If this function is invoked on other [Continuation] instances it returns `this` continuation unchanged.\n */\n@SinceKotlin(\"1.3\")\npublic actual fun <T> Continuation<T>.intercepted(): Continuation<T> =\n    (this as? CoroutineImpl)?.intercepted() ?: this\n\n\nprivate inline fun <T> createCoroutineFromSuspendFunction(\n    completion: Continuation<T>,\n    crossinline block: () -> Any?\n): Continuation<Unit> {\n    @Suppress(\"UNCHECKED_CAST\")\n    return object : CoroutineImpl(completion as Continuation<Any?>) {\n        override fun doResume(): Any? {\n            exception?.let { throw it }\n            return block()\n        }\n    }\n}\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.js.*\nimport primitiveArrayConcat\nimport withType\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun <T> Array<out T>.elementAt(index: Int): T {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun ByteArray.elementAt(index: Int): Byte {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun ShortArray.elementAt(index: Int): Short {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun IntArray.elementAt(index: Int): Int {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun LongArray.elementAt(index: Int): Long {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun FloatArray.elementAt(index: Int): Float {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun DoubleArray.elementAt(index: Int): Double {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun BooleanArray.elementAt(index: Int): Boolean {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun CharArray.elementAt(index: Int): Char {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic actual fun <T> Array<out T>.asList(): List<T> {\n    return ArrayList<T>(this.unsafeCast<Array<Any?>>())\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun ByteArray.asList(): List<Byte> {\n    return this.unsafeCast<Array<Byte>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun ShortArray.asList(): List<Short> {\n    return this.unsafeCast<Array<Short>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun IntArray.asList(): List<Int> {\n    return this.unsafeCast<Array<Int>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun LongArray.asList(): List<Long> {\n    return this.unsafeCast<Array<Long>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun FloatArray.asList(): List<Float> {\n    return this.unsafeCast<Array<Float>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun DoubleArray.asList(): List<Double> {\n    return this.unsafeCast<Array<Double>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun BooleanArray.asList(): List<Boolean> {\n    return this.unsafeCast<Array<Boolean>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic actual fun CharArray.asList(): List<Char> {\n    return object : AbstractList<Char>(), RandomAccess {\n        override val size: Int get() = this@asList.size\n        override fun isEmpty(): Boolean = this@asList.isEmpty()\n        override fun contains(element: Char): Boolean = this@asList.contains(element)\n        override fun get(index: Int): Char {\n            AbstractList.checkElementIndex(index, size)\n            return this@asList[index]\n        }\n        override fun indexOf(element: Char): Int {\n            if ((element as Any?) !is Char) return -1\n            return this@asList.indexOf(element)\n        }\n        override fun lastIndexOf(element: Char): Int {\n            if ((element as Any?) !is Char) return -1\n            return this@asList.lastIndexOf(element)\n        }\n    }\n}\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayDeepEquals\")\npublic actual infix fun <T> Array<out T>.contentDeepEquals(other: Array<out T>): Boolean {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayDeepHashCode\")\npublic actual fun <T> Array<out T>.contentDeepHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayDeepToString\")\npublic actual fun <T> Array<out T>.contentDeepToString(): String {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayEquals\")\npublic actual infix fun <T> Array<out T>.contentEquals(other: Array<out T>): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayEquals\")\npublic actual infix fun ByteArray.contentEquals(other: ByteArray): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayEquals\")\npublic actual infix fun ShortArray.contentEquals(other: ShortArray): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayEquals\")\npublic actual infix fun IntArray.contentEquals(other: IntArray): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayEquals\")\npublic actual infix fun LongArray.contentEquals(other: LongArray): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayEquals\")\npublic actual infix fun FloatArray.contentEquals(other: FloatArray): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayEquals\")\npublic actual infix fun DoubleArray.contentEquals(other: DoubleArray): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayEquals\")\npublic actual infix fun BooleanArray.contentEquals(other: BooleanArray): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayEquals\")\npublic actual infix fun CharArray.contentEquals(other: CharArray): Boolean {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayHashCode\")\npublic actual fun <T> Array<out T>.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayHashCode\")\npublic actual fun ByteArray.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayHashCode\")\npublic actual fun ShortArray.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayHashCode\")\npublic actual fun IntArray.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayHashCode\")\npublic actual fun LongArray.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayHashCode\")\npublic actual fun FloatArray.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayHashCode\")\npublic actual fun DoubleArray.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayHashCode\")\npublic actual fun BooleanArray.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayHashCode\")\npublic actual fun CharArray.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayToString\")\npublic actual fun <T> Array<out T>.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayToString\")\npublic actual fun ByteArray.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayToString\")\npublic actual fun ShortArray.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayToString\")\npublic actual fun IntArray.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayToString\")\npublic actual fun LongArray.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayToString\")\npublic actual fun FloatArray.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayToString\")\npublic actual fun DoubleArray.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayToString\")\npublic actual fun BooleanArray.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayToString\")\npublic actual fun CharArray.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun <T> Array<out T>.copyInto(destination: Array<T>, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): Array<T> {\n    arrayCopy(this, destination, destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun ByteArray.copyInto(destination: ByteArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ByteArray {\n    arrayCopy(this.unsafeCast<Array<Byte>>(), destination.unsafeCast<Array<Byte>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun ShortArray.copyInto(destination: ShortArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ShortArray {\n    arrayCopy(this.unsafeCast<Array<Short>>(), destination.unsafeCast<Array<Short>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun IntArray.copyInto(destination: IntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): IntArray {\n    arrayCopy(this.unsafeCast<Array<Int>>(), destination.unsafeCast<Array<Int>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun LongArray.copyInto(destination: LongArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): LongArray {\n    arrayCopy(this.unsafeCast<Array<Long>>(), destination.unsafeCast<Array<Long>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun FloatArray.copyInto(destination: FloatArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): FloatArray {\n    arrayCopy(this.unsafeCast<Array<Float>>(), destination.unsafeCast<Array<Float>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun DoubleArray.copyInto(destination: DoubleArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): DoubleArray {\n    arrayCopy(this.unsafeCast<Array<Double>>(), destination.unsafeCast<Array<Double>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun BooleanArray.copyInto(destination: BooleanArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): BooleanArray {\n    arrayCopy(this.unsafeCast<Array<Boolean>>(), destination.unsafeCast<Array<Boolean>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun CharArray.copyInto(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): CharArray {\n    arrayCopy(this.unsafeCast<Array<Char>>(), destination.unsafeCast<Array<Char>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline fun <T> Array<out T>.copyOf(): Array<T> {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun ByteArray.copyOf(): ByteArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun ShortArray.copyOf(): ShortArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun IntArray.copyOf(): IntArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic actual fun LongArray.copyOf(): LongArray {\n    return withType(\"LongArray\", this.asDynamic().slice())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun FloatArray.copyOf(): FloatArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun DoubleArray.copyOf(): DoubleArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic actual fun BooleanArray.copyOf(): BooleanArray {\n    return withType(\"BooleanArray\", this.asDynamic().slice())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic actual fun CharArray.copyOf(): CharArray {\n    return withType(\"CharArray\", this.asDynamic().slice())\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun ByteArray.copyOf(newSize: Int): ByteArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, ByteArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun ShortArray.copyOf(newSize: Int): ShortArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, ShortArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun IntArray.copyOf(newSize: Int): IntArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, IntArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun LongArray.copyOf(newSize: Int): LongArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return withType(\"LongArray\", arrayCopyResize(this, newSize, 0L))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun FloatArray.copyOf(newSize: Int): FloatArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, FloatArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun DoubleArray.copyOf(newSize: Int): DoubleArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, DoubleArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `false` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `false` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun BooleanArray.copyOf(newSize: Int): BooleanArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return withType(\"BooleanArray\", arrayCopyResize(this, newSize, false))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with null char (`\\u0000`) values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with null char (`\\u0000`) values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun CharArray.copyOf(newSize: Int): CharArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return withType(\"CharArray\", fillFrom(this, CharArray(newSize)))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `null` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `null` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizingCopyOf\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\npublic actual fun <T> Array<out T>.copyOf(newSize: Int): Array<T?> {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return arrayCopyResize(this, newSize, null)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\npublic actual fun <T> Array<out T>.copyOfRange(fromIndex: Int, toIndex: Int): Array<T> {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic actual fun ByteArray.copyOfRange(fromIndex: Int, toIndex: Int): ByteArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic actual fun ShortArray.copyOfRange(fromIndex: Int, toIndex: Int): ShortArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic actual fun IntArray.copyOfRange(fromIndex: Int, toIndex: Int): IntArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic actual fun LongArray.copyOfRange(fromIndex: Int, toIndex: Int): LongArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return withType(\"LongArray\", this.asDynamic().slice(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic actual fun FloatArray.copyOfRange(fromIndex: Int, toIndex: Int): FloatArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic actual fun DoubleArray.copyOfRange(fromIndex: Int, toIndex: Int): DoubleArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic actual fun BooleanArray.copyOfRange(fromIndex: Int, toIndex: Int): BooleanArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return withType(\"BooleanArray\", this.asDynamic().slice(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic actual fun CharArray.copyOfRange(fromIndex: Int, toIndex: Int): CharArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return withType(\"CharArray\", this.asDynamic().slice(fromIndex, toIndex))\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive), 0 by default.\n * @param toIndex the end of the range (exclusive), size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun <T> Array<T>.fill(element: T, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive), 0 by default.\n * @param toIndex the end of the range (exclusive), size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ByteArray.fill(element: Byte, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive), 0 by default.\n * @param toIndex the end of the range (exclusive), size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ShortArray.fill(element: Short, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive), 0 by default.\n * @param toIndex the end of the range (exclusive), size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun IntArray.fill(element: Int, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive), 0 by default.\n * @param toIndex the end of the range (exclusive), size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun LongArray.fill(element: Long, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive), 0 by default.\n * @param toIndex the end of the range (exclusive), size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun FloatArray.fill(element: Float, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive), 0 by default.\n * @param toIndex the end of the range (exclusive), size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun DoubleArray.fill(element: Double, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive), 0 by default.\n * @param toIndex the end of the range (exclusive), size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun BooleanArray.fill(element: Boolean, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive), 0 by default.\n * @param toIndex the end of the range (exclusive), size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharArray.fill(element: Char, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline operator fun <T> Array<out T>.plus(element: T): Array<T> {\n    return this.asDynamic().concat(arrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ByteArray.plus(element: Byte): ByteArray {\n    return plus(byteArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ShortArray.plus(element: Short): ShortArray {\n    return plus(shortArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun IntArray.plus(element: Int): IntArray {\n    return plus(intArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun LongArray.plus(element: Long): LongArray {\n    return plus(longArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun FloatArray.plus(element: Float): FloatArray {\n    return plus(floatArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun DoubleArray.plus(element: Double): DoubleArray {\n    return plus(doubleArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun BooleanArray.plus(element: Boolean): BooleanArray {\n    return plus(booleanArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun CharArray.plus(element: Char): CharArray {\n    return plus(charArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\npublic actual operator fun <T> Array<out T>.plus(elements: Collection<T>): Array<T> {\n    return arrayPlusCollection(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun ByteArray.plus(elements: Collection<Byte>): ByteArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun ShortArray.plus(elements: Collection<Short>): ShortArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun IntArray.plus(elements: Collection<Int>): IntArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun LongArray.plus(elements: Collection<Long>): LongArray {\n    return arrayPlusCollection(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun FloatArray.plus(elements: Collection<Float>): FloatArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun DoubleArray.plus(elements: Collection<Double>): DoubleArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun BooleanArray.plus(elements: Collection<Boolean>): BooleanArray {\n    return arrayPlusCollection(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun CharArray.plus(elements: Collection<Char>): CharArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline operator fun <T> Array<out T>.plus(elements: Array<out T>): Array<T> {\n    return this.asDynamic().concat(elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ByteArray.plus(elements: ByteArray): ByteArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ShortArray.plus(elements: ShortArray): ShortArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun IntArray.plus(elements: IntArray): IntArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun LongArray.plus(elements: LongArray): LongArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun FloatArray.plus(elements: FloatArray): FloatArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun DoubleArray.plus(elements: DoubleArray): DoubleArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun BooleanArray.plus(elements: BooleanArray): BooleanArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun CharArray.plus(elements: CharArray): CharArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline fun <T> Array<out T>.plusElement(element: T): Array<T> {\n    return this.asDynamic().concat(arrayOf(element))\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun IntArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic actual fun LongArray.sort(): Unit {\n    if (size > 1) sort { a: Long, b: Long -> a.compareTo(b) }\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun ByteArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun ShortArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun DoubleArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun FloatArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun CharArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place according to the natural order of its elements.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Arrays.Sorting.sortArrayOfComparable\n */\npublic actual fun <T : Comparable<T>> Array<out T>.sort(): Unit {\n    if (size > 1) sortArray(this)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Array<out T>.sort(comparison: (a: T, b: T) -> Int): Unit {\n    if (size > 1) sortArrayWith(this, comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sort(noinline comparison: (a: Byte, b: Byte) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sort(noinline comparison: (a: Short, b: Short) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sort(noinline comparison: (a: Int, b: Int) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sort(noinline comparison: (a: Long, b: Long) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sort(noinline comparison: (a: Float, b: Float) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sort(noinline comparison: (a: Double, b: Double) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sort(noinline comparison: (a: Char, b: Char) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic actual fun <T> Array<out T>.sortWith(comparator: Comparator<in T>): Unit {\n    if (size > 1) sortArrayWith(this, comparator)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun ByteArray.toTypedArray(): Array<Byte> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun ShortArray.toTypedArray(): Array<Short> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun IntArray.toTypedArray(): Array<Int> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun LongArray.toTypedArray(): Array<Long> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun FloatArray.toTypedArray(): Array<Float> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun DoubleArray.toTypedArray(): Array<Double> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun BooleanArray.toTypedArray(): Array<Boolean> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun CharArray.toTypedArray(): Array<Char> {\n    return Array(size) { index -> this[index] }\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\nimport kotlin.comparisons.naturalOrder\nimport kotlin.random.Random\n\n/** Returns the array if it's not `null`, or an empty array otherwise. */\n@kotlin.internal.InlineOnly\npublic actual inline fun <T> Array<out T>?.orEmpty(): Array<out T> = this ?: emptyArray<T>()\n\n@kotlin.internal.InlineOnly\npublic actual inline fun <T> Collection<T>.toTypedArray(): Array<T> = copyToArray(this)\n\n@JsName(\"copyToArray\")\n@PublishedApi\ninternal fun <T> copyToArray(collection: Collection<T>): Array<T> {\n    return if (collection.asDynamic().toArray !== undefined)\n        collection.asDynamic().toArray().unsafeCast<Array<T>>()\n    else\n        copyToArrayImpl(collection).unsafeCast<Array<T>>()\n}\n\n@JsName(\"copyToArrayImpl\")\ninternal actual fun copyToArrayImpl(collection: Collection<*>): Array<Any?> {\n    val array = emptyArray<Any?>()\n    val iterator = collection.iterator()\n    while (iterator.hasNext())\n        array.asDynamic().push(iterator.next())\n    return array\n}\n\n@JsName(\"copyToExistingArrayImpl\")\ninternal actual fun <T> copyToArrayImpl(collection: Collection<*>, array: Array<T>): Array<T> {\n    if (array.size < collection.size)\n        return copyToArrayImpl(collection).unsafeCast<Array<T>>()\n\n    val iterator = collection.iterator()\n    var index = 0\n    while (iterator.hasNext()) {\n        array[index++] = iterator.next().unsafeCast<T>()\n    }\n    if (index < array.size) {\n        array[index] = null.unsafeCast<T>()\n    }\n    return array\n}\n\n/**\n * Returns an immutable list containing only the specified object [element].\n */\npublic fun <T> listOf(element: T): List<T> = arrayListOf(element)\n\n/**\n * Returns an immutable set containing only the specified object [element].\n */\npublic fun <T> setOf(element: T): Set<T> = hashSetOf(element)\n\n/**\n * Returns an immutable map, mapping only the specified key to the\n * specified value.\n */\npublic fun <K, V> mapOf(pair: Pair<K, V>): Map<K, V> = hashMapOf(pair)\n\n/**\n * Fills the list with the provided [value].\n *\n * Each element in the list gets replaced with the [value].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> MutableList<T>.fill(value: T): Unit {\n    for (index in 0..lastIndex) {\n        this[index] = value\n    }\n}\n\n/**\n * Randomly shuffles elements in this list.\n *\n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> MutableList<T>.shuffle(): Unit = shuffle(Random)\n\n/**\n * Returns a new list with the elements of this list randomly shuffled.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> Iterable<T>.shuffled(): List<T> = toMutableList().apply { shuffle() }\n\n/**\n * Sorts elements in the list in-place according to their natural sort order.\n *\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic actual fun <T : Comparable<T>> MutableList<T>.sort(): Unit {\n    collectionsSort(this, naturalOrder())\n}\n\n/**\n * Sorts elements in the list in-place according to the order specified with [comparator].\n *\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic actual fun <T> MutableList<T>.sortWith(comparator: Comparator<in T>): Unit {\n    collectionsSort(this, comparator)\n}\n\nprivate fun <T> collectionsSort(list: MutableList<T>, comparator: Comparator<in T>) {\n    if (list.size <= 1) return\n\n    val array = copyToArray(list)\n    sortArrayWith(array, comparator)\n\n    for (i in 0 until array.size) {\n        list[i] = array[i]\n    }\n}\n\ninternal actual fun <T> arrayOfNulls(reference: Array<T>, size: Int): Array<T> {\n    return arrayOfNulls<Any>(size).unsafeCast<Array<T>>()\n}\n\n@SinceKotlin(\"1.3\")\n@PublishedApi\n@JsName(\"arrayCopy\")\ninternal fun <T> arrayCopy(source: Array<out T>, destination: Array<in T>, destinationOffset: Int, startIndex: Int, endIndex: Int) {\n    AbstractList.checkRangeIndexes(startIndex, endIndex, source.size)\n    val rangeSize = endIndex - startIndex\n    AbstractList.checkRangeIndexes(destinationOffset, destinationOffset + rangeSize, destination.size)\n\n    if (js(\"ArrayBuffer\").isView(destination) && js(\"ArrayBuffer\").isView(source)) {\n        val subrange = source.asDynamic().subarray(startIndex, endIndex)\n        destination.asDynamic().set(subrange, destinationOffset)\n    } else {\n        if (source !== destination || destinationOffset <= startIndex) {\n            for (index in 0 until rangeSize) {\n                destination[destinationOffset + index] = source[startIndex + index]\n            }\n        } else {\n            for (index in rangeSize - 1 downTo 0) {\n                destination[destinationOffset + index] = source[startIndex + index]\n            }\n        }\n    }\n}\n\n// no singleton map implementation in js, return map as is\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <K, V> Map<K, V>.toSingletonMapOrSelf(): Map<K, V> = this\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <K, V> Map<out K, V>.toSingletonMap(): Map<K, V> = this.toMutableMap()\n\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <T> Array<out T>.copyToArrayOfAny(isVarargs: Boolean): Array<out Any?> =\n    if (isVarargs)\n    // no need to copy vararg array in JS\n        this\n    else\n        this.copyOf()\n\n\n\n@PublishedApi\ninternal actual fun checkIndexOverflow(index: Int): Int {\n    if (index < 0) {\n        throwIndexOverflow()\n    }\n    return index\n}\n\n@PublishedApi\ninternal actual fun checkCountOverflow(count: Int): Int {\n    if (count < 0) {\n        throwCountOverflow()\n    }\n    return count\n}\n\n\n/**\n * JS map and set implementations do not make use of capacities or load factors.\n */\n@PublishedApi\ninternal actual fun mapCapacity(expectedSize: Int) = expectedSize\n\n/**\n * Checks a collection builder function capacity argument.\n * In JS no validation is made in Map/Set constructor yet.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@PublishedApi\ninternal actual fun checkBuilderCapacity(capacity: Int) {\n    require(capacity >= 0) { \"capacity must be non-negative.\" }\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:Suppress(\"UNUSED_PARAMETER\", \"NOTHING_TO_INLINE\")\n\npackage kotlin\n\n/**\n * Returns an empty array of the specified type [T].\n */\npublic inline fun <T> emptyArray(): Array<T> = js(\"[]\")\n\n@library\npublic fun <T> arrayOf(vararg elements: T): Array<T> = definedExternally\n\n@library\npublic fun doubleArrayOf(vararg elements: Double): DoubleArray = definedExternally\n\n@library\npublic fun floatArrayOf(vararg elements: Float): FloatArray = definedExternally\n\n@library\npublic fun longArrayOf(vararg elements: Long): LongArray = definedExternally\n\n@library\npublic fun intArrayOf(vararg elements: Int): IntArray = definedExternally\n\n@library\npublic fun charArrayOf(vararg elements: Char): CharArray = definedExternally\n\n@library\npublic fun shortArrayOf(vararg elements: Short): ShortArray = definedExternally\n\n@library\npublic fun byteArrayOf(vararg elements: Byte): ByteArray = definedExternally\n\n@library\npublic fun booleanArrayOf(vararg elements: Boolean): BooleanArray = definedExternally\n\n/**\n * Creates a new instance of the [Lazy] that uses the specified initialization function [initializer].\n */\npublic actual fun <T> lazy(initializer: () -> T): Lazy<T> = UnsafeLazyImpl(initializer)\n\n/**\n * Creates a new instance of the [Lazy] that uses the specified initialization function [initializer].\n *\n * The [mode] parameter is ignored. */\npublic actual fun <T> lazy(mode: LazyThreadSafetyMode, initializer: () -> T): Lazy<T> = UnsafeLazyImpl(initializer)\n\n/**\n * Creates a new instance of the [Lazy] that uses the specified initialization function [initializer].\n *\n * The [lock] parameter is ignored.\n */\npublic actual fun <T> lazy(lock: Any?, initializer: () -> T): Lazy<T> = UnsafeLazyImpl(initializer)\n\n\ninternal fun fillFrom(src: dynamic, dst: dynamic): dynamic {\n    val srcLen: Int = src.length\n    val dstLen: Int = dst.length\n    var index: Int = 0\n    while (index < srcLen && index < dstLen) dst[index] = src[index++]\n    return dst\n}\n\n\ninternal fun arrayCopyResize(source: dynamic, newSize: Int, defaultValue: Any?): dynamic {\n    val result = source.slice(0, newSize)\n    copyArrayType(source, result)\n    var index: Int = source.length\n    if (newSize > index) {\n        result.length = newSize\n        while (index < newSize) result[index++] = defaultValue\n    }\n    return result\n}\n\ninternal fun <T> arrayPlusCollection(array: dynamic, collection: Collection<T>): dynamic {\n    val result = array.slice()\n    result.length += collection.size\n    copyArrayType(array, result)\n    var index: Int = array.length\n    for (element in collection) result[index++] = element\n    return result\n}\n\ninternal fun <T> fillFromCollection(dst: dynamic, startIndex: Int, collection: Collection<T>): dynamic {\n    var index = startIndex\n    for (element in collection) dst[index++] = element\n    return dst\n}\n\ninternal inline fun copyArrayType(from: dynamic, to: dynamic) {\n    if (from.`$type$` !== undefined) {\n        to.`$type$` = from.`$type$`\n    }\n}\n\ninternal inline fun jsIsType(obj: dynamic, jsClass: dynamic) = js(\"Kotlin\").isType(obj, jsClass)","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the [MutableCollection] interface.\n *\n * @param E the type of elements contained in the collection. The collection is invariant on its element type.\n */\npublic actual abstract class AbstractMutableCollection<E> protected actual constructor() : AbstractCollection<E>(), MutableCollection<E> {\n\n    actual abstract override fun add(element: E): Boolean\n\n    actual override fun remove(element: E): Boolean {\n        val iterator = iterator()\n        while (iterator.hasNext()) {\n            if (iterator.next() == element) {\n                iterator.remove()\n                return true\n            }\n        }\n        return false\n    }\n\n    actual override fun addAll(elements: Collection<E>): Boolean {\n        var modified = false\n        for (element in elements) {\n            if (add(element)) modified = true\n        }\n        return modified\n    }\n\n    actual override fun removeAll(elements: Collection<E>): Boolean = (this as MutableIterable<E>).removeAll { it in elements }\n    actual override fun retainAll(elements: Collection<E>): Boolean = (this as MutableIterable<E>).removeAll { it !in elements }\n\n    actual override fun clear(): Unit {\n        val iterator = this.iterator()\n        while (iterator.hasNext()) {\n            iterator.next()\n            iterator.remove()\n        }\n    }\n\n    @JsName(\"toJSON\")\n    open fun toJSON(): Any = this.toArray()\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n/*\n * Based on GWT AbstractList\n * Copyright 2007 Google Inc.\n*/\n\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the [MutableList] interface.\n *\n * @param E the type of elements contained in the list. The list is invariant on its element type.\n */\npublic actual abstract class AbstractMutableList<E> protected actual constructor() : AbstractMutableCollection<E>(), MutableList<E> {\n    protected var modCount: Int = 0\n\n    abstract override fun add(index: Int, element: E): Unit\n    abstract override fun removeAt(index: Int): E\n    abstract override fun set(index: Int, element: E): E\n\n    /**\n     * Adds the specified element to the end of this list.\n     *\n     * @return `true` because the list is always modified as the result of this operation.\n     */\n    actual override fun add(element: E): Boolean {\n        add(size, element)\n        return true\n    }\n\n    actual override fun addAll(index: Int, elements: Collection<E>): Boolean {\n        var _index = index\n        var changed = false\n        for (e in elements) {\n            add(_index++, e)\n            changed = true\n        }\n        return changed\n    }\n\n    actual override fun clear() {\n        removeRange(0, size)\n    }\n\n    actual override fun removeAll(elements: Collection<E>): Boolean = removeAll { it in elements }\n    actual override fun retainAll(elements: Collection<E>): Boolean = removeAll { it !in elements }\n\n\n    actual override fun iterator(): MutableIterator<E> = IteratorImpl()\n\n    actual override fun contains(element: E): Boolean = indexOf(element) >= 0\n\n    actual override fun indexOf(element: E): Int {\n        for (index in 0..lastIndex) {\n            if (get(index) == element) {\n                return index\n            }\n        }\n        return -1\n    }\n\n    actual override fun lastIndexOf(element: E): Int {\n        for (index in lastIndex downTo 0) {\n            if (get(index) == element) {\n                return index\n            }\n        }\n        return -1\n    }\n\n    actual override fun listIterator(): MutableListIterator<E> = listIterator(0)\n    actual override fun listIterator(index: Int): MutableListIterator<E> = ListIteratorImpl(index)\n\n\n    actual override fun subList(fromIndex: Int, toIndex: Int): MutableList<E> = SubList(this, fromIndex, toIndex)\n\n    /**\n     * Removes the range of elements from this list starting from [fromIndex] and ending with but not including [toIndex].\n     */\n    protected open fun removeRange(fromIndex: Int, toIndex: Int) {\n        val iterator = listIterator(fromIndex)\n        repeat(toIndex - fromIndex) {\n            iterator.next()\n            iterator.remove()\n        }\n    }\n\n    /**\n     * Compares this list with another list instance with the ordered structural equality.\n     *\n     * @return true, if [other] instance is a [List] of the same size, which contains the same elements in the same order.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is List<*>) return false\n\n        return AbstractList.orderedEquals(this, other)\n    }\n\n    /**\n     * Returns the hash code value for this list.\n     */\n    override fun hashCode(): Int = AbstractList.orderedHashCode(this)\n\n\n    private open inner class IteratorImpl : MutableIterator<E> {\n        /** the index of the item that will be returned on the next call to [next]`()` */\n        protected var index = 0\n        /** the index of the item that was returned on the previous call to [next]`()`\n         * or [ListIterator.previous]`()` (for `ListIterator`),\n         * -1 if no such item exists\n         */\n        protected var last = -1\n\n        override fun hasNext(): Boolean = index < size\n\n        override fun next(): E {\n            if (!hasNext()) throw NoSuchElementException()\n            last = index++\n            return get(last)\n        }\n\n        override fun remove() {\n            check(last != -1) { \"Call next() or previous() before removing element from the iterator.\" }\n\n            removeAt(last)\n            index = last\n            last = -1\n        }\n    }\n\n    /**\n     * Implementation of `MutableListIterator` for abstract lists.\n     */\n    private inner class ListIteratorImpl(index: Int) : IteratorImpl(), MutableListIterator<E> {\n\n        init {\n            AbstractList.checkPositionIndex(index, this@AbstractMutableList.size)\n            this.index = index\n        }\n\n        override fun hasPrevious(): Boolean = index > 0\n\n        override fun nextIndex(): Int = index\n\n        override fun previous(): E {\n            if (!hasPrevious()) throw NoSuchElementException()\n\n            last = --index\n            return get(last)\n        }\n\n        override fun previousIndex(): Int = index - 1\n\n        override fun add(element: E) {\n            add(index, element)\n            index++\n            last = -1\n        }\n\n        override fun set(element: E) {\n            check(last != -1) { \"Call next() or previous() before updating element value with the iterator.\" }\n            this@AbstractMutableList[last] = element\n        }\n    }\n\n    private class SubList<E>(private val list: AbstractMutableList<E>, private val fromIndex: Int, toIndex: Int) : AbstractMutableList<E>(), RandomAccess {\n        private var _size: Int = 0\n\n        init {\n            AbstractList.checkRangeIndexes(fromIndex, toIndex, list.size)\n            this._size = toIndex - fromIndex\n        }\n\n        override fun add(index: Int, element: E) {\n            AbstractList.checkPositionIndex(index, _size)\n\n            list.add(fromIndex + index, element)\n            _size++\n        }\n\n        override fun get(index: Int): E {\n            AbstractList.checkElementIndex(index, _size)\n\n            return list[fromIndex + index]\n        }\n\n        override fun removeAt(index: Int): E {\n            AbstractList.checkElementIndex(index, _size)\n\n            val result = list.removeAt(fromIndex + index)\n            _size--\n            return result\n        }\n\n        override fun set(index: Int, element: E): E {\n            AbstractList.checkElementIndex(index, _size)\n\n            return list.set(fromIndex + index, element)\n        }\n\n        override val size: Int get() = _size\n    }\n\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n/*\n * Based on GWT AbstractMap\n * Copyright 2007 Google Inc.\n */\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the [MutableMap] interface.\n *\n * The implementor is required to implement [entries] property, which should return mutable set of map entries, and [put] function.\n *\n * @param K the type of map keys. The map is invariant on its key type.\n * @param V the type of map values. The map is invariant on its value type.\n */\npublic actual abstract class AbstractMutableMap<K, V> protected actual constructor() : AbstractMap<K, V>(), MutableMap<K, V> {\n\n    /**\n     * A mutable [Map.Entry] shared by several [Map] implementations.\n     */\n    internal open class SimpleEntry<K, V>(override val key: K, value: V) : MutableMap.MutableEntry<K, V> {\n        constructor(entry: Map.Entry<K, V>) : this(entry.key, entry.value)\n\n        private var _value = value\n\n        override val value: V get() = _value\n\n        override fun setValue(newValue: V): V {\n            val oldValue = this._value\n            this._value = newValue\n            return oldValue\n        }\n\n        override fun hashCode(): Int = entryHashCode(this)\n        override fun toString(): String = entryToString(this)\n        override fun equals(other: Any?): Boolean = entryEquals(this, other)\n\n    }\n\n    actual override fun clear() {\n        entries.clear()\n    }\n\n    private var _keys: MutableSet<K>? = null\n    actual override val keys: MutableSet<K>\n        get() {\n            if (_keys == null) {\n                _keys = object : AbstractMutableSet<K>() {\n                    override fun add(element: K): Boolean = throw UnsupportedOperationException(\"Add is not supported on keys\")\n                    override fun clear() {\n                        this@AbstractMutableMap.clear()\n                    }\n\n                    override operator fun contains(element: K): Boolean = containsKey(element)\n\n                    override operator fun iterator(): MutableIterator<K> {\n                        val entryIterator = entries.iterator()\n                        return object : MutableIterator<K> {\n                            override fun hasNext(): Boolean = entryIterator.hasNext()\n                            override fun next(): K = entryIterator.next().key\n                            override fun remove() = entryIterator.remove()\n                        }\n                    }\n\n                    override fun remove(element: K): Boolean {\n                        if (containsKey(element)) {\n                            this@AbstractMutableMap.remove(element)\n                            return true\n                        }\n                        return false\n                    }\n\n                    override val size: Int get() = this@AbstractMutableMap.size\n                }\n            }\n            return _keys!!\n        }\n\n    actual abstract override fun put(key: K, value: V): V?\n\n    actual override fun putAll(from: Map<out K, V>) {\n        for ((key, value) in from) {\n            put(key, value)\n        }\n    }\n\n    private var _values: MutableCollection<V>? = null\n    actual override val values: MutableCollection<V>\n        get() {\n            if (_values == null) {\n                _values = object : AbstractMutableCollection<V>() {\n                    override fun add(element: V): Boolean = throw UnsupportedOperationException(\"Add is not supported on values\")\n                    override fun clear() = this@AbstractMutableMap.clear()\n\n                    override operator fun contains(element: V): Boolean = containsValue(element)\n\n                    override operator fun iterator(): MutableIterator<V> {\n                        val entryIterator = entries.iterator()\n                        return object : MutableIterator<V> {\n                            override fun hasNext(): Boolean = entryIterator.hasNext()\n                            override fun next(): V = entryIterator.next().value\n                            override fun remove() = entryIterator.remove()\n                        }\n                    }\n\n                    override val size: Int get() = this@AbstractMutableMap.size\n\n                    // TODO: should we implement them this way? Currently it's unspecified in JVM\n                    override fun equals(other: Any?): Boolean {\n                        if (this === other) return true\n                        if (other !is Collection<*>) return false\n                        return AbstractList.orderedEquals(this, other)\n                    }\n\n                    override fun hashCode(): Int = AbstractList.orderedHashCode(this)\n                }\n            }\n            return _values!!\n        }\n\n    actual override fun remove(key: K): V? {\n        val iter = entries.iterator()\n        while (iter.hasNext()) {\n            val entry = iter.next()\n            val k = entry.key\n            if (key == k) {\n                val value = entry.value\n                iter.remove()\n                return value\n            }\n        }\n        return null\n    }\n\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the [MutableSet] interface.\n *\n * @param E the type of elements contained in the set. The set is invariant on its element type.\n */\npublic actual abstract class AbstractMutableSet<E> protected actual constructor() : AbstractMutableCollection<E>(), MutableSet<E> {\n\n    /**\n     * Compares this set with another set instance with the unordered structural equality.\n     *\n     * @return `true`, if [other] instance is a [Set] of the same size, all elements of which are contained in this set.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is Set<*>) return false\n        return AbstractSet.setEquals(this, other)\n    }\n\n    /**\n     * Returns the hash code value for this set.\n     */\n    override fun hashCode(): Int = AbstractSet.unorderedHashCode(this)\n\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n/**\n * Provides a [MutableList] implementation, which uses a resizable array as its backing storage.\n *\n * This implementation doesn't provide a way to manage capacity, as backing JS array is resizeable itself.\n * There is no speed advantage to pre-allocating array sizes in JavaScript, so this implementation does not include any of the\n * capacity and \"growth increment\" concepts.\n */\npublic actual open class ArrayList<E> internal constructor(private var array: Array<Any?>) : AbstractMutableList<E>(), MutableList<E>, RandomAccess {\n\n    /**\n     * Creates an empty [ArrayList].\n     */\n    public actual constructor() : this(emptyArray()) {}\n\n    /**\n     * Creates an empty [ArrayList].\n     * @param initialCapacity initial capacity (ignored)\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    public actual constructor(initialCapacity: Int = 0) : this(emptyArray()) {}\n\n    /**\n     * Creates an [ArrayList] filled from the [elements] collection.\n     */\n    public actual constructor(elements: Collection<E>) : this(elements.toTypedArray<Any?>()) {}\n\n    /** Does nothing in this ArrayList implementation. */\n    public actual fun trimToSize() {}\n\n    /** Does nothing in this ArrayList implementation. */\n    public actual fun ensureCapacity(minCapacity: Int) {}\n\n    actual override val size: Int get() = array.size\n    @Suppress(\"UNCHECKED_CAST\")\n    actual override fun get(index: Int): E = array[rangeCheck(index)] as E\n    actual override fun set(index: Int, element: E): E {\n        rangeCheck(index)\n        @Suppress(\"UNCHECKED_CAST\")\n        return array[index].apply { array[index] = element } as E\n    }\n\n    actual override fun add(element: E): Boolean {\n        array.asDynamic().push(element)\n        modCount++\n        return true\n    }\n\n    actual override fun add(index: Int, element: E): Unit {\n        array.asDynamic().splice(insertionRangeCheck(index), 0, element)\n        modCount++\n    }\n\n    actual override fun addAll(elements: Collection<E>): Boolean {\n        if (elements.isEmpty()) return false\n\n        array += elements.toTypedArray<Any?>()\n        modCount++\n        return true\n    }\n\n    actual override fun addAll(index: Int, elements: Collection<E>): Boolean {\n        insertionRangeCheck(index)\n\n        if (index == size) return addAll(elements)\n        if (elements.isEmpty()) return false\n        when (index) {\n            size -> return addAll(elements)\n            0 -> array = elements.toTypedArray<Any?>() + array\n            else -> array = array.copyOfRange(0, index).asDynamic().concat(elements.toTypedArray<Any?>(), array.copyOfRange(index, size))\n        }\n\n        modCount++\n        return true\n    }\n\n    actual override fun removeAt(index: Int): E {\n        rangeCheck(index)\n        modCount++\n        return if (index == lastIndex)\n            array.asDynamic().pop()\n        else\n            array.asDynamic().splice(index, 1)[0]\n    }\n\n    actual override fun remove(element: E): Boolean {\n        for (index in array.indices) {\n            if (array[index] == element) {\n                array.asDynamic().splice(index, 1)\n                modCount++\n                return true\n            }\n        }\n        return false\n    }\n\n    override fun removeRange(fromIndex: Int, toIndex: Int) {\n        modCount++\n        array.asDynamic().splice(fromIndex, toIndex - fromIndex)\n    }\n\n    actual override fun clear() {\n        array = emptyArray()\n        modCount++\n    }\n\n\n    actual override fun indexOf(element: E): Int = array.indexOf(element)\n\n    actual override fun lastIndexOf(element: E): Int = array.lastIndexOf(element)\n\n    override fun toString() = arrayToString(array)\n    override fun toArray(): Array<Any?> = js(\"[]\").slice.call(array)\n\n\n    private fun rangeCheck(index: Int) = index.apply {\n        AbstractList.checkElementIndex(index, size)\n    }\n\n    private fun insertionRangeCheck(index: Int) = index.apply {\n        AbstractList.checkPositionIndex(index, size)\n    }\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\ninternal interface EqualityComparator {\n    /**\n     * Subclasses must override to return a value indicating\n     * whether or not two keys or values are equal.\n     */\n    abstract fun equals(value1: Any?, value2: Any?): Boolean\n\n    /**\n     * Subclasses must override to return the hash code of a given key.\n     */\n    abstract fun getHashCode(value: Any?): Int\n\n\n    object HashCode : EqualityComparator {\n        override fun equals(value1: Any?, value2: Any?): Boolean = value1 == value2\n\n        override fun getHashCode(value: Any?): Int = value?.hashCode() ?: 0\n    }\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n/*\n * Based on GWT AbstractHashMap\n * Copyright 2008 Google Inc.\n */\n\npackage kotlin.collections\n\nimport kotlin.collections.MutableMap.MutableEntry\n\n/**\n * Hash table based implementation of the [MutableMap] interface.\n *\n * This implementation makes no guarantees regarding the order of enumeration of [keys], [values] and [entries] collections.\n */\npublic actual open class HashMap<K, V> : AbstractMutableMap<K, V>, MutableMap<K, V> {\n\n    private inner class EntrySet : AbstractMutableSet<MutableEntry<K, V>>() {\n\n        override fun add(element: MutableEntry<K, V>): Boolean = throw UnsupportedOperationException(\"Add is not supported on entries\")\n        override fun clear() {\n            this@HashMap.clear()\n        }\n\n        override operator fun contains(element: MutableEntry<K, V>): Boolean = containsEntry(element)\n\n        override operator fun iterator(): MutableIterator<MutableEntry<K, V>> = internalMap.iterator()\n\n        override fun remove(element: MutableEntry<K, V>): Boolean {\n            if (contains(element)) {\n                this@HashMap.remove(element.key)\n                return true\n            }\n            return false\n        }\n\n        override val size: Int get() = this@HashMap.size\n    }\n\n\n    /**\n     * Internal implementation of the map: either string-based or hashcode-based.\n     */\n    private val internalMap: InternalMap<K, V>\n\n    private val equality: EqualityComparator\n\n    internal constructor(internalMap: InternalMap<K, V>) : super() {\n        this.internalMap = internalMap\n        this.equality = internalMap.equality\n    }\n\n    /**\n     * Constructs an empty [HashMap] instance.\n     */\n    actual constructor() : this(InternalHashCodeMap(EqualityComparator.HashCode))\n\n    /**\n     * Constructs an empty [HashMap] instance.\n     *\n     * @param  initialCapacity the initial capacity (ignored)\n     * @param  loadFactor      the load factor (ignored)\n     *\n     * @throws IllegalArgumentException if the initial capacity or load factor are negative\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    actual constructor(initialCapacity: Int, loadFactor: Float = 0.0f) : this() {\n        // This implementation of HashMap has no need of load factors or capacities.\n        require(initialCapacity >= 0) { \"Negative initial capacity: $initialCapacity\" }\n        require(loadFactor >= 0) { \"Non-positive load factor: $loadFactor\" }\n    }\n\n    actual constructor(initialCapacity: Int) : this(initialCapacity, 0.0f)\n\n\n    /**\n     * Constructs an instance of [HashMap] filled with the contents of the specified [original] map.\n     */\n    actual constructor(original: Map<out K, V>) : this() {\n        this.putAll(original)\n    }\n\n    actual override fun clear() {\n        internalMap.clear()\n//        structureChanged(this)\n    }\n\n    actual override fun containsKey(key: K): Boolean = internalMap.contains(key)\n\n    actual override fun containsValue(value: V): Boolean = internalMap.any { equality.equals(it.value, value) }\n\n    private var _entries: MutableSet<MutableMap.MutableEntry<K, V>>? = null\n    actual override val entries: MutableSet<MutableMap.MutableEntry<K, V>>\n        get() {\n            if (_entries == null) {\n                _entries = createEntrySet()\n            }\n            return _entries!!\n        }\n\n    protected open fun createEntrySet(): MutableSet<MutableMap.MutableEntry<K, V>> = EntrySet()\n\n    actual override operator fun get(key: K): V? = internalMap.get(key)\n\n    actual override fun put(key: K, value: V): V? = internalMap.put(key, value)\n\n    actual override fun remove(key: K): V? = internalMap.remove(key)\n\n    actual override val size: Int get() = internalMap.size\n\n}\n\n/**\n * Constructs the specialized implementation of [HashMap] with [String] keys, which stores the keys as properties of\n * JS object without hashing them.\n */\npublic fun <V> stringMapOf(vararg pairs: Pair<String, V>): HashMap<String, V> {\n    return HashMap<String, V>(InternalStringMap(EqualityComparator.HashCode)).apply { putAll(pairs) }\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n/*\n * Based on GWT HashSet\n * Copyright 2008 Google Inc.\n */\n\npackage kotlin.collections\n\n/**\n * The implementation of the [MutableSet] interface, backed by a [HashMap] instance.\n */\npublic actual open class HashSet<E> : AbstractMutableSet<E>, MutableSet<E> {\n\n    private val map: HashMap<E, Any>\n\n    /**\n     * Constructs a new empty [HashSet].\n     */\n    actual constructor() {\n        map = HashMap<E, Any>()\n    }\n\n    /**\n     * Constructs a new [HashSet] filled with the elements of the specified collection.\n     */\n    actual constructor(elements: Collection<E>) {\n        map = HashMap<E, Any>(elements.size)\n        addAll(elements)\n    }\n\n    /**\n     * Constructs a new empty [HashSet].\n     *\n     * @param  initialCapacity the initial capacity (ignored)\n     * @param  loadFactor      the load factor (ignored)\n     *\n     * @throws IllegalArgumentException if the initial capacity or load factor are negative\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    actual constructor(initialCapacity: Int, loadFactor: Float = 0.0f) {\n        map = HashMap<E, Any>(initialCapacity, loadFactor)\n    }\n\n    actual constructor(initialCapacity: Int) : this(initialCapacity, 0.0f)\n\n    /**\n     * Protected constructor to specify the underlying map. This is used by\n     * LinkedHashSet.\n\n     * @param map underlying map to use.\n     */\n    internal constructor(map: HashMap<E, Any>) {\n        this.map = map\n    }\n\n    actual override fun add(element: E): Boolean {\n        val old = map.put(element, this)\n        return old == null\n    }\n\n    actual override fun clear() {\n        map.clear()\n    }\n\n//    public override fun clone(): Any {\n//        return HashSet<E>(this)\n//    }\n\n    actual override operator fun contains(element: E): Boolean = map.containsKey(element)\n\n    actual override fun isEmpty(): Boolean = map.isEmpty()\n\n    actual override fun iterator(): MutableIterator<E> = map.keys.iterator()\n\n    actual override fun remove(element: E): Boolean = map.remove(element) != null\n\n    actual override val size: Int get() = map.size\n\n}\n\n/**\n * Creates a new instance of the specialized implementation of [HashSet] with the specified [String] elements,\n * which elements the keys as properties of JS object without hashing them.\n */\npublic fun stringSetOf(vararg elements: String): HashSet<String> {\n    return HashSet(stringMapOf<Any>()).apply { addAll(elements) }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n/*\n * Based on GWT InternalHashCodeMap\n * Copyright 2008 Google Inc.\n */\n\npackage kotlin.collections\n\nimport kotlin.collections.MutableMap.MutableEntry\nimport kotlin.collections.AbstractMutableMap.SimpleEntry\n\n/**\n * A simple wrapper around JavaScriptObject to provide [java.util.Map]-like semantics for any\n * key type.\n *\n *\n * Implementation notes:\n *\n *\n * A key's hashCode is the index in backingMap which should contain that key. Since several keys may\n * have the same hash, each value in hashCodeMap is actually an array containing all entries whose\n * keys share the same hash.\n */\ninternal class InternalHashCodeMap<K, V>(override val equality: EqualityComparator) : InternalMap<K, V> {\n\n    private var backingMap: dynamic = createJsMap()\n    override var size: Int = 0\n        private set\n\n    override fun put(key: K, value: V): V? {\n        val hashCode = equality.getHashCode(key)\n        val chainOrEntry = getChainOrEntryOrNull(hashCode)\n        if (chainOrEntry == null) {\n            // This is a new chain, put it to the map.\n            backingMap[hashCode] = SimpleEntry(key, value)\n        } else {\n            if (chainOrEntry !is Array<*>) {\n                // It is an entry\n                val entry: SimpleEntry<K, V> = chainOrEntry\n                if (equality.equals(entry.key, key)) {\n                    return entry.setValue(value)\n                } else {\n                    backingMap[hashCode] = arrayOf(entry, SimpleEntry(key, value))\n                    size++\n                    return null\n                }\n            } else {\n                // Chain already exists, perhaps key also exists.\n                val chain: Array<MutableEntry<K, V>> = chainOrEntry\n                val entry = chain.findEntryInChain(key)\n                if (entry != null) {\n                    return entry.setValue(value)\n                }\n                chain.asDynamic().push(SimpleEntry(key, value))\n            }\n        }\n        size++\n//        structureChanged(host)\n        return null\n    }\n\n    override fun remove(key: K): V? {\n        val hashCode = equality.getHashCode(key)\n        val chainOrEntry = getChainOrEntryOrNull(hashCode) ?: return null\n        if (chainOrEntry !is Array<*>) {\n            val entry: MutableEntry<K, V> = chainOrEntry\n            if (equality.equals(entry.key, key)) {\n                jsDeleteProperty(backingMap, hashCode)\n                size--\n                return entry.value\n            } else {\n                return null\n            }\n        } else {\n            val chain: Array<MutableEntry<K, V>> = chainOrEntry\n            for (index in chain.indices) {\n                val entry = chain[index]\n                if (equality.equals(key, entry.key)) {\n                    if (chain.size == 1) {\n                        chain.asDynamic().length = 0\n                        // remove the whole array\n                        jsDeleteProperty(backingMap, hashCode)\n                    } else {\n                        // splice out the entry we're removing\n                        chain.asDynamic().splice(index, 1)\n                    }\n                    size--\n//                structureChanged(host)\n                    return entry.value\n                }\n            }\n        }\n        return null\n    }\n\n    override fun clear() {\n        backingMap = createJsMap()\n        size = 0\n    }\n\n    override fun contains(key: K): Boolean = getEntry(key) != null\n\n    override fun get(key: K): V? = getEntry(key)?.value\n\n    private fun getEntry(key: K): MutableEntry<K, V>? {\n        val chainOrEntry = getChainOrEntryOrNull(equality.getHashCode(key)) ?: return null\n        if (chainOrEntry !is Array<*>) {\n            val entry: MutableEntry<K, V> = chainOrEntry\n            if (equality.equals(entry.key, key)) {\n                return entry\n            } else {\n                return null\n            }\n        } else {\n            val chain: Array<MutableEntry<K, V>> = chainOrEntry\n            return chain.findEntryInChain(key)\n        }\n    }\n\n    private fun Array<MutableEntry<K, V>>.findEntryInChain(key: K): MutableEntry<K, V>? =\n        firstOrNull { entry -> equality.equals(entry.key, key) }\n\n    override fun iterator(): MutableIterator<MutableEntry<K, V>> {\n\n        return object : MutableIterator<MutableEntry<K, V>> {\n            var state = -1 // -1 not ready, 0 - ready, 1 - done\n\n            val keys: Array<String> = js(\"Object\").keys(backingMap)\n            var keyIndex = -1\n\n            var chainOrEntry: dynamic = null\n            var isChain = false\n            var itemIndex = -1\n            var lastEntry: MutableEntry<K, V>? = null\n\n            private fun computeNext(): Int {\n                if (chainOrEntry != null && isChain) {\n                    val chainSize: Int = chainOrEntry.unsafeCast<Array<MutableEntry<K, V>>>().size\n                    if (++itemIndex < chainSize)\n                        return 0\n                }\n\n                if (++keyIndex < keys.size) {\n                    chainOrEntry = backingMap[keys[keyIndex]]\n                    isChain = chainOrEntry is Array<*>\n                    itemIndex = 0\n                    return 0\n                } else {\n                    chainOrEntry = null\n                    return 1\n                }\n            }\n\n            override fun hasNext(): Boolean {\n                if (state == -1)\n                    state = computeNext()\n                return state == 0\n            }\n\n            override fun next(): MutableEntry<K, V> {\n                if (!hasNext()) throw NoSuchElementException()\n                val lastEntry = if (isChain) {\n                    chainOrEntry.unsafeCast<Array<MutableEntry<K, V>>>()[itemIndex]\n                } else {\n                    chainOrEntry.unsafeCast<MutableEntry<K, V>>()\n                }\n                this.lastEntry = lastEntry\n                state = -1\n                return lastEntry\n            }\n\n            override fun remove() {\n                checkNotNull(lastEntry)\n                this@InternalHashCodeMap.remove(lastEntry!!.key)\n                lastEntry = null\n                // the chain being iterated just got modified by InternalHashCodeMap.remove\n                itemIndex--\n            }\n        }\n    }\n\n    private fun getChainOrEntryOrNull(hashCode: Int): dynamic {\n        val chainOrEntry = backingMap[hashCode]\n        return if (chainOrEntry === undefined) null else chainOrEntry\n    }\n\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n/*\n * Based on GWT InternalStringMap\n * Copyright 2008 Google Inc.\n */\npackage kotlin.collections\n\nimport kotlin.collections.MutableMap.MutableEntry\n\n/**\n * A simple wrapper around JavaScript Map for key type is string.\n *\n * Though this map is instantiated only with K=String, the K type is not fixed to String statically,\n * because we want to have it erased to Any? in order not to generate type-safe override bridges for\n * [get], [contains], [remove] etc, if they ever are generated.\n */\ninternal class InternalStringMap<K, V>(override val equality: EqualityComparator) : InternalMap<K, V> {\n\n    private var backingMap: dynamic = createJsMap()\n    override var size: Int = 0\n        private set\n\n//    /**\n//     * A mod count to track 'value' replacements in map to ensure that the 'value' that we have in the\n//     * iterator entry is guaranteed to be still correct.\n//     * This is to optimize for the common scenario where the values are not modified during\n//     * iterations where the entries are never stale.\n//     */\n//    private var valueMod: Int = 0\n\n    override operator fun contains(key: K): Boolean {\n        if (key !is String) return false\n        return backingMap[key] !== undefined\n    }\n\n    override operator fun get(key: K): V? {\n        if (key !is String) return null\n        val value = backingMap[key]\n        return if (value !== undefined) value.unsafeCast<V>() else null\n    }\n\n\n    override fun put(key: K, value: V): V? {\n        require(key is String)\n        val oldValue = backingMap[key]\n        backingMap[key] = value\n\n        if (oldValue === undefined) {\n            size++\n//            structureChanged(host)\n            return null\n        } else {\n//            valueMod++\n            return oldValue.unsafeCast<V>()\n        }\n    }\n\n    override fun remove(key: K): V? {\n        if (key !is String) return null\n        val value = backingMap[key]\n        if (value !== undefined) {\n            jsDeleteProperty(backingMap, key)\n            size--\n//            structureChanged(host)\n            return value.unsafeCast<V>()\n        } else {\n//            valueMod++\n            return null\n        }\n    }\n\n\n    override fun clear() {\n        backingMap = createJsMap()\n        size = 0\n    }\n\n\n    override fun iterator(): MutableIterator<MutableEntry<K, V>> {\n        return object : MutableIterator<MutableEntry<K, V>> {\n            private val keys: Array<String> = js(\"Object\").keys(backingMap)\n            private val iterator = keys.iterator()\n            private var lastKey: String? = null\n\n            override fun hasNext(): Boolean = iterator.hasNext()\n\n            override fun next(): MutableEntry<K, V> {\n                val key = iterator.next()\n                lastKey = key\n                @Suppress(\"UNCHECKED_CAST\")\n                return newMapEntry(key as K)\n            }\n\n            override fun remove() {\n                @Suppress(\"UNCHECKED_CAST\")\n                this@InternalStringMap.remove(checkNotNull(lastKey) as K)\n            }\n        }\n    }\n\n    private fun newMapEntry(key: K): MutableEntry<K, V> = object : MutableEntry<K, V> {\n        override val key: K get() = key\n        override val value: V get() = this@InternalStringMap[key].unsafeCast<V>()\n\n        override fun setValue(newValue: V): V = this@InternalStringMap.put(key, newValue).unsafeCast<V>()\n\n        override fun hashCode(): Int = AbstractMap.entryHashCode(this)\n        override fun toString(): String = AbstractMap.entryToString(this)\n        override fun equals(other: Any?): Boolean = AbstractMap.entryEquals(this, other)\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n/*\n * Based on GWT LinkedHashMap\n * Copyright 2008 Google Inc.\n */\npackage kotlin.collections\n\nimport kotlin.collections.MutableMap.MutableEntry\n\n/**\n * Hash table based implementation of the [MutableMap] interface, which additionally preserves the insertion order\n * of entries during the iteration.\n *\n * The insertion order is preserved by maintaining a doubly-linked list of all of its entries.\n */\npublic actual open class LinkedHashMap<K, V> : HashMap<K, V>, MutableMap<K, V> {\n\n    /**\n     * The entry we use includes next/prev pointers for a doubly-linked circular\n     * list with a head node. This reduces the special cases we have to deal with\n     * in the list operations.\n\n     * Note that we duplicate the key from the underlying hash map so we can find\n     * the eldest entry. The alternative would have been to modify HashMap so more\n     * of the code was directly usable here, but this would have added some\n     * overhead to HashMap, or to reimplement most of the HashMap code here with\n     * small modifications. Paying a small storage cost only if you use\n     * LinkedHashMap and minimizing code size seemed like a better tradeoff\n     */\n    private class ChainEntry<K, V>(key: K, value: V) : AbstractMutableMap.SimpleEntry<K, V>(key, value) {\n        internal var next: ChainEntry<K, V>? = null\n        internal var prev: ChainEntry<K, V>? = null\n    }\n\n    private inner class EntrySet : AbstractMutableSet<MutableEntry<K, V>>() {\n\n        private inner class EntryIterator : MutableIterator<MutableEntry<K, V>> {\n            // The last entry that was returned from this iterator.\n            private var last: ChainEntry<K, V>? = null\n\n            // The next entry to return from this iterator.\n            private var next: ChainEntry<K, V>? = null\n\n            init {\n                next = head\n//                recordLastKnownStructure(map, this)\n            }\n\n            override fun hasNext(): Boolean {\n                return next !== null\n            }\n\n            override fun next(): MutableEntry<K, V> {\n//                checkStructuralChange(map, this)\n                if (!hasNext()) throw NoSuchElementException()\n\n                val current = next!!\n                last = current\n                next = current.next.takeIf { it !== head }\n                return current\n            }\n\n            override fun remove() {\n                check(last != null)\n//                checkStructuralChange(map, this)\n\n                last!!.remove()\n                map.remove(last!!.key)\n//                recordLastKnownStructure(map, this)\n                last = null\n            }\n        }\n\n        override fun add(element: MutableEntry<K, V>): Boolean = throw UnsupportedOperationException(\"Add is not supported on entries\")\n        override fun clear() {\n            this@LinkedHashMap.clear()\n        }\n\n        override operator fun contains(element: MutableEntry<K, V>): Boolean = containsEntry(element)\n\n        override operator fun iterator(): MutableIterator<MutableEntry<K, V>> = EntryIterator()\n\n        override fun remove(element: MutableEntry<K, V>): Boolean {\n            if (contains(element)) {\n                this@LinkedHashMap.remove(element.key)\n                return true\n            }\n            return false\n        }\n\n        override val size: Int get() = this@LinkedHashMap.size\n    }\n\n\n    /*\n   * The head of the insert order chain, which is a doubly-linked circular\n   * list.\n   *\n   * The most recently inserted node is at the end of the chain, ie.\n   * chain.prev.\n   */\n    private var head: ChainEntry<K, V>? = null\n\n    /**\n     * Add this node to the end of the chain.\n     */\n    private fun ChainEntry<K, V>.addToEnd() {\n        // This entry is not in the list.\n        check(next == null && prev == null)\n\n        val _head = head\n        if (_head == null) {\n            head = this\n            next = this\n            prev = this\n        } else {\n            // Chain is valid.\n            val _tail = checkNotNull(_head.prev)\n            // Update me.\n            prev = _tail\n            next = _head\n            // Update my new siblings: current head and old tail\n            _head.prev = this\n            _tail.next = this\n        }\n    }\n\n    /**\n     * Remove this node from the chain it is a part of.\n     */\n    private fun ChainEntry<K, V>.remove() {\n        if (this.next === this) {\n            // if this is single element, remove head\n            head = null\n        } else {\n            if (head === this) {\n                // if this is first element, move head to next\n                head = next\n            }\n            next!!.prev = prev\n            prev!!.next = next\n        }\n        next = null\n        prev = null\n    }\n\n    /*\n   * The hashmap that keeps track of our entries and the chain. Note that we\n   * duplicate the key here to eliminate changes to HashMap and minimize the\n   * code here, at the expense of additional space.\n   */\n    private val map: HashMap<K, ChainEntry<K, V>>\n\n    /**\n     * Constructs an empty [LinkedHashMap] instance.\n     */\n    actual constructor() : super() {\n        map = HashMap<K, ChainEntry<K, V>>()\n    }\n\n    internal constructor(backingMap: HashMap<K, Any>) : super() {\n        @Suppress(\"UNCHECKED_CAST\") // expected to work due to erasure\n        map = backingMap as HashMap<K, ChainEntry<K, V>>\n    }\n\n    /**\n     * Constructs an empty [LinkedHashMap] instance.\n     *\n     * @param  initialCapacity the initial capacity (ignored)\n     * @param  loadFactor      the load factor (ignored)\n     *\n     * @throws IllegalArgumentException if the initial capacity or load factor are negative\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    actual constructor(initialCapacity: Int, loadFactor: Float = 0.0f) : super(initialCapacity, loadFactor) {\n        map = HashMap<K, ChainEntry<K, V>>()\n    }\n\n    actual constructor(initialCapacity: Int) : this(initialCapacity, 0.0f)\n\n    /**\n     * Constructs an instance of [LinkedHashMap] filled with the contents of the specified [original] map.\n     */\n    actual constructor(original: Map<out K, V>) {\n        map = HashMap<K, ChainEntry<K, V>>()\n        this.putAll(original)\n    }\n\n    actual override fun clear() {\n        map.clear()\n        head = null\n    }\n\n\n//    override fun clone(): Any {\n//        return LinkedHashMap(this)\n//    }\n\n\n    actual override fun containsKey(key: K): Boolean = map.containsKey(key)\n\n    actual override fun containsValue(value: V): Boolean {\n        var node: ChainEntry<K, V> = head ?: return false\n        do {\n            if (node.value == value) {\n                return true\n            }\n            node = node.next!!\n        } while (node !== head)\n        return false\n    }\n\n\n    override fun createEntrySet(): MutableSet<MutableMap.MutableEntry<K, V>> = EntrySet()\n\n    actual override operator fun get(key: K): V? = map.get(key)?.value\n\n    actual override fun put(key: K, value: V): V? {\n        val old = map.get(key)\n        if (old == null) {\n            val newEntry = ChainEntry(key, value)\n            map.put(key, newEntry)\n            newEntry.addToEnd()\n            return null\n        } else {\n            return old.setValue(value)\n        }\n    }\n\n    actual override fun remove(key: K): V? {\n        val entry = map.remove(key)\n        if (entry != null) {\n            entry.remove()\n            return entry.value\n        }\n        return null\n    }\n\n    actual override val size: Int get() = map.size\n\n}\n\n/**\n * Constructs the specialized implementation of [LinkedHashMap] with [String] keys, which stores the keys as properties of\n * JS object without hashing them.\n */\npublic fun <V> linkedStringMapOf(vararg pairs: Pair<String, V>): LinkedHashMap<String, V> {\n    return LinkedHashMap<String, V>(stringMapOf<Any>()).apply { putAll(pairs) }\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.io\n\ninternal abstract class BaseOutput {\n    open fun println() {\n        print(\"\\n\")\n    }\n\n    open fun println(message: Any?) {\n        print(message)\n        println()\n    }\n\n    abstract fun print(message: Any?)\n\n    open fun flush() {}\n}\n\n/** JsName used to make the declaration available outside of module to test it */\n@JsName(\"NodeJsOutput\")\ninternal class NodeJsOutput(val outputStream: dynamic) : BaseOutput() {\n    override fun print(message: Any?) {\n        // TODO: Using local variable because of bug in block decomposition lowering in IR backend\n        val messageString = String(message)\n        outputStream.write(messageString)\n    }\n}\n\n/** JsName used to make the declaration available outside of module to test it */\n@JsName(\"OutputToConsoleLog\")\ninternal class OutputToConsoleLog : BaseOutput() {\n    override fun print(message: Any?) {\n        console.log(message)\n    }\n\n    override fun println(message: Any?) {\n        console.log(message)\n    }\n\n    override fun println() {\n        console.log(\"\")\n    }\n}\n\n/** JsName used to make the declaration available outside of module to test it and use at try.kotl.in */\n@JsName(\"BufferedOutput\")\ninternal open class BufferedOutput : BaseOutput() {\n    var buffer = \"\"\n\n    override fun print(message: Any?) {\n        buffer += String(message)\n    }\n\n    override fun flush() {\n        buffer = \"\"\n    }\n}\n\n/** JsName used to make the declaration available outside of module to test it */\n@JsName(\"BufferedOutputToConsoleLog\")\ninternal class BufferedOutputToConsoleLog : BufferedOutput() {\n    override fun print(message: Any?) {\n        var s = String(message)\n        val i = s.nativeLastIndexOf(\"\\n\", 0)\n        if (i >= 0) {\n            buffer += s.substring(0, i)\n            flush()\n            s = s.substring(i + 1)\n        }\n        buffer += s\n    }\n\n    override fun flush() {\n        console.log(buffer)\n        buffer = \"\"\n    }\n}\n\n/** JsName used to make the declaration available outside of module to test it and use at try.kotl.in */\n@JsName(\"output\")\ninternal var output = run {\n    val isNode: Boolean = js(\"typeof process !== 'undefined' && process.versions && !!process.versions.node\")\n    if (isNode) NodeJsOutput(js(\"process.stdout\")) else BufferedOutputToConsoleLog()\n}\n\n@kotlin.internal.InlineOnly\nprivate inline fun String(value: Any?): String = js(\"String\")(value)\n\n/** Prints the line separator to the standard output stream. */\npublic actual fun println() {\n    output.println()\n}\n\n/** Prints the given [message] and the line separator to the standard output stream. */\npublic actual fun println(message: Any?) {\n    output.println(message)\n}\n\n/** Prints the given [message] to the standard output stream. */\npublic actual fun print(message: Any?) {\n    output.print(message)\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.coroutines.intrinsics.CoroutineSingletons.*\nimport kotlin.coroutines.intrinsics.COROUTINE_SUSPENDED\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal actual class SafeContinuation<in T>\ninternal actual constructor(\n    private val delegate: Continuation<T>,\n    initialResult: Any?\n) : Continuation<T> {\n    @PublishedApi\n    internal actual constructor(delegate: Continuation<T>) : this(delegate, UNDECIDED)\n\n    public actual override val context: CoroutineContext\n        get() = delegate.context\n\n    private var result: Any? = initialResult\n\n    public actual override fun resumeWith(result: Result<T>) {\n        val cur = this.result\n        when {\n            cur === UNDECIDED -> {\n                this.result = result.value\n            }\n            cur === COROUTINE_SUSPENDED -> {\n                this.result = RESUMED\n                delegate.resumeWith(result)\n            }\n            else -> throw IllegalStateException(\"Already resumed\")\n        }\n    }\n\n    @PublishedApi\n    internal actual fun getOrThrow(): Any? {\n        if (result === UNDECIDED) {\n            result = COROUTINE_SUSPENDED\n            return COROUTINE_SUSPENDED\n        }\n        val result = this.result\n        return when {\n            result === RESUMED -> COROUTINE_SUSPENDED // already called continuation, indicate COROUTINE_SUSPENDED upstream\n            result is Result.Failure -> throw result.exception\n            else -> result // either COROUTINE_SUSPENDED or data\n        }\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// a package is omitted to get declarations directly under the module\n\n@JsName(\"throwNPE\")\ninternal fun throwNPE(message: String) {\n    throw NullPointerException(message)\n}\n\n@JsName(\"throwCCE\")\ninternal fun throwCCE() {\n    throw ClassCastException(\"Illegal cast\")\n}\n\n@JsName(\"throwISE\")\ninternal fun throwISE(message: String) {\n    throw IllegalStateException(message)\n}\n\n@JsName(\"throwUPAE\")\ninternal fun throwUPAE(propertyName: String) {\n    throw UninitializedPropertyAccessException(\"lateinit property ${propertyName} has not been initialized\")\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n// NOTE: Do not author your exceptions as they are written in this file, instead use this template:\n/*\npublic open class MyException : Exception {\n    constructor() : super()\n    constructor(message: String?) : super(message)\n    constructor(message: String?, cause: Throwable?) : super(message, cause)\n    constructor(cause: Throwable?) : super(cause)\n}\n*/\n\n\n// TODO: remove workarounds for KT-22053 from direct Throwable inheritors\n// TODO: remove primary constructors, make all secondary KT-22055\n\n@Suppress(\"USELESS_ELVIS_RIGHT_IS_NULL\")\npublic actual open class Error actual constructor(message: String?, cause: Throwable?) : Throwable(message, cause ?: null) {\n    actual constructor() : this(null, null) {\n        Error::class.js.asDynamic().call(this, null, null)\n    }\n\n    actual constructor(message: String?) : this(message, null) {\n        Error::class.js.asDynamic().call(this, message, null)\n    }\n\n    actual constructor(cause: Throwable?) : this(undefined, cause) {\n        Error::class.js.asDynamic().call(this, undefined, cause)\n    }\n}\n\n@Suppress(\"USELESS_ELVIS_RIGHT_IS_NULL\")\npublic actual open class Exception actual constructor(message: String?, cause: Throwable?) : Throwable(message, cause ?: null) {\n    actual constructor() : this(null, null) {\n        Exception::class.js.asDynamic().call(this, null, null)\n    }\n\n    actual constructor(message: String?) : this(message, null) {\n        Exception::class.js.asDynamic().call(this, message, null)\n    }\n\n    actual constructor(cause: Throwable?) : this(undefined, cause) {\n        Exception::class.js.asDynamic().call(this, undefined, cause)\n    }\n}\n\npublic actual open class RuntimeException actual constructor(message: String?, cause: Throwable?) : Exception(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class IllegalArgumentException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class IllegalStateException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class IndexOutOfBoundsException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\npublic actual open class ConcurrentModificationException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class UnsupportedOperationException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\n\npublic actual open class NumberFormatException actual constructor(message: String?) : IllegalArgumentException(message) {\n    actual constructor() : this(null)\n}\n\n\npublic actual open class NullPointerException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\npublic actual open class ClassCastException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\npublic actual open class AssertionError private constructor(message: String?, cause: Throwable?) : Error(message, cause) {\n    actual constructor() : this(null)\n    constructor(message: String?) : this(message, null)\n    actual constructor(message: Any?) : this(message.toString(), message as? Throwable)\n}\n\npublic actual open class NoSuchElementException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\n@SinceKotlin(\"1.3\")\npublic actual open class ArithmeticException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\npublic actual open class NoWhenBranchMatchedException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class UninitializedPropertyAccessException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:Suppress(\"DEPRECATION\", \"DEPRECATION_ERROR\")\npackage kotlin.math\n\n\nimport kotlin.internal.InlineOnly\nimport kotlin.js.Math as nativeMath\n\n\n// region ================ Double Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Double): Double = nativeMath.sin(x)\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Double): Double = nativeMath.cos(x)\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Double): Double = nativeMath.tan(x)\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Double): Double = nativeMath.asin(x)\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Double): Double = nativeMath.acos(x)\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Double): Double = nativeMath.atan(x)\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Double, x: Double): Double = nativeMath.atan2(y, x)\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Double): Double = nativeMath.sinh(x)\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Double): Double = nativeMath.cosh(x)\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Double): Double = nativeMath.tanh(x)\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Double): Double = nativeMath.asinh(x)\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Double): Double = nativeMath.acosh(x)\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Double): Double = nativeMath.atanh(x)\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Double, y: Double): Double = nativeMath.hypot(x, y)\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Double): Double = nativeMath.sqrt(x)\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Double): Double = nativeMath.exp(x)\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Double): Double = nativeMath.expm1(x)\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun log(x: Double, base: Double): Double {\n    if (base <= 0.0 || base == 1.0) return Double.NaN\n    return nativeMath.log(x) / nativeMath.log(base)\n}\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Double): Double = nativeMath.log(x)\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Double): Double = nativeMath.log10(x)\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Double): Double = nativeMath.log2(x)\n\n/**\n * Computes `ln(x + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Double): Double = nativeMath.log1p(x)\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest double value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Double): Double = nativeMath.ceil(x).unsafeCast<Double>() // TODO: Remove unsafe cast after removing public js.math\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest double value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Double): Double = nativeMath.floor(x).unsafeCast<Double>()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Double): Double = nativeMath.trunc(x)\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun round(x: Double): Double {\n    if (x % 0.5 != 0.0) {\n        return nativeMath.round(x).unsafeCast<Double>()\n    }\n    val floor = floor(x)\n    return if (floor % 2 == 0.0) floor else ceil(x)\n}\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Double]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Double): Double = nativeMath.abs(x)\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Double): Double = nativeMath.sign(x)\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Double, b: Double): Double = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Double, b: Double): Double = nativeMath.max(a, b)\n\n// extensions\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(x: Double): Double = nativeMath.pow(this, x)\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(n: Int): Double = nativeMath.pow(this, n.toDouble())\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.absoluteValue: Double get() = nativeMath.abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.sign: Double get() = nativeMath.sign(this)\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.withSign(sign: Int): Double = this.withSign(sign.toDouble())\n\n/**\n * Returns the ulp (unit in the last place) of this value.\n *\n * An ulp is a positive distance between this value and the next nearest [Double] value larger in magnitude.\n *\n * Special Cases:\n *   - `NaN.ulp` is `NaN`\n *   - `x.ulp` is `+Inf` when `x` is `+Inf` or `-Inf`\n *   - `0.0.ulp` is `Double.MIN_VALUE`\n */\n@SinceKotlin(\"1.2\")\npublic actual val Double.ulp: Double get() = when {\n    this < 0 -> (-this).ulp\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == Double.MAX_VALUE -> this - this.nextDown()\n    else -> this.nextUp() - this\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of positive infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextUp(): Double = when {\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == 0.0 -> Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) 1 else -1)\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of negative infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextDown(): Double = when {\n    this.isNaN() || this == Double.NEGATIVE_INFINITY -> this\n    this == 0.0 -> -Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) -1 else 1)\n}\n\n\n/**\n * Returns the [Double] value nearest to this value in direction from this value towards the value [to].\n *\n * Special cases:\n *   - `x.nextTowards(y)` is `NaN` if either `x` or `y` are `NaN`\n *   - `x.nextTowards(x) == x`\n *\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextTowards(to: Double): Double = when {\n    this.isNaN() || to.isNaN() -> Double.NaN\n    to == this -> to\n    to > this -> this.nextUp()\n    else /* to < this */ -> this.nextDown()\n}\n\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToInt(): Int = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Int.MAX_VALUE -> Int.MAX_VALUE\n    this < Int.MIN_VALUE -> Int.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toInt()\n}\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToLong(): Long = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Long.MAX_VALUE -> Long.MAX_VALUE\n    this < Long.MIN_VALUE -> Long.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toLong()\n}\n\n// endregion\n\n\n\n// region ================ Float Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Float): Float = nativeMath.sin(x.toDouble()).toFloat()\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Float): Float = nativeMath.cos(x.toDouble()).toFloat()\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Float): Float = nativeMath.tan(x.toDouble()).toFloat()\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Float): Float = nativeMath.asin(x.toDouble()).toFloat()\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Float): Float = nativeMath.acos(x.toDouble()).toFloat()\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Float): Float = nativeMath.atan(x.toDouble()).toFloat()\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Float, x: Float): Float = nativeMath.atan2(y.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Float): Float = nativeMath.sinh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Float): Float = nativeMath.cosh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Float): Float = nativeMath.tanh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Float): Float = nativeMath.asinh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Float): Float = nativeMath.acosh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Float): Float = nativeMath.atanh(x.toDouble()).toFloat()\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Float, y: Float): Float = nativeMath.hypot(x.toDouble(), y.toDouble()).toFloat()\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Float): Float = nativeMath.sqrt(x.toDouble()).toFloat()\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Float): Float = nativeMath.exp(x.toDouble()).toFloat()\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Float): Float = nativeMath.expm1(x.toDouble()).toFloat()\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log(x: Float, base: Float): Float = log(x.toDouble(), base.toDouble()).toFloat()\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Float): Float = nativeMath.log(x.toDouble()).toFloat()\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Float): Float = nativeMath.log10(x.toDouble()).toFloat()\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Float): Float = nativeMath.log2(x.toDouble()).toFloat()\n\n/**\n * Computes `ln(a + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Float): Float = nativeMath.log1p(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest Float value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Float): Float = nativeMath.ceil(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest Float value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Float): Float = nativeMath.floor(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Float): Float = truncate(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun round(x: Float): Float = round(x.toDouble()).toFloat()\n\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Float]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Float): Float = nativeMath.abs(x.toDouble()).toFloat()\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Float): Float = nativeMath.sign(x.toDouble()).toFloat()\n\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Float, b: Float): Float = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Float, b: Float): Float = nativeMath.max(a, b)\n\n// extensions\n\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(x: Float): Float = nativeMath.pow(this.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(n: Int): Float = nativeMath.pow(this.toDouble(), n.toDouble()).toFloat()\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.absoluteValue: Float get() = nativeMath.abs(this.toDouble()).toFloat()\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.sign: Float get() = nativeMath.sign(this.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Float): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Int): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToInt(): Int = toDouble().roundToInt()\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToLong(): Long = toDouble().roundToLong()\n\n\n// endregion\n\n// region ================ Integer Math ========================================\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Int]\n */\n// TODO: remove manual 'or' when KT-19290 is fixed\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Int): Int = if (n < 0) (-n or 0) else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Int, b: Int): Int = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Int, b: Int): Int = nativeMath.max(a, b)\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Int.MIN_VALUE.absoluteValue` is `Int.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Int.absoluteValue: Int get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Int.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Long]\n */\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Long): Long = if (n < 0) -n else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun min(a: Long, b: Long): Long = if (a <= b) a else b\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun max(a: Long, b: Long): Long = if (a >= b) a else b\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Long.MIN_VALUE.absoluteValue` is `Long.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Long.absoluteValue: Long get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Long.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n// endregion\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n\n/**\n * Returns a bit representation of the specified floating-point value as [Long]\n * according to the IEEE 754 floating-point \"double format\" bit layout.\n */\n@SinceKotlin(\"1.2\")\n@library(\"doubleToBits\")\npublic actual fun Double.toBits(): Long = definedExternally\n\n/**\n * Returns a bit representation of the specified floating-point value as [Long]\n * according to the IEEE 754 floating-point \"double format\" bit layout,\n * preserving `NaN` values exact layout.\n */\n@SinceKotlin(\"1.2\")\n@library(\"doubleToRawBits\")\npublic actual fun Double.toRawBits(): Long = definedExternally\n\n/**\n * Returns the [Double] value corresponding to a given bit representation.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Double.Companion.fromBits(bits: Long): Double = js(\"Kotlin\").doubleFromBits(bits).unsafeCast<Double>()\n\n/**\n * Returns a bit representation of the specified floating-point value as [Int]\n * according to the IEEE 754 floating-point \"single format\" bit layout.\n *\n * Note that in Kotlin/JS [Float] range is wider than \"single format\" bit layout can represent,\n * so some [Float] values may overflow, underflow or loose their accuracy after conversion to bits and back.\n */\n@SinceKotlin(\"1.2\")\n@library(\"floatToBits\")\npublic actual fun Float.toBits(): Int = definedExternally\n\n/**\n * Returns a bit representation of the specified floating-point value as [Int]\n * according to the IEEE 754 floating-point \"single format\" bit layout,\n * preserving `NaN` values exact layout.\n *\n * Note that in Kotlin/JS [Float] range is wider than \"single format\" bit layout can represent,\n * so some [Float] values may overflow, underflow or loose their accuracy after conversion to bits and back.\n */\n@SinceKotlin(\"1.2\")\n@library(\"floatToRawBits\")\npublic actual fun Float.toRawBits(): Int = definedExternally\n\n/**\n * Returns the [Float] value corresponding to a given bit representation.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Float.Companion.fromBits(bits: Int): Float = js(\"Kotlin\").floatFromBits(bits).unsafeCast<Float>()\n\n\ninternal inline fun Long(low: Int, high: Int) = js(\"Kotlin\").Long.fromBits(low, high).unsafeCast<Long>()\ninternal inline val Long.low: Int get() = this.asDynamic().getLowBits().unsafeCast<Int>()\ninternal inline val Long.high: Int get() = this.asDynamic().getHighBits().unsafeCast<Int>()","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n/**\n * Returns `true` if the specified number is a\n * Not-a-Number (NaN) value, `false` otherwise.\n */\npublic actual fun Double.isNaN(): Boolean = this != this\n\n/**\n * Returns `true` if the specified number is a\n * Not-a-Number (NaN) value, `false` otherwise.\n */\npublic actual fun Float.isNaN(): Boolean = this != this\n\n/**\n * Returns `true` if this value is infinitely large in magnitude.\n */\npublic actual fun Double.isInfinite(): Boolean = this == Double.POSITIVE_INFINITY || this == Double.NEGATIVE_INFINITY\n\n/**\n * Returns `true` if this value is infinitely large in magnitude.\n */\npublic actual fun Float.isInfinite(): Boolean = this == Float.POSITIVE_INFINITY || this == Float.NEGATIVE_INFINITY\n\n/**\n * Returns `true` if the argument is a finite floating-point value; returns `false` otherwise (for `NaN` and infinity arguments).\n */\npublic actual fun Double.isFinite(): Boolean = !isInfinite() && !isNaN()\n\n/**\n * Returns `true` if the argument is a finite floating-point value; returns `false` otherwise (for `NaN` and infinity arguments).\n */\npublic actual fun Float.isFinite(): Boolean = !isInfinite() && !isNaN()\n\n\n/**\n * Counts the number of set bits in the binary representation of this [Int] number.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun Int.countOneBits(): Int {\n    // Hacker's Delight 5-1 algorithm\n    var v = this\n    v = (v and 0x55555555) + (v.ushr(1) and 0x55555555)\n    v = (v and 0x33333333) + (v.ushr(2) and 0x33333333)\n    v = (v and 0x0F0F0F0F) + (v.ushr(4) and 0x0F0F0F0F)\n    v = (v and 0x00FF00FF) + (v.ushr(8) and 0x00FF00FF)\n    v = (v and 0x0000FFFF) + (v.ushr(16))\n    return v\n}\n\n/**\n * Counts the number of consecutive most significant bits that are zero in the binary representation of this [Int] number.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@Suppress(\"DEPRECATION\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Int.countLeadingZeroBits(): Int = kotlin.js.Math.clz32(this)\n\n/**\n * Counts the number of consecutive least significant bits that are zero in the binary representation of this [Int] number.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun Int.countTrailingZeroBits(): Int =\n    // Hacker's Delight 5-4 algorithm for expressing countTrailingZeroBits with countLeadingZeroBits\n    Int.SIZE_BITS - (this or -this).inv().countLeadingZeroBits()\n\n/**\n * Returns a number having a single bit set in the position of the most significant set bit of this [Int] number,\n * or zero, if this number is zero.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun Int.takeHighestOneBit(): Int =\n    if (this == 0) 0 else 1.shl(Int.SIZE_BITS - 1 - countLeadingZeroBits())\n\n/**\n * Returns a number having a single bit set in the position of the least significant set bit of this [Int] number,\n * or zero, if this number is zero.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun Int.takeLowestOneBit(): Int =\n    // Hacker's Delight 2-1 algorithm for isolating rightmost 1-bit\n    this and -this\n\n/**\n * Rotates the binary representation of this [Int] number left by the specified [bitCount] number of bits.\n * The most significant bits pushed out from the left side reenter the number as the least significant bits on the right side.\n *\n * Rotating the number left by a negative bit count is the same as rotating it right by the negated bit count:\n * `number.rotateLeft(-n) == number.rotateRight(n)`\n *\n * Rotating by a multiple of [Int.SIZE_BITS] (32) returns the same number, or more generally\n * `number.rotateLeft(n) == number.rotateLeft(n % 32)`\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun Int.rotateLeft(bitCount: Int): Int =\n    shl(bitCount) or ushr(Int.SIZE_BITS - bitCount)\n\n\n/**\n * Rotates the binary representation of this [Int] number right by the specified [bitCount] number of bits.\n * The least significant bits pushed out from the right side reenter the number as the most significant bits on the left side.\n *\n * Rotating the number right by a negative bit count is the same as rotating it left by the negated bit count:\n * `number.rotateRight(-n) == number.rotateLeft(n)`\n *\n * Rotating by a multiple of [Int.SIZE_BITS] (32) returns the same number, or more generally\n * `number.rotateRight(n) == number.rotateRight(n % 32)`\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun Int.rotateRight(bitCount: Int): Int =\n    shl(Int.SIZE_BITS - bitCount) or ushr(bitCount)\n\n\n/**\n * Counts the number of set bits in the binary representation of this [Long] number.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun Long.countOneBits(): Int =\n    high.countOneBits() + low.countOneBits()\n\n/**\n * Counts the number of consecutive most significant bits that are zero in the binary representation of this [Long] number.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun Long.countLeadingZeroBits(): Int =\n    when (val high = this.high) {\n        0 -> Int.SIZE_BITS + low.countLeadingZeroBits()\n        else -> high.countLeadingZeroBits()\n    }\n\n/**\n * Counts the number of consecutive least significant bits that are zero in the binary representation of this [Long] number.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun Long.countTrailingZeroBits(): Int =\n    when (val low = this.low) {\n        0 -> Int.SIZE_BITS + high.countTrailingZeroBits()\n        else -> low.countTrailingZeroBits()\n    }\n\n/**\n * Returns a number having a single bit set in the position of the most significant set bit of this [Long] number,\n * or zero, if this number is zero.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun Long.takeHighestOneBit(): Long =\n    when (val high = this.high) {\n        0 -> Long(low.takeHighestOneBit(), 0)\n        else -> Long(0, high.takeHighestOneBit())\n    }\n\n/**\n * Returns a number having a single bit set in the position of the least significant set bit of this [Long] number,\n * or zero, if this number is zero.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun Long.takeLowestOneBit(): Long =\n    when (val low = this.low) {\n        0 -> Long(0, high.takeLowestOneBit())\n        else -> Long(low.takeLowestOneBit(), 0)\n    }\n\n/**\n * Rotates the binary representation of this [Long] number left by the specified [bitCount] number of bits.\n * The most significant bits pushed out from the left side reenter the number as the least significant bits on the right side.\n *\n * Rotating the number left by a negative bit count is the same as rotating it right by the negated bit count:\n * `number.rotateLeft(-n) == number.rotateRight(n)`\n *\n * Rotating by a multiple of [Long.SIZE_BITS] (64) returns the same number, or more generally\n * `number.rotateLeft(n) == number.rotateLeft(n % 64)`\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun Long.rotateLeft(bitCount: Int): Long {\n    if ((bitCount and 31) != 0) {\n        val low = this.low\n        val high = this.high\n        val newLow = low.shl(bitCount) or high.ushr(-bitCount)\n        val newHigh = high.shl(bitCount) or low.ushr(-bitCount)\n        return if ((bitCount and 32) == 0) Long(newLow, newHigh) else Long(newHigh, newLow)\n    } else {\n        return if ((bitCount and 32) == 0) this else Long(high, low)\n    }\n}\n\n\n/**\n * Rotates the binary representation of this [Long] number right by the specified [bitCount] number of bits.\n * The least significant bits pushed out from the right side reenter the number as the most significant bits on the left side.\n *\n * Rotating the number right by a negative bit count is the same as rotating it left by the negated bit count:\n * `number.rotateRight(-n) == number.rotateLeft(n)`\n *\n * Rotating by a multiple of [Long.SIZE_BITS] (64) returns the same number, or more generally\n * `number.rotateRight(n) == number.rotateRight(n % 64)`\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic actual inline fun Long.rotateRight(bitCount: Int): Long = rotateLeft(-bitCount)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.random\n\nimport kotlin.math.pow\n\ninternal actual fun defaultPlatformRandom(): Random =\n    Random(js(\"(Math.random() * Math.pow(2, 32)) | 0\").unsafeCast<Int>())\n\n\nprivate val INV_2_26: Double = 2.0.pow(-26)\nprivate val INV_2_53: Double = 2.0.pow(-53)\ninternal actual fun doubleFromParts(hi26: Int, low27: Int): Double =\n    hi26 * INV_2_26 + low27 * INV_2_53","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.js\n\nimport getKClass\nimport kotlin.reflect.KClass\nimport kotlin.reflect.js.internal.KClassImpl\n\n/**\n * Represents the constructor of a class. Instances of `JsClass` can be passed to JavaScript APIs that expect a constructor reference.\n */\nexternal interface JsClass<T : Any> {\n    /**\n     * Returns the unqualified name of the class represented by this instance.\n     */\n    val name: String\n}\n\n@Deprecated(\"Use class literal and extension property `js` instead.\", replaceWith = ReplaceWith(\"T::class.js\"), level = DeprecationLevel.ERROR)\nexternal fun <T : Any> jsClass(): JsClass<T>\n\n@Deprecated(\"Use class literal and extension property `js` instead.\", replaceWith = ReplaceWith(\"this::class.js\"), level = DeprecationLevel.ERROR)\nval <T : Any> T.jsClass: JsClass<T>\n    get() = when (jsTypeOf(this)) {\n        \"string\" -> js(\"String\")\n        \"number\" -> js(\"Number\")\n        \"boolean\" -> js(\"Boolean\")\n        else -> js(\"Object\").getPrototypeOf(this).constructor\n    }\n\n/**\n * Obtains a constructor reference for the given `KClass`.\n */\nval <T : Any> KClass<T>.js: JsClass<T>\n    get() = (this as KClassImpl<T>).jClass\n\n/**\n * Obtains a `KClass` instance for the given constructor reference.\n */\nval <T : Any> JsClass<T>.kotlin: KClass<T>\n    get() = getKClass(this)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.reflect.js.internal\n\nimport kotlin.reflect.*\n\ninternal abstract class KClassImpl<T : Any>(\n    internal open val jClass: JsClass<T>\n) : KClass<T> {\n    override val annotations: List<Annotation>\n        get() = TODO()\n    override val constructors: Collection<KFunction<T>>\n        get() = TODO()\n    override val isAbstract: Boolean\n        get() = TODO()\n    override val isCompanion: Boolean\n        get() = TODO()\n    override val isData: Boolean\n        get() = TODO()\n    override val isFinal: Boolean\n        get() = TODO()\n    override val isInner: Boolean\n        get() = TODO()\n    override val isOpen: Boolean\n        get() = TODO()\n    override val isSealed: Boolean\n        get() = TODO()\n    override val members: Collection<KCallable<*>>\n        get() = TODO()\n    override val nestedClasses: Collection<KClass<*>>\n        get() = TODO()\n    override val objectInstance: T?\n        get() = TODO()\n    override val qualifiedName: String?\n        get() = TODO()\n    override val supertypes: List<KType>\n        get() = TODO()\n    override val typeParameters: List<KTypeParameter>\n        get() = TODO()\n    override val sealedSubclasses: List<KClass<out T>>\n        get() = TODO()\n    override val visibility: KVisibility?\n        get() = TODO()\n\n    override fun equals(other: Any?): Boolean {\n        return other is KClassImpl<*> && jClass == other.jClass\n    }\n\n    // TODO: use FQN\n    override fun hashCode(): Int = simpleName?.hashCode() ?: 0\n\n    override fun toString(): String {\n        // TODO: use FQN\n        return \"class $simpleName\"\n    }\n}\n\ninternal class SimpleKClassImpl<T : Any>(jClass: JsClass<T>) : KClassImpl<T>(jClass) {\n    override val simpleName: String? = jClass.asDynamic().`$metadata$`?.simpleName.unsafeCast<String?>()\n\n    override fun isInstance(value: Any?): Boolean {\n        return jsIsType(value, jClass)\n    }\n}\n\ninternal class PrimitiveKClassImpl<T : Any>(\n    jClass: JsClass<T>,\n    private val givenSimpleName: String,\n    private val isInstanceFunction: (Any?) -> Boolean\n) : KClassImpl<T>(jClass) {\n    override fun equals(other: Any?): Boolean {\n        if (other !is PrimitiveKClassImpl<*>) return false\n        return super.equals(other) && givenSimpleName == other.givenSimpleName\n    }\n\n    override val simpleName: String? get() = givenSimpleName\n\n    override fun isInstance(value: Any?): Boolean {\n        return isInstanceFunction(value)\n    }\n}\n\ninternal object NothingKClassImpl : KClassImpl<Nothing>(js(\"Object\")) {\n    override val simpleName: String = \"Nothing\"\n\n    override fun isInstance(value: Any?): Boolean = false\n\n    override val jClass: JsClass<Nothing>\n        get() = throw UnsupportedOperationException(\"There's no native JS class for Nothing type\")\n\n    override fun equals(other: Any?): Boolean = other === this\n\n    override fun hashCode(): Int = 0\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n/**\n * The common interface of [InternalStringMap] and [InternalHashCodeMap].\n */\ninternal interface InternalMap<K, V> : MutableIterable<MutableMap.MutableEntry<K, V>> {\n    val equality: EqualityComparator\n    val size: Int\n    operator fun contains(key: K): Boolean\n    operator fun get(key: K): V?\n\n    fun put(key: K, value: V): V?\n    fun remove(key: K): V?\n    fun clear(): Unit\n\n    fun createJsMap(): dynamic {\n        val result = js(\"Object.create(null)\")\n        // force to switch object representation to dictionary mode\n        result[\"foo\"] = 1\n        jsDeleteProperty(result, \"foo\")\n        return result\n    }\n}\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n\n@file:Suppress(\"UNUSED_PARAMETER\")\n\npackage kotlin.js\n\n@kotlin.internal.InlineOnly\ninternal inline fun jsDeleteProperty(obj: Any, property: Any) {\n    js(\"delete obj[property]\")\n}\n\n@kotlin.internal.InlineOnly\ninternal inline fun jsBitwiseOr(lhs: Any?, rhs: Any?): Int =\n    js(\"lhs | rhs\").unsafeCast<Int>()","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n/**\n * Converts the characters in the specified array to a string.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun String(chars: CharArray): String {\n    var result = \"\"\n    for (char in chars) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Converts the characters from a portion of the specified array to a string.\n *\n * @throws IndexOutOfBoundsException if either [offset] or [length] are less than zero\n * or `offset + length` is out of [chars] array bounds.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun String(chars: CharArray, offset: Int, length: Int): String {\n    if (offset < 0 || length < 0 || chars.size - offset < length)\n        throw IndexOutOfBoundsException(\"size: ${chars.size}; offset: $offset; length: $length\")\n    var result = \"\"\n    for (index in offset until offset + length) {\n        result += chars[index]\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] into a String.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun CharArray.concatToString(): String {\n    var result = \"\"\n    for (char in this) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] or its subrange into a String.\n *\n * @param startIndex the beginning (inclusive) of the subrange of characters, 0 by default.\n * @param endIndex the end (exclusive) of the subrange of characters, size of this array by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n@ExperimentalStdlibApi\npublic actual fun CharArray.concatToString(startIndex: Int = 0, endIndex: Int = this.size): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    var result = \"\"\n    for (index in startIndex until endIndex) {\n        result += this[index]\n    }\n    return result\n}\n\n/**\n * Returns a [CharArray] containing characters of this string.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun String.toCharArray(): CharArray {\n    return CharArray(length) { get(it) }\n}\n\n/**\n * Returns a [CharArray] containing characters of this string or its substring.\n *\n * @param startIndex the beginning (inclusive) of the substring, 0 by default.\n * @param endIndex the end (exclusive) of the substring, length of this string by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n@ExperimentalStdlibApi\npublic actual fun String.toCharArray(startIndex: Int = 0, endIndex: Int = this.length): CharArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return CharArray(endIndex - startIndex) { get(startIndex + it) }\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array.\n *\n * Malformed byte sequences are replaced by the replacement char `\\uFFFD`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun ByteArray.decodeToString(): String {\n    return decodeUtf8(this, 0, size, false)\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array or its subrange.\n *\n * @param startIndex the beginning (inclusive) of the subrange to decode, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to decode, size of this array by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed byte sequence or replace it by the replacement char `\\uFFFD`.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if the byte array contains malformed UTF-8 byte sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n@ExperimentalStdlibApi\npublic actual fun ByteArray.decodeToString(\n    startIndex: Int = 0,\n    endIndex: Int = this.size,\n    throwOnInvalidSequence: Boolean = false\n): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    return decodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Encodes this string to an array of bytes in UTF-8 encoding.\n *\n * Any malformed char sequence is replaced by the replacement byte sequence.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun String.encodeToByteArray(): ByteArray {\n    return encodeUtf8(this, 0, length, false)\n}\n\n/**\n * Encodes this string or its substring to an array of bytes in UTF-8 encoding.\n *\n * @param startIndex the beginning (inclusive) of the substring to encode, 0 by default.\n * @param endIndex the end (exclusive) of the substring to encode, length of this string by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed char sequence or replace.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if this string contains malformed char sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n@ExperimentalStdlibApi\npublic actual fun String.encodeToByteArray(\n    startIndex: Int = 0,\n    endIndex: Int = this.length,\n    throwOnInvalidSequence: Boolean = false\n): ByteArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return encodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Returns a copy of this string converted to upper case using the rules of the default locale.\n *\n * @sample samples.text.Strings.toUpperCase\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toUpperCase(): String = asDynamic().toUpperCase()\n\n/**\n * Returns a copy of this string converted to lower case using the rules of the default locale.\n *\n * @sample samples.text.Strings.toLowerCase\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toLowerCase(): String = asDynamic().toLowerCase()\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeIndexOf(str: String, fromIndex: Int): Int = asDynamic().indexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeLastIndexOf(str: String, fromIndex: Int): Int = asDynamic().lastIndexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeStartsWith(s: String, position: Int): Boolean = asDynamic().startsWith(s, position)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeEndsWith(s: String): Boolean = asDynamic().endsWith(s)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int): String = asDynamic().substring(startIndex)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int, endIndex: Int): String = asDynamic().substring(startIndex, endIndex)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.concat(str: String): String = asDynamic().concat(str)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.match(regex: String): Array<String>? = asDynamic().match(regex)\n\n//native public fun String.trim(): String\n//TODO: String.replace to implement effective trimLeading and trimTrailing\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeReplace(pattern: RegExp, replacement: String): String = asDynamic().replace(pattern, replacement)\n\n@SinceKotlin(\"1.2\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.compareTo(other: String, ignoreCase: Boolean = false): Int {\n    if (ignoreCase) {\n        val n1 = this.length\n        val n2 = other.length\n        val min = minOf(n1, n2)\n        if (min == 0) return n1 - n2\n        var start = 0\n        while (true) {\n            val end = minOf(start + 16, min)\n            var s1 = this.substring(start, end)\n            var s2 = other.substring(start, end)\n            if (s1 != s2) {\n                s1 = s1.toUpperCase()\n                s2 = s2.toUpperCase()\n                if (s1 != s2) {\n                    s1 = s1.toLowerCase()\n                    s2 = s2.toLowerCase()\n                    if (s1 != s2) {\n                        return s1.compareTo(s2)\n                    }\n                }\n            }\n            if (end == min) break\n            start = end\n        }\n        return n1 - n2\n    } else {\n        return compareTo(other)\n    }\n}\n\n\nprivate val STRING_CASE_INSENSITIVE_ORDER = Comparator<String> { a, b -> a.compareTo(b, ignoreCase = true) }\n\n@SinceKotlin(\"1.2\")\npublic actual val String.Companion.CASE_INSENSITIVE_ORDER: Comparator<String>\n    get() = STRING_CASE_INSENSITIVE_ORDER\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.reflect.js.internal\n\nimport kotlin.js.JsClass\n\n@JsName(\"PrimitiveClasses\")\ninternal object PrimitiveClasses {\n    @JsName(\"anyClass\")\n    val anyClass = PrimitiveKClassImpl(js(\"Object\").unsafeCast<JsClass<Any>>(), \"Any\", { it is Any })\n\n    @JsName(\"numberClass\")\n    val numberClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Number>>(), \"Number\", { it is Number })\n\n    @JsName(\"nothingClass\")\n    val nothingClass = NothingKClassImpl\n\n    @JsName(\"booleanClass\")\n    val booleanClass = PrimitiveKClassImpl(js(\"Boolean\").unsafeCast<JsClass<Boolean>>(), \"Boolean\", { it is Boolean })\n\n    @JsName(\"byteClass\")\n    val byteClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Byte>>(), \"Byte\", { it is Byte })\n\n    @JsName(\"shortClass\")\n    val shortClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Short>>(), \"Short\", { it is Short })\n\n    @JsName(\"intClass\")\n    val intClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Int>>(), \"Int\", { it is Int })\n\n    @JsName(\"floatClass\")\n    val floatClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Float>>(), \"Float\", { it is Float })\n\n    @JsName(\"doubleClass\")\n    val doubleClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Double>>(), \"Double\", { it is Double })\n\n    @JsName(\"arrayClass\")\n    val arrayClass = PrimitiveKClassImpl(js(\"Array\").unsafeCast<JsClass<Array<*>>>(), \"Array\", { it is Array<*> })\n\n    @JsName(\"stringClass\")\n    val stringClass = PrimitiveKClassImpl(js(\"String\").unsafeCast<JsClass<String>>(), \"String\", { it is String })\n\n    @JsName(\"throwableClass\")\n    val throwableClass = PrimitiveKClassImpl(js(\"Error\").unsafeCast<JsClass<Throwable>>(), \"Throwable\", { it is Throwable })\n\n    @JsName(\"booleanArrayClass\")\n    val booleanArrayClass = PrimitiveKClassImpl(js(\"Array\").unsafeCast<JsClass<BooleanArray>>(), \"BooleanArray\", { it is BooleanArray })\n\n    @JsName(\"charArrayClass\")\n    val charArrayClass = PrimitiveKClassImpl(js(\"Uint16Array\").unsafeCast<JsClass<CharArray>>(), \"CharArray\", { it is CharArray })\n\n    @JsName(\"byteArrayClass\")\n    val byteArrayClass = PrimitiveKClassImpl(js(\"Int8Array\").unsafeCast<JsClass<ByteArray>>(), \"ByteArray\", { it is ByteArray })\n\n    @JsName(\"shortArrayClass\")\n    val shortArrayClass = PrimitiveKClassImpl(js(\"Int16Array\").unsafeCast<JsClass<ShortArray>>(), \"ShortArray\", { it is ShortArray })\n\n    @JsName(\"intArrayClass\")\n    val intArrayClass = PrimitiveKClassImpl(js(\"Int32Array\").unsafeCast<JsClass<IntArray>>(), \"IntArray\", { it is IntArray })\n\n    @JsName(\"longArrayClass\")\n    val longArrayClass = PrimitiveKClassImpl(js(\"Array\").unsafeCast<JsClass<LongArray>>(), \"LongArray\", { it is LongArray })\n\n    @JsName(\"floatArrayClass\")\n    val floatArrayClass = PrimitiveKClassImpl(js(\"Float32Array\").unsafeCast<JsClass<FloatArray>>(), \"FloatArray\", { it is FloatArray })\n\n    @JsName(\"doubleArrayClass\")\n    val doubleArrayClass = PrimitiveKClassImpl(js(\"Float64Array\").unsafeCast<JsClass<DoubleArray>>(), \"DoubleArray\", { it is DoubleArray })\n\n    @JsName(\"functionClass\")\n    fun functionClass(arity: Int): KClassImpl<Any> {\n        return functionClasses.get(arity) ?: run {\n            val result = PrimitiveKClassImpl(js(\"Function\").unsafeCast<JsClass<Any>>(), \"Function$arity\",\n                                             { jsTypeOf(it) === \"function\" && it.asDynamic().length === arity })\n            functionClasses.asDynamic()[arity] = result\n            result\n        }\n    }\n}\n\nprivate val functionClasses = arrayOfNulls<KClassImpl<Any>>(0)","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// a package is omitted to get declarations directly under the module\n\nimport kotlin.reflect.*\nimport kotlin.reflect.js.internal.*\n\n@JsName(\"getKClass\")\ninternal fun <T : Any> getKClass(jClass: JsClass<T>): KClass<T> = getOrCreateKClass(jClass)\n\n@JsName(\"getKClassFromExpression\")\ninternal fun <T : Any> getKClassFromExpression(e: T): KClass<T> =\n    when (jsTypeOf(e)) {\n        \"string\" -> PrimitiveClasses.stringClass\n        \"number\" -> if (jsBitwiseOr(e, 0).asDynamic() === e) PrimitiveClasses.intClass else PrimitiveClasses.doubleClass\n        \"boolean\" -> PrimitiveClasses.booleanClass\n        \"function\" -> PrimitiveClasses.functionClass(e.asDynamic().length)\n        else -> {\n            when {\n                e is BooleanArray -> PrimitiveClasses.booleanArrayClass\n                e is CharArray -> PrimitiveClasses.charArrayClass\n                e is ByteArray -> PrimitiveClasses.byteArrayClass\n                e is ShortArray -> PrimitiveClasses.shortArrayClass\n                e is IntArray -> PrimitiveClasses.intArrayClass\n                e is LongArray -> PrimitiveClasses.longArrayClass\n                e is FloatArray -> PrimitiveClasses.floatArrayClass\n                e is DoubleArray -> PrimitiveClasses.doubleArrayClass\n                e is KClass<*> -> KClass::class\n                e is Array<*> -> PrimitiveClasses.arrayClass\n                else -> {\n                    val constructor = js(\"Object\").getPrototypeOf(e).constructor\n                    when {\n                        constructor === js(\"Object\") -> PrimitiveClasses.anyClass\n                        constructor === js(\"Error\") -> PrimitiveClasses.throwableClass\n                        else -> {\n                            val jsClass: JsClass<T> = constructor\n                            getOrCreateKClass(jsClass)\n                        }\n                    }\n                }\n            }\n        }\n    }.unsafeCast<KClass<T>>()\n\nprivate fun <T : Any> getOrCreateKClass(jClass: JsClass<T>): KClass<T> {\n    if (jClass === js(\"String\")) return PrimitiveClasses.stringClass.unsafeCast<KClass<T>>()\n\n    val metadata = jClass.asDynamic().`$metadata$`\n\n    return if (metadata != null) {\n        if (metadata.`$kClass$` == null) {\n            val kClass = SimpleKClassImpl(jClass)\n            metadata.`$kClass$` = kClass\n            kClass\n        } else {\n            metadata.`$kClass$`\n        }\n    } else {\n        SimpleKClassImpl(jClass)\n    }\n}\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n/**\n * A mutable sequence of characters.\n *\n * String builder can be used to efficiently perform multiple string manipulation operations.\n */\npublic actual class StringBuilder actual constructor(content: String) : Appendable, CharSequence {\n    /**\n     * Constructs an empty string builder with the specified initial [capacity].\n     *\n     * In Kotlin/JS implementation of StringBuilder the initial capacity has no effect on the further performance of operations.\n     */\n    actual constructor(capacity: Int) : this() {\n        this.asDynamic()._capacity = capacity\n    }\n\n    /** Constructs a string builder that contains the same characters as the specified [content] char sequence. */\n    actual constructor(content: CharSequence) : this(content.toString()) {}\n\n    /** Constructs an empty string builder. */\n    actual constructor() : this(\"\")\n\n    private var string: String = if (content !== undefined) content else \"\"\n\n    actual override val length: Int\n        get() = string.asDynamic().length\n\n    actual override fun get(index: Int): Char =\n        string.getOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, length: $length}\") }\n\n    actual override fun subSequence(startIndex: Int, endIndex: Int): CharSequence = string.substring(startIndex, endIndex)\n\n    actual override fun append(value: Char): StringBuilder {\n        string += value\n        return this\n    }\n\n    actual override fun append(value: CharSequence?): StringBuilder {\n        string += value.toString()\n        return this\n    }\n\n    @UseExperimental(ExperimentalStdlibApi::class)\n    actual override fun append(value: CharSequence?, startIndex: Int, endIndex: Int): StringBuilder = this.appendRange(value, startIndex, endIndex)\n\n    /**\n     * Reverses the contents of this string builder and returns this instance.\n     *\n     * Surrogate pairs included in this string builder are treated as single characters.\n     * Therefore, the order of the high-low surrogates is never reversed.\n     *\n     * Note that the reverse operation may produce new surrogate pairs that were unpaired low-surrogates and high-surrogates before the operation.\n     * For example, reversing `\"\\uDC00\\uD800\"` produces `\"\\uD800\\uDC00\"` which is a valid surrogate pair.\n     */\n    actual fun reverse(): StringBuilder {\n        var reversed = \"\"\n        var index = string.length - 1\n        while (index >= 0) {\n            val low = string[index--]\n            if (low.isLowSurrogate() && index >= 0) {\n                val high = string[index--]\n                if (high.isHighSurrogate()) {\n                    reversed = reversed + high + low\n                } else {\n                    reversed = reversed + low + high\n                }\n            } else {\n                reversed += low\n            }\n        }\n        string = reversed\n        return this\n    }\n\n    /**\n     * Appends the string representation of the specified object [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    actual fun append(value: Any?): StringBuilder {\n        string += value.toString()\n        return this\n    }\n\n    /**\n     * Appends the string representation of the specified boolean [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n//    @ExperimentalStdlibApi\n    actual fun append(value: Boolean): StringBuilder {\n        string += value\n        return this\n    }\n\n    /**\n     * Appends characters in the specified character array [value] to this string builder and returns this instance.\n     *\n     * Characters are appended in order, starting at the index 0.\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    actual fun append(value: CharArray): StringBuilder {\n        string += value.concatToString()\n        return this\n    }\n\n    /**\n     * Appends the specified string [value] to this string builder and returns this instance.\n     */\n    @SinceKotlin(\"1.3\")\n//    @ExperimentalStdlibApi\n    actual fun append(value: String): StringBuilder {\n        this.string += value\n        return this\n    }\n\n    /**\n     * Returns the current capacity of this string builder.\n     *\n     * The capacity is the maximum length this string builder can have before an allocation occurs.\n     *\n     * In Kotlin/JS implementation of StringBuilder the value returned from this method may not indicate the actual size of the backing storage.\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    actual fun capacity(): Int = if (this.asDynamic()._capacity !== undefined) maxOf(this.asDynamic()._capacity, length) else length\n\n    /**\n     * Ensures that the capacity of this string builder is at least equal to the specified [minimumCapacity].\n     *\n     * If the current capacity is less than the [minimumCapacity], a new backing storage is allocated with greater capacity.\n     * Otherwise, this method takes no action and simply returns.\n     *\n     * In Kotlin/JS implementation of StringBuilder the size of the backing storage is not extended to comply the given [minimumCapacity],\n     * thus calling this method has no effect on the further performance of operations.\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    actual fun ensureCapacity(minimumCapacity: Int) {\n        if (minimumCapacity > capacity()) {\n            this.asDynamic()._capacity = minimumCapacity\n        }\n    }\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    actual fun indexOf(string: String): Int = this.string.asDynamic().indexOf(string)\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string],\n     * starting at the specified [startIndex].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    actual fun indexOf(string: String, startIndex: Int): Int = this.string.asDynamic().indexOf(string, startIndex)\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string].\n     * The last occurrence of empty string `\"\"` is considered to be at the index equal to `this.length`.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    actual fun lastIndexOf(string: String): Int = this.string.asDynamic().lastIndexOf(string)\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string],\n     * starting from the specified [startIndex] toward the beginning.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    actual fun lastIndexOf(string: String, startIndex: Int): Int {\n        if (string.isEmpty() && startIndex < 0) return -1\n        return this.string.asDynamic().lastIndexOf(string, startIndex)\n    }\n\n    /**\n     * Inserts the string representation of the specified boolean [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    actual fun insert(index: Int, value: Boolean): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        string = string.substring(0, index) + value + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts the specified character [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    actual fun insert(index: Int, value: Char): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        string = string.substring(0, index) + value + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts characters in the specified character array [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in same order as in the [value] character array, starting at [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    actual fun insert(index: Int, value: CharArray): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        string = string.substring(0, index) + value.concatToString() + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts characters in the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n     *\n     * @param index the position in this string builder to insert at.\n     * @param value the character sequence from which characters are inserted. If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    actual fun insert(index: Int, value: CharSequence?): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        string = string.substring(0, index) + value.toString() + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts the string representation of the specified object [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    actual fun insert(index: Int, value: Any?): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        string = string.substring(0, index) + value.toString() + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts the string [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    actual fun insert(index: Int, value: String): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        this.string = this.string.substring(0, index) + value + this.string.substring(index)\n        return this\n    }\n\n    /**\n     *  Sets the length of this string builder to the specified [newLength].\n     *\n     *  If the [newLength] is less than the current length, it is changed to the specified [newLength].\n     *  Otherwise, null characters '\\u0000' are appended to this string builder until its length is less than the [newLength].\n     *\n     *  Note that in Kotlin/JS [set] operator function has non-constant execution time complexity.\n     *  Therefore, increasing length of this string builder and then updating each character by index may slow down your program.\n     *\n     *  @throws IndexOutOfBoundsException or [IllegalArgumentException] if [newLength] is less than zero.\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    actual fun setLength(newLength: Int) {\n        if (newLength < 0) {\n            throw IllegalArgumentException(\"Negative new length: $newLength.\")\n        }\n\n        if (newLength <= length) {\n            string = string.substring(0, newLength)\n        } else {\n            for (i in length until newLength) {\n                string += '\\u0000'\n            }\n        }\n    }\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [length] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException if [startIndex] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    actual fun substring(startIndex: Int): String {\n        AbstractList.checkPositionIndex(startIndex, length)\n\n        return string.substring(startIndex)\n    }\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [endIndex] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    actual fun substring(startIndex: Int, endIndex: Int): String {\n        AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n\n        return string.substring(startIndex, endIndex)\n    }\n\n    /**\n     * Attempts to reduce storage used for this string builder.\n     *\n     * If the backing storage of this string builder is larger than necessary to hold its current contents,\n     * then it may be resized to become more space efficient.\n     * Calling this method may, but is not required to, affect the value of the [capacity] property.\n     *\n     * In Kotlin/JS implementation of StringBuilder the size of the backing storage is always equal to the length of the string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    actual fun trimToSize() {\n        if (this.asDynamic()._capacity !== undefined) {\n            this.asDynamic()._capacity = length\n        }\n    }\n\n    override fun toString(): String = string\n\n    /**\n     * Clears the content of this string builder making it empty and returns this instance.\n     *\n     * @sample samples.text.Strings.clearStringBuilder\n     */\n    @SinceKotlin(\"1.3\")\n    public fun clear(): StringBuilder {\n        string = \"\"\n        return this\n    }\n\n    /**\n     * Sets the character at the specified [index] to the specified [value].\n     *\n     * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    public operator fun set(index: Int, value: Char) {\n        AbstractList.checkElementIndex(index, length)\n\n        string = string.substring(0, index) + value + string.substring(index + 1)\n    }\n\n    /**\n     * Replaces characters in the specified range of this string builder with characters in the specified string [value] and returns this instance.\n     *\n     * @param startIndex the beginning (inclusive) of the range to replace.\n     * @param endIndex the end (exclusive) of the range to replace.\n     * @param value the string to replace with.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] if [startIndex] is less than zero, greater than the length of this string builder, or `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    public fun setRange(startIndex: Int, endIndex: Int, value: String): StringBuilder {\n        checkReplaceRange(startIndex, endIndex, length)\n\n        this.string = this.string.substring(0, startIndex) + value + this.string.substring(endIndex)\n        return this\n    }\n\n    private fun checkReplaceRange(startIndex: Int, endIndex: Int, length: Int) {\n        if (startIndex < 0 || startIndex > length) {\n            throw IndexOutOfBoundsException(\"startIndex: $startIndex, length: $length\")\n        }\n        if (startIndex > endIndex) {\n            throw IllegalArgumentException(\"startIndex($startIndex) > endIndex($endIndex)\")\n        }\n    }\n\n    /**\n     * Removes the character at the specified [index] from this string builder and returns this instance.\n     *\n     * If the `Char` at the specified [index] is part of a supplementary code point, this method does not remove the entire supplementary character.\n     *\n     * @param index the index of `Char` to remove.\n     *\n     * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    public fun deleteAt(index: Int): StringBuilder {\n        AbstractList.checkElementIndex(index, length)\n\n        string = string.substring(0, index) + string.substring(index + 1)\n        return this\n    }\n\n    /**\n     * Removes characters in the specified range from this string builder and returns this instance.\n     *\n     * @param startIndex the beginning (inclusive) of the range to remove.\n     * @param endIndex the end (exclusive) of the range to remove.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    public fun deleteRange(startIndex: Int, endIndex: Int): StringBuilder {\n        checkReplaceRange(startIndex, endIndex, length)\n\n        string = string.substring(0, startIndex) + string.substring(endIndex)\n        return this\n    }\n\n    /**\n     * Copies characters from this string builder into the [destination] character array.\n     *\n     * @param destination the array to copy to.\n     * @param destinationOffset the position in the array to copy to, 0 by default.\n     * @param startIndex the beginning (inclusive) of the range to copy, 0 by default.\n     * @param endIndex the end (exclusive) of the range to copy, length of this string builder by default.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n     * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n     *  or when that index is out of the [destination] array indices range.\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    public fun toCharArray(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = this.length) {\n        AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n        AbstractList.checkBoundsIndexes(destinationOffset, destinationOffset + endIndex - startIndex, destination.size)\n\n        var dstIndex = destinationOffset\n        for (index in startIndex until endIndex) {\n            destination[dstIndex++] = string[index]\n        }\n    }\n\n    /**\n     * Appends characters in a subarray of the specified character array [value] to this string builder and returns this instance.\n     *\n     * Characters are appended in order, starting at specified [startIndex].\n     *\n     * @param value the array from which characters are appended.\n     * @param startIndex the beginning (inclusive) of the subarray to append.\n     * @param endIndex the end (exclusive) of the subarray to append.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    public fun appendRange(value: CharArray, startIndex: Int, endIndex: Int): StringBuilder {\n        string += value.concatToString(startIndex, endIndex)\n        return this\n    }\n\n    /**\n     * Appends a subsequence of the specified character sequence [value] to this string builder and returns this instance.\n     *\n     * @param value the character sequence from which a subsequence is appended. If [value] is `null`,\n     *  then characters are appended as if [value] contained the four characters `\"null\"`.\n     * @param startIndex the beginning (inclusive) of the subsequence to append.\n     * @param endIndex the end (exclusive) of the subsequence to append.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    public fun appendRange(value: CharSequence?, startIndex: Int, endIndex: Int): StringBuilder {\n        val stringCsq = value.toString()\n        AbstractList.checkBoundsIndexes(startIndex, endIndex, stringCsq.length)\n\n        string += stringCsq.substring(startIndex, endIndex)\n        return this\n    }\n\n    /**\n     * Inserts characters in a subarray of the specified character array [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in same order as in the [value] array, starting at [index].\n     *\n     * @param index the position in this string builder to insert at.\n     * @param value the array from which characters are inserted.\n     * @param startIndex the beginning (inclusive) of the subarray to insert.\n     * @param endIndex the end (exclusive) of the subarray to insert.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    public fun insertRange(index: Int, value: CharArray, startIndex: Int, endIndex: Int): StringBuilder {\n        AbstractList.checkPositionIndex(index, this.length)\n\n        string = string.substring(0, index) + value.concatToString(startIndex, endIndex) + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts characters in a subsequence of the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n     *\n     * @param index the position in this string builder to insert at.\n     * @param value the character sequence from which a subsequence is inserted. If [value] is `null`,\n     *  then characters will be inserted as if [value] contained the four characters `\"null\"`.\n     * @param startIndex the beginning (inclusive) of the subsequence to insert.\n     * @param endIndex the end (exclusive) of the subsequence to insert.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    public fun insertRange(index: Int, value: CharSequence?, startIndex: Int, endIndex: Int): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        val stringCsq = value.toString()\n        AbstractList.checkBoundsIndexes(startIndex, endIndex, stringCsq.length)\n\n        string = string.substring(0, index) + stringCsq.substring(startIndex, endIndex) + string.substring(index)\n        return this\n    }\n}\n\n\n/**\n * Clears the content of this string builder making it empty and returns this instance.\n *\n * @sample samples.text.Strings.clearStringBuilder\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.clear(): StringBuilder = this.clear()\n\n/**\n * Sets the character at the specified [index] to the specified [value].\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline operator fun StringBuilder.set(index: Int, value: Char) = this.set(index, value)\n\n/**\n * Replaces characters in the specified range of this string builder with characters in the specified string [value] and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to replace.\n * @param endIndex the end (exclusive) of the range to replace.\n * @param value the string to replace with.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] if [startIndex] is less than zero, greater than the length of this string builder, or `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.setRange(startIndex: Int, endIndex: Int, value: String): StringBuilder =\n    this.setRange(startIndex, endIndex, value)\n\n/**\n * Removes the character at the specified [index] from this string builder and returns this instance.\n *\n * If the `Char` at the specified [index] is part of a supplementary code point, this method does not remove the entire supplementary character.\n *\n * @param index the index of `Char` to remove.\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.deleteAt(index: Int): StringBuilder = this.deleteAt(index)\n\n/**\n * Removes characters in the specified range from this string builder and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to remove.\n * @param endIndex the end (exclusive) of the range to remove.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.deleteRange(startIndex: Int, endIndex: Int): StringBuilder = this.deleteRange(startIndex, endIndex)\n\n/**\n * Copies characters from this string builder into the [destination] character array.\n *\n * @param destination the array to copy to.\n * @param destinationOffset the position in the array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the range to copy, 0 by default.\n * @param endIndex the end (exclusive) of the range to copy, length of this string builder by default.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n *  or when that index is out of the [destination] array indices range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\", \"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun StringBuilder.toCharArray(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = this.length) =\n    this.toCharArray(destination, destinationOffset, startIndex, endIndex)\n\n/**\n * Appends characters in a subarray of the specified character array [value] to this string builder and returns this instance.\n *\n * Characters are appended in order, starting at specified [startIndex].\n *\n * @param value the array from which characters are appended.\n * @param startIndex the beginning (inclusive) of the subarray to append.\n * @param endIndex the end (exclusive) of the subarray to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.appendRange(value: CharArray, startIndex: Int, endIndex: Int): StringBuilder =\n    this.appendRange(value, startIndex, endIndex)\n\n/**\n * Appends a subsequence of the specified character sequence [value] to this string builder and returns this instance.\n *\n * @param value the character sequence from which a subsequence is appended. If [value] is `null`,\n *  then characters are appended as if [value] contained the four characters `\"null\"`.\n * @param startIndex the beginning (inclusive) of the subsequence to append.\n * @param endIndex the end (exclusive) of the subsequence to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.appendRange(value: CharSequence?, startIndex: Int, endIndex: Int): StringBuilder =\n    this.appendRange(value, startIndex, endIndex)\n\n/**\n * Inserts characters in a subarray of the specified character array [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in same order as in the [value] array, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the array from which characters are inserted.\n * @param startIndex the beginning (inclusive) of the subarray to insert.\n * @param endIndex the end (exclusive) of the subarray to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.insertRange(index: Int, value: CharArray, startIndex: Int, endIndex: Int): StringBuilder =\n    this.insertRange(index, value, startIndex, endIndex)\n\n/**\n * Inserts characters in a subsequence of the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the character sequence from which a subsequence is inserted. If [value] is `null`,\n *  then characters will be inserted as if [value] contained the four characters `\"null\"`.\n * @param startIndex the beginning (inclusive) of the subsequence to insert.\n * @param endIndex the end (exclusive) of the subsequence to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.insertRange(index: Int, value: CharSequence?, startIndex: Int, endIndex: Int): StringBuilder =\n    this.insertRange(index, value, startIndex, endIndex)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n// actually \\s is enough to match all whitespace, but \\xA0 added because of different regexp behavior of Rhino used in Selenium tests\npublic actual fun Char.isWhitespace(): Boolean = toString().matches(\"[\\\\s\\\\xA0]\")\n\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.toLowerCase(): Char = js(\"String.fromCharCode\")(toInt()).toLowerCase().charCodeAt(0).unsafeCast<Int>().toChar()\n\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.toUpperCase(): Char = js(\"String.fromCharCode\")(toInt()).toUpperCase().charCodeAt(0).unsafeCast<Int>().toChar()\n\n/**\n * Returns `true` if this character is a Unicode high-surrogate code unit (also known as leading-surrogate code unit).\n */\npublic actual fun Char.isHighSurrogate(): Boolean = this in Char.MIN_HIGH_SURROGATE..Char.MAX_HIGH_SURROGATE\n\n/**\n * Returns `true` if this character is a Unicode low-surrogate code unit (also known as trailing-surrogate code unit).\n */\npublic actual fun Char.isLowSurrogate(): Boolean = this in Char.MIN_LOW_SURROGATE..Char.MAX_LOW_SURROGATE\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n\n/**\n * Returns `true` if the contents of this string is equal to the word \"true\", ignoring case, and `false` otherwise.\n */\npublic actual fun String.toBoolean(): Boolean = toLowerCase() == \"true\"\n\n/**\n * Parses the string as a signed [Byte] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toByte(): Byte = toByteOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a signed [Byte] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toByte(radix: Int): Byte = toByteOrNull(radix) ?: numberFormatError(this)\n\n\n/**\n * Parses the string as a [Short] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toShort(): Short = toShortOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Short] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toShort(radix: Int): Short = toShortOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as an [Int] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toInt(): Int = toIntOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as an [Int] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toInt(radix: Int): Int = toIntOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Long] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toLong(): Long = toLongOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Long] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toLong(radix: Int): Long = toLongOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Double] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toDouble(): Double = (+(this.asDynamic())).unsafeCast<Double>().also {\n    if (it.isNaN() && !this.isNaN() || it == 0.0 && this.isBlank())\n        numberFormatError(this)\n}\n\n/**\n * Parses the string as a [Float] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toFloat(): Float = toDouble().unsafeCast<Float>()\n\n/**\n * Parses the string as a [Double] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\npublic actual fun String.toDoubleOrNull(): Double? = (+(this.asDynamic())).unsafeCast<Double>().takeIf {\n    !(it.isNaN() && !this.isNaN() || it == 0.0 && this.isBlank())\n}\n\n/**\n * Parses the string as a [Float] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toFloatOrNull(): Float? = toDoubleOrNull().unsafeCast<Float?>()\n\n/**\n * Returns a string representation of this [Byte] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Byte.toString(radix: Int): String = this.toInt().toString(radix)\n\n/**\n * Returns a string representation of this [Short] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Short.toString(radix: Int): String = this.toInt().toString(radix)\n\n/**\n * Returns a string representation of this [Int] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Int.toString(radix: Int): String = asDynamic().toString(checkRadix(radix))\n\nprivate fun String.isNaN(): Boolean = when (this.toLowerCase()) {\n    \"nan\", \"+nan\", \"-nan\" -> true\n    else -> false\n}\n\n/**\n * Checks whether the given [radix] is valid radix for string to number and number to string conversion.\n */\n@PublishedApi\ninternal actual fun checkRadix(radix: Int): Int {\n    if (radix !in 2..36) {\n        throw IllegalArgumentException(\"radix $radix was not in valid range 2..36\")\n    }\n    return radix\n}\n\ninternal actual fun digitOf(char: Char, radix: Int): Int = when {\n    char >= '0' && char <= '9' -> char - '0'\n    char >= 'A' && char <= 'Z' -> char - 'A' + 10\n    char >= 'a' && char <= 'z' -> char - 'a' + 10\n    else -> -1\n}.let { if (it >= radix) -1 else it }\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n\npublic actual interface Comparator<T> {\n    @JsName(\"compare\")\n    actual fun compare(a: T, b: T): Int\n}\n\npublic actual inline fun <T> Comparator(crossinline comparison: (a: T, b: T) -> Int): Comparator<T> = object : Comparator<T> {\n    override fun compare(a: T, b: T): Int = comparison(a, b)\n}\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.comparisons\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.js.*\n\n/**\n * Returns the greater of two values.\n * If values are equal, returns the first one.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, b: T): T {\n    return if (a >= b) a else b\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Byte, b: Byte): Byte {\n    return Math.max(a.toInt(), b.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Short, b: Short): Short {\n    return Math.max(a.toInt(), b.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Int, b: Int): Int {\n    return Math.max(a, b)\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@Suppress(\"DEPRECATION_ERROR\", \"NOTHING_TO_INLINE\")\npublic actual inline fun maxOf(a: Long, b: Long): Long {\n    return if (a >= b) a else b\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Float, b: Float): Float {\n    return Math.max(a, b)\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Double, b: Double): Double {\n    return Math.max(a, b)\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, b: T, c: T): T {\n    return maxOf(a, maxOf(b, c))\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Byte, b: Byte, c: Byte): Byte {\n    return Math.max(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Short, b: Short, c: Short): Short {\n    return Math.max(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Int, b: Int, c: Int): Int {\n    return Math.max(a, b, c)\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Long, b: Long, c: Long): Long {\n    return maxOf(a, maxOf(b, c))\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Float, b: Float, c: Float): Float {\n    return Math.max(a, b, c)\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Double, b: Double, c: Double): Double {\n    return Math.max(a, b, c)\n}\n\n/**\n * Returns the smaller of two values.\n * If values are equal, returns the first one.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> minOf(a: T, b: T): T {\n    return if (a <= b) a else b\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Byte, b: Byte): Byte {\n    return Math.min(a.toInt(), b.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Short, b: Short): Short {\n    return Math.min(a.toInt(), b.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Int, b: Int): Int {\n    return Math.min(a, b)\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@Suppress(\"DEPRECATION_ERROR\", \"NOTHING_TO_INLINE\")\npublic actual inline fun minOf(a: Long, b: Long): Long {\n    return if (a <= b) a else b\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Float, b: Float): Float {\n    return Math.min(a, b)\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Double, b: Double): Double {\n    return Math.min(a, b)\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> minOf(a: T, b: T, c: T): T {\n    return minOf(a, minOf(b, c))\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Byte, b: Byte, c: Byte): Byte {\n    return Math.min(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Short, b: Short, c: Short): Short {\n    return Math.min(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Int, b: Int, c: Int): Int {\n    return Math.min(a, b, c)\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Long, b: Long, c: Long): Long {\n    return minOf(a, minOf(b, c))\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Float, b: Float, c: Float): Float {\n    return Math.min(a, b, c)\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Double, b: Double, c: Double): Double {\n    return Math.min(a, b, c)\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\npackage kotlin.collections\n\nimport kotlin.js.JsName\n\n/**\n * Provides a skeletal implementation of the read-only [Collection] interface.\n *\n * @param E the type of elements contained in the collection. The collection is covariant on its element type.\n */\n@SinceKotlin(\"1.1\")\npublic abstract class AbstractCollection<out E> protected constructor() : Collection<E> {\n    abstract override val size: Int\n    abstract override fun iterator(): Iterator<E>\n\n    override fun contains(element: @UnsafeVariance E): Boolean = any { it == element }\n\n    override fun containsAll(elements: Collection<@UnsafeVariance E>): Boolean =\n        elements.all { contains(it) } // use when js will support bound refs: elements.all(this::contains)\n\n    override fun isEmpty(): Boolean = size == 0\n\n    override fun toString(): String = joinToString(\", \", \"[\", \"]\") {\n        if (it === this) \"(this Collection)\" else it.toString()\n    }\n\n    /**\n     * Returns new array of type `Array<Any?>` with the elements of this collection.\n     */\n    @JsName(\"toArray\")\n    protected open fun toArray(): Array<Any?> = copyToArrayImpl(this)\n\n    /**\n     * Fills the provided [array] or creates new array of the same type\n     * and fills it with the elements of this collection.\n     */\n    protected open fun <T> toArray(array: Array<T>): Array<T> = copyToArrayImpl(this, array)\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n/*\n * Based on GWT AbstractList\n * Copyright 2007 Google Inc.\n*/\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the read-only [List] interface.\n *\n * This class is intended to help implementing read-only lists so it doesn't support concurrent modification tracking.\n *\n * @param E the type of elements contained in the list. The list is covariant on its element type.\n */\n@SinceKotlin(\"1.1\")\npublic abstract class AbstractList<out E> protected constructor() : AbstractCollection<E>(), List<E> {\n    abstract override val size: Int\n    abstract override fun get(index: Int): E\n\n    override fun iterator(): Iterator<E> = IteratorImpl()\n\n    override fun indexOf(element: @UnsafeVariance E): Int = indexOfFirst { it == element }\n\n    override fun lastIndexOf(element: @UnsafeVariance E): Int = indexOfLast { it == element }\n\n    override fun listIterator(): ListIterator<E> = ListIteratorImpl(0)\n\n    override fun listIterator(index: Int): ListIterator<E> = ListIteratorImpl(index)\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<E> = SubList(this, fromIndex, toIndex)\n\n    private class SubList<out E>(private val list: AbstractList<E>, private val fromIndex: Int, toIndex: Int) : AbstractList<E>(), RandomAccess {\n        private var _size: Int = 0\n\n        init {\n            checkRangeIndexes(fromIndex, toIndex, list.size)\n            this._size = toIndex - fromIndex\n        }\n\n        override fun get(index: Int): E {\n            checkElementIndex(index, _size)\n\n            return list[fromIndex + index]\n        }\n\n        override val size: Int get() = _size\n    }\n\n    /**\n     * Compares this list with other list instance with the ordered structural equality.\n     *\n     * @return true, if [other] instance is a [List] of the same size, which contains the same elements in the same order.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is List<*>) return false\n\n        return orderedEquals(this, other)\n    }\n\n    /**\n     * Returns the hash code value for this list.\n     */\n    override fun hashCode(): Int = orderedHashCode(this)\n\n    private open inner class IteratorImpl : Iterator<E> {\n        /** the index of the item that will be returned on the next call to [next]`()` */\n        protected var index = 0\n\n        override fun hasNext(): Boolean = index < size\n\n        override fun next(): E {\n            if (!hasNext()) throw NoSuchElementException()\n            return get(index++)\n        }\n    }\n\n    /**\n     * Implementation of [ListIterator] for abstract lists.\n     */\n    private open inner class ListIteratorImpl(index: Int) : IteratorImpl(), ListIterator<E> {\n\n        init {\n            checkPositionIndex(index, this@AbstractList.size)\n            this.index = index\n        }\n\n        override fun hasPrevious(): Boolean = index > 0\n\n        override fun nextIndex(): Int = index\n\n        override fun previous(): E {\n            if (!hasPrevious()) throw NoSuchElementException()\n            return get(--index)\n        }\n\n        override fun previousIndex(): Int = index - 1\n    }\n\n    internal companion object {\n        internal fun checkElementIndex(index: Int, size: Int) {\n            if (index < 0 || index >= size) {\n                throw IndexOutOfBoundsException(\"index: $index, size: $size\")\n            }\n        }\n\n        internal fun checkPositionIndex(index: Int, size: Int) {\n            if (index < 0 || index > size) {\n                throw IndexOutOfBoundsException(\"index: $index, size: $size\")\n            }\n        }\n\n        internal fun checkRangeIndexes(fromIndex: Int, toIndex: Int, size: Int) {\n            if (fromIndex < 0 || toIndex > size) {\n                throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex, size: $size\")\n            }\n            if (fromIndex > toIndex) {\n                throw IllegalArgumentException(\"fromIndex: $fromIndex > toIndex: $toIndex\")\n            }\n        }\n\n        internal fun checkBoundsIndexes(startIndex: Int, endIndex: Int, size: Int) {\n            if (startIndex < 0 || endIndex > size) {\n                throw IndexOutOfBoundsException(\"startIndex: $startIndex, endIndex: $endIndex, size: $size\")\n            }\n            if (startIndex > endIndex) {\n                throw IllegalArgumentException(\"startIndex: $startIndex > endIndex: $endIndex\")\n            }\n        }\n\n        internal fun orderedHashCode(c: Collection<*>): Int {\n            var hashCode = 1\n            for (e in c) {\n                hashCode = 31 * hashCode + (e?.hashCode() ?: 0)\n            }\n            return hashCode\n        }\n\n        internal fun orderedEquals(c: Collection<*>, other: Collection<*>): Boolean {\n            if (c.size != other.size) return false\n\n            val otherIterator = other.iterator()\n            for (elem in c) {\n                val elemOther = otherIterator.next()\n                if (elem != elemOther) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n}","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns a character at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun CharSequence.elementAt(index: Int): Char\n\n/**\n * Returns a character at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.elementAtOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns a character at the given [index] or `null` if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.elementAtOrNull(index: Int): Char? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first character matching the given [predicate], or `null` if no such character was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.find(predicate: (Char) -> Boolean): Char? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last character matching the given [predicate], or `null` if no such character was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.findLast(predicate: (Char) -> Boolean): Char? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first character.\n * @throws [NoSuchElementException] if the char sequence is empty.\n */\npublic fun CharSequence.first(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first character matching the given [predicate].\n * @throws [NoSuchElementException] if no such character is found.\n */\npublic inline fun CharSequence.first(predicate: (Char) -> Boolean): Char {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n}\n\n/**\n * Returns the first character, or `null` if the char sequence is empty.\n */\npublic fun CharSequence.firstOrNull(): Char? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first character matching the given [predicate], or `null` if character was not found.\n */\npublic inline fun CharSequence.firstOrNull(predicate: (Char) -> Boolean): Char? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns a character at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this char sequence.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.getOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns a character at the given [index] or `null` if the [index] is out of bounds of this char sequence.\n */\npublic fun CharSequence.getOrNull(index: Int): Char? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns index of the first character matching the given [predicate], or -1 if the char sequence does not contain such character.\n */\npublic inline fun CharSequence.indexOfFirst(predicate: (Char) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last character matching the given [predicate], or -1 if the char sequence does not contain such character.\n */\npublic inline fun CharSequence.indexOfLast(predicate: (Char) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last character.\n * @throws [NoSuchElementException] if the char sequence is empty.\n */\npublic fun CharSequence.last(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last character matching the given [predicate].\n * @throws [NoSuchElementException] if no such character is found.\n */\npublic inline fun CharSequence.last(predicate: (Char) -> Boolean): Char {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n}\n\n/**\n * Returns the last character, or `null` if the char sequence is empty.\n */\npublic fun CharSequence.lastOrNull(): Char? {\n    return if (isEmpty()) null else this[length - 1]\n}\n\n/**\n * Returns the last character matching the given [predicate], or `null` if no such character was found.\n */\npublic inline fun CharSequence.lastOrNull(predicate: (Char) -> Boolean): Char? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random character from this char sequence.\n * \n * @throws NoSuchElementException if this char sequence is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.random(): Char {\n    return random(Random)\n}\n\n/**\n * Returns a random character from this char sequence using the specified source of randomness.\n * \n * @throws NoSuchElementException if this char sequence is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun CharSequence.random(random: Random): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return get(random.nextInt(length))\n}\n\n/**\n * Returns a random character from this char sequence, or `null` if this char sequence is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.randomOrNull(): Char? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random character from this char sequence using the specified source of randomness, or `null` if this char sequence is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun CharSequence.randomOrNull(random: Random): Char? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(length))\n}\n\n/**\n * Returns the single character, or throws an exception if the char sequence is empty or has more than one character.\n */\npublic fun CharSequence.single(): Char {\n    return when (length) {\n        0 -> throw NoSuchElementException(\"Char sequence is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Char sequence has more than one element.\")\n    }\n}\n\n/**\n * Returns the single character matching the given [predicate], or throws exception if there is no or more than one matching character.\n */\npublic inline fun CharSequence.single(predicate: (Char) -> Boolean): Char {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Char sequence contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Char\n}\n\n/**\n * Returns single character, or `null` if the char sequence is empty or has more than one character.\n */\npublic fun CharSequence.singleOrNull(): Char? {\n    return if (length == 1) this[0] else null\n}\n\n/**\n * Returns the single character matching the given [predicate], or `null` if character was not found or more than one character was found.\n */\npublic inline fun CharSequence.singleOrNull(predicate: (Char) -> Boolean): Char? {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a subsequence of this char sequence with the first [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun CharSequence.drop(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return subSequence(n.coerceAtMost(length), length)\n}\n\n/**\n * Returns a string with the first [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun String.drop(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return substring(n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence with the last [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun CharSequence.dropLast(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return take((length - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a string with the last [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun String.dropLast(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return take((length - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a subsequence of this char sequence containing all characters except last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun CharSequence.dropLastWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in lastIndex downTo 0)\n        if (!predicate(this[index]))\n            return subSequence(0, index + 1)\n    return \"\"\n}\n\n/**\n * Returns a string containing all characters except last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun String.dropLastWhile(predicate: (Char) -> Boolean): String {\n    for (index in lastIndex downTo 0)\n        if (!predicate(this[index]))\n            return substring(0, index + 1)\n    return \"\"\n}\n\n/**\n * Returns a subsequence of this char sequence containing all characters except first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun CharSequence.dropWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n    return \"\"\n}\n\n/**\n * Returns a string containing all characters except first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun String.dropWhile(predicate: (Char) -> Boolean): String {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return substring(index)\n    return \"\"\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that match the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun CharSequence.filter(predicate: (Char) -> Boolean): CharSequence {\n    return filterTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that match the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun String.filter(predicate: (Char) -> Boolean): String {\n    return filterTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that match the given [predicate].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n */\npublic inline fun CharSequence.filterIndexed(predicate: (index: Int, Char) -> Boolean): CharSequence {\n    return filterIndexedTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that match the given [predicate].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n */\npublic inline fun String.filterIndexed(predicate: (index: Int, Char) -> Boolean): String {\n    return filterIndexedTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Appends all characters matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n */\npublic inline fun <C : Appendable> CharSequence.filterIndexedTo(destination: C, predicate: (index: Int, Char) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.append(element)\n    }\n    return destination\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that do not match the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun CharSequence.filterNot(predicate: (Char) -> Boolean): CharSequence {\n    return filterNotTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that do not match the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun String.filterNot(predicate: (Char) -> Boolean): String {\n    return filterNotTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Appends all characters not matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : Appendable> CharSequence.filterNotTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.append(element)\n    return destination\n}\n\n/**\n * Appends all characters matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : Appendable> CharSequence.filterTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (index in 0 until length) {\n        val element = get(index)\n        if (predicate(element)) destination.append(element)\n    }\n    return destination\n}\n\n/**\n * Returns a char sequence containing characters of the original char sequence at the specified range of [indices].\n */\npublic fun CharSequence.slice(indices: IntRange): CharSequence {\n    if (indices.isEmpty()) return \"\"\n    return subSequence(indices)\n}\n\n/**\n * Returns a string containing characters of the original string at the specified range of [indices].\n */\npublic fun String.slice(indices: IntRange): String {\n    if (indices.isEmpty()) return \"\"\n    return substring(indices)\n}\n\n/**\n * Returns a char sequence containing characters of the original char sequence at specified [indices].\n */\npublic fun CharSequence.slice(indices: Iterable<Int>): CharSequence {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return \"\"\n    val result = StringBuilder(size)\n    for (i in indices) {\n        result.append(get(i))\n    }\n    return result\n}\n\n/**\n * Returns a string containing characters of the original string at specified [indices].\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.slice(indices: Iterable<Int>): String {\n    return (this as CharSequence).slice(indices).toString()\n}\n\n/**\n * Returns a subsequence of this char sequence containing the first [n] characters from this char sequence, or the entire char sequence if this char sequence is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun CharSequence.take(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return subSequence(0, n.coerceAtMost(length))\n}\n\n/**\n * Returns a string containing the first [n] characters from this string, or the entire string if this string is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun String.take(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return substring(0, n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence containing the last [n] characters from this char sequence, or the entire char sequence if this char sequence is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun CharSequence.takeLast(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    val length = length\n    return subSequence(length - n.coerceAtMost(length), length)\n}\n\n/**\n * Returns a string containing the last [n] characters from this string, or the entire string if this string is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun String.takeLast(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    val length = length\n    return substring(length - n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence containing last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun CharSequence.takeLastWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return subSequence(index + 1, length)\n        }\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Returns a string containing last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun String.takeLastWhile(predicate: (Char) -> Boolean): String {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return substring(index + 1)\n        }\n    }\n    return this\n}\n\n/**\n * Returns a subsequence of this char sequence containing the first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun CharSequence.takeWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in 0 until length)\n        if (!predicate(get(index))) {\n            return subSequence(0, index)\n        }\n    return subSequence(0, length)\n}\n\n/**\n * Returns a string containing the first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun String.takeWhile(predicate: (Char) -> Boolean): String {\n    for (index in 0 until length)\n        if (!predicate(get(index))) {\n            return substring(0, index)\n        }\n    return this\n}\n\n/**\n * Returns a char sequence with characters in reversed order.\n */\npublic fun CharSequence.reversed(): CharSequence {\n    return StringBuilder(this).reverse()\n}\n\n/**\n * Returns a string with characters in reversed order.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.reversed(): String {\n    return (this as CharSequence).reversed().toString()\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to characters of the given char sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associate\n */\npublic inline fun <K, V> CharSequence.associate(transform: (Char) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the characters from the given char sequence indexed by the key\n * returned from [keySelector] function applied to each character.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associateBy\n */\npublic inline fun <K> CharSequence.associateBy(keySelector: (Char) -> K): Map<K, Char> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Char>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to characters of the given char sequence.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associateByWithValueTransform\n */\npublic inline fun <K, V> CharSequence.associateBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, V> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each character of the given char sequence\n * and value is the character itself.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.text.Strings.associateByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Char>> CharSequence.associateByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to characters of the given char sequence.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.text.Strings.associateByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharSequence.associateByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each character of the given char sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.text.Strings.associateTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharSequence.associateTo(destination: M, transform: (Char) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are characters from the given char sequence and values are\n * produced by the [valueSelector] function applied to each character.\n * \n * If any two characters are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <V> CharSequence.associateWith(valueSelector: (Char) -> V): Map<Char, V> {\n    val result = LinkedHashMap<Char, V>(mapCapacity(length).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each character of the given char sequence,\n * where key is the character itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two characters are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.text.Strings.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <V, M : MutableMap<in Char, in V>> CharSequence.associateWithTo(destination: M, valueSelector: (Char) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all characters to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Char>> CharSequence.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a [HashSet] of all characters.\n */\npublic fun CharSequence.toHashSet(): HashSet<Char> {\n    return toCollection(HashSet<Char>(mapCapacity(length)))\n}\n\n/**\n * Returns a [List] containing all characters.\n */\npublic fun CharSequence.toList(): List<Char> {\n    return when (length) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [MutableList] filled with all characters of this char sequence.\n */\npublic fun CharSequence.toMutableList(): MutableList<Char> {\n    return toCollection(ArrayList<Char>(length))\n}\n\n/**\n * Returns a [Set] of all characters.\n * \n * The returned set preserves the element iteration order of the original char sequence.\n */\npublic fun CharSequence.toSet(): Set<Char> {\n    return when (length) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Char>(mapCapacity(length)))\n    }\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each character of original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> CharSequence.flatMap(transform: (Char) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each character of original char sequence, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.flatMapTo(destination: C, transform: (Char) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups characters of the original char sequence by the key returned by the given [keySelector] function\n * applied to each character and returns a map where each group key is associated with a list of corresponding characters.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> CharSequence.groupBy(keySelector: (Char) -> K): Map<K, List<Char>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Char>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each character of the original char sequence\n * by the key returned by the given [keySelector] function applied to the character\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> CharSequence.groupBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups characters of the original char sequence by the key returned by the given [keySelector] function\n * applied to each character and puts to the [destination] map each group key associated with a list of corresponding characters.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Char>>> CharSequence.groupByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Char>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each character of the original char sequence\n * by the key returned by the given [keySelector] function applied to the character\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> CharSequence.groupByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a char sequence to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each character.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <K> CharSequence.groupingBy(crossinline keySelector: (Char) -> K): Grouping<Char, K> {\n    return object : Grouping<Char, K> {\n        override fun sourceIterator(): Iterator<Char> = this@groupingBy.iterator()\n        override fun keyOf(element: Char): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each character in the original char sequence.\n * \n * @sample samples.text.Strings.map\n */\npublic inline fun <R> CharSequence.map(transform: (Char) -> R): List<R> {\n    return mapTo(ArrayList<R>(length), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each character and its index in the original char sequence.\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R> CharSequence.mapIndexed(transform: (index: Int, Char) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(length), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each character and its index in the original char sequence.\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R : Any> CharSequence.mapIndexedNotNull(transform: (index: Int, Char) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each character and its index in the original char sequence\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R : Any, C : MutableCollection<in R>> CharSequence.mapIndexedNotNullTo(destination: C, transform: (index: Int, Char) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each character and its index in the original char sequence\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.mapIndexedTo(destination: C, transform: (index: Int, Char) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each character in the original char sequence.\n */\npublic inline fun <R : Any> CharSequence.mapNotNull(transform: (Char) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each character in the original char sequence\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <R : Any, C : MutableCollection<in R>> CharSequence.mapNotNullTo(destination: C, transform: (Char) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each character of the original char sequence\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.mapTo(destination: C, transform: (Char) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each character of the original char sequence\n * into an [IndexedValue] containing the index of that character and the character itself.\n */\npublic fun CharSequence.withIndex(): Iterable<IndexedValue<Char>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns `true` if all characters match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun CharSequence.all(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if char sequence has at least one character.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun CharSequence.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if at least one character matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun CharSequence.any(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the length of this char sequence.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.count(): Int {\n    return length\n}\n\n/**\n * Returns the number of characters matching the given [predicate].\n */\npublic inline fun CharSequence.count(predicate: (Char) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each character.\n */\npublic inline fun <R> CharSequence.fold(initial: R, operation: (acc: R, Char) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each character and current accumulator value.\n */\npublic inline fun <R> CharSequence.foldRight(initial: R, operation: (Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * @param [operation] function that takes the index of a character, the character itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldRightIndexed(initial: R, operation: (index: Int, Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each character.\n */\npublic inline fun CharSequence.forEach(action: (Char) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each character, providing sequential index with the character.\n * @param [action] function that takes the index of a character and the character itself\n * and performs the desired action on the character.\n */\npublic inline fun CharSequence.forEachIndexed(action: (index: Int, Char) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Returns the largest character or `null` if there are no characters.\n */\npublic fun CharSequence.max(): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first character yielding the largest value of the given function or `null` if there are no characters.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <R : Comparable<R>> CharSequence.maxBy(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first character having the largest value according to the provided [comparator] or `null` if there are no characters.\n */\npublic fun CharSequence.maxWith(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest character or `null` if there are no characters.\n */\npublic fun CharSequence.min(): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first character yielding the smallest value of the given function or `null` if there are no characters.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <R : Comparable<R>> CharSequence.minBy(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first character having the smallest value according to the provided [comparator] or `null` if there are no characters.\n */\npublic fun CharSequence.minWith(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the char sequence has no characters.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun CharSequence.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no characters match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun CharSequence.none(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each character and returns the char sequence itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <S : CharSequence> S.onEach(action: (Char) -> Unit): S {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right to current accumulator value and each character.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharSequence.reduce(operation: (acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharSequence.reduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right to current accumulator value and each character. Returns null if the char sequence is empty.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun CharSequence.reduceOrNull(operation: (acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last character and applying [operation] from right to left to each character and current accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharSequence.reduceRight(operation: (Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last character and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * @param [operation] function that takes the index of a character, the character itself\n * and current accumulator value, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharSequence.reduceRightIndexed(operation: (index: Int, Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last character and applying [operation] from right to left to each character and current accumulator value. Returns null if the char sequence is empty.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun CharSequence.reduceRightOrNull(operation: (Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun <R> CharSequence.scan(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(length + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character, its index in the original char sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun <R> CharSequence.scanIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(length + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character and current accumulator value that starts with the first character of this char sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scanReduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun CharSequence.scanReduce(operation: (acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(length).apply { add(accumulator) }\n    for (index in 1 until length) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character, its index in the original char sequence and current accumulator value that starts with the first character of this char sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scanReduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun CharSequence.scanReduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(length).apply { add(accumulator) }\n    for (index in 1 until length) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\npublic inline fun CharSequence.sumBy(selector: (Char) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\npublic inline fun CharSequence.sumByDouble(selector: (Char) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Splits this char sequence into a list of strings each not exceeding the given [size].\n * \n * The last string in the resulting list may have less characters than the given [size].\n * \n * @param size the number of elements to take in each string, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.chunked(size: Int): List<String> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this char sequence into several char sequences each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each char sequence.\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last char sequence may have less characters than the given [size].\n * \n * @param size the number of elements to take in each char sequence, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.chunked(size: Int, transform: (CharSequence) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Splits this char sequence into a sequence of strings each not exceeding the given [size].\n * \n * The last string in the resulting sequence may have less characters than the given [size].\n * \n * @param size the number of elements to take in each string, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.chunkedSequence(size: Int): Sequence<String> {\n    return chunkedSequence(size) { it.toString() }\n}\n\n/**\n * Splits this char sequence into several char sequences each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return sequence of results of the [transform] applied to an each char sequence.\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last char sequence may have less characters than the given [size].\n * \n * @param size the number of elements to take in each char sequence, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunkedTransformToSequence\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.chunkedSequence(size: Int, transform: (CharSequence) -> R): Sequence<R> {\n    return windowedSequence(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Splits the original char sequence into pair of char sequences,\n * where *first* char sequence contains characters for which [predicate] yielded `true`,\n * while *second* char sequence contains characters for which [predicate] yielded `false`.\n * \n * @sample samples.text.Strings.partition\n */\npublic inline fun CharSequence.partition(predicate: (Char) -> Boolean): Pair<CharSequence, CharSequence> {\n    val first = StringBuilder()\n    val second = StringBuilder()\n    for (element in this) {\n        if (predicate(element)) {\n            first.append(element)\n        } else {\n            second.append(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original string into pair of strings,\n * where *first* string contains characters for which [predicate] yielded `true`,\n * while *second* string contains characters for which [predicate] yielded `false`.\n * \n * @sample samples.text.Strings.partition\n */\npublic inline fun String.partition(predicate: (Char) -> Boolean): Pair<String, String> {\n    val first = StringBuilder()\n    val second = StringBuilder()\n    for (element in this) {\n        if (predicate(element)) {\n            first.append(element)\n        } else {\n            second.append(element)\n        }\n    }\n    return Pair(first.toString(), second.toString())\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this char sequence with the given [step], where each\n * snapshot is a string.\n * \n * Several last strings may have less characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<String> {\n    return windowed(size, step, partialWindows) { it.toString() }\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each char sequence representing a view over the window of the given [size]\n * sliding along this char sequence with the given [step].\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last char sequences may have less characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (CharSequence) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    val thisSize = this.length\n    val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n    val result = ArrayList<R>(resultCapacity)\n    var index = 0\n    while (index in 0 until thisSize) {\n        val end = index + size\n        val coercedEnd = if (end < 0 || end > thisSize) { if (partialWindows) thisSize else break } else end\n        result.add(transform(subSequence(index, coercedEnd)))\n        index += step\n    }\n    return result\n}\n\n/**\n * Returns a sequence of snapshots of the window of the given [size]\n * sliding along this char sequence with the given [step], where each\n * snapshot is a string.\n * \n * Several last strings may have less characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.windowedSequence(size: Int, step: Int = 1, partialWindows: Boolean = false): Sequence<String> {\n    return windowedSequence(size, step, partialWindows) { it.toString() }\n}\n\n/**\n * Returns a sequence of results of applying the given [transform] function to\n * an each char sequence representing a view over the window of the given [size]\n * sliding along this char sequence with the given [step].\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last char sequences may have less characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.windowedSequence(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (CharSequence) -> R): Sequence<R> {\n    checkWindowSizeStep(size, step)\n    val windows = (if (partialWindows) indices else 0 until length - size + 1) step step\n    return windows.asSequence().map { index ->\n        val end = index + size\n        val coercedEnd = if (end < 0 || end > length) length else end\n        transform(subSequence(index, coercedEnd))\n    }\n}\n\n/**\n * Returns a list of pairs built from the characters of `this` and the [other] char sequences with the same index\n * The returned list has length of the shortest char sequence.\n * \n * @sample samples.text.Strings.zip\n */\npublic infix fun CharSequence.zip(other: CharSequence): List<Pair<Char, Char>> {\n    return zip(other) { c1, c2 -> c1 to c2 }\n}\n\n/**\n * Returns a list of values built from the characters of `this` and the [other] char sequences with the same index\n * using the provided [transform] function applied to each pair of characters.\n * The returned list has length of the shortest char sequence.\n * \n * @sample samples.text.Strings.zipWithTransform\n */\npublic inline fun <V> CharSequence.zip(other: CharSequence, transform: (a: Char, b: Char) -> V): List<V> {\n    val length = minOf(this.length, other.length)\n    val list = ArrayList<V>(length)\n    for (i in 0 until length) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent characters in this char sequence.\n * \n * The returned list is empty if this char sequence contains less than two characters.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.zipWithNext(): List<Pair<Char, Char>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent characters in this char sequence.\n * \n * The returned list is empty if this char sequence contains less than two characters.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <R> CharSequence.zipWithNext(transform: (a: Char, b: Char) -> R): List<R> {\n    val size = length - 1\n    if (size < 1) return emptyList()\n    val result = ArrayList<R>(size)\n    for (index in 0 until size) {\n        result.add(transform(this[index], this[index + 1]))\n    }\n    return result\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original char sequence returning its characters when being iterated.\n */\npublic fun CharSequence.asIterable(): Iterable<Char> {\n    if (this is String && isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original char sequence returning its characters when being iterated.\n */\npublic fun CharSequence.asSequence(): Sequence<Char> {\n    if (this is String && isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\nimport kotlin.contracts.contract\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trim(predicate: (Char) -> Boolean): CharSequence {\n    var startIndex = 0\n    var endIndex = length - 1\n    var startFound = false\n\n    while (startIndex <= endIndex) {\n        val index = if (!startFound) startIndex else endIndex\n        val match = predicate(this[index])\n\n        if (!startFound) {\n            if (!match)\n                startFound = true\n            else\n                startIndex += 1\n        } else {\n            if (!match)\n                break\n            else\n                endIndex -= 1\n        }\n    }\n\n    return subSequence(startIndex, endIndex + 1)\n}\n\n/**\n * Returns a string having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trim(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trim(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimStart(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n\n    return \"\"\n}\n\n/**\n * Returns a string having leading characters matching the [predicate] removed.\n */\npublic inline fun String.trimStart(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimStart(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimEnd(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices.reversed())\n        if (!predicate(this[index]))\n            return subSequence(0, index + 1)\n\n    return \"\"\n}\n\n/**\n * Returns a string having trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trimEnd(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimEnd(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trim(vararg chars: Char): CharSequence = trim { it in chars }\n\n/**\n * Returns a string having leading and trailing characters from the [chars] array removed.\n */\npublic fun String.trim(vararg chars: Char): String = trim { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading characters from the [chars] array removed.\n */\npublic fun CharSequence.trimStart(vararg chars: Char): CharSequence = trimStart { it in chars }\n\n/**\n * Returns a string having leading characters from the [chars] array removed.\n */\npublic fun String.trimStart(vararg chars: Char): String = trimStart { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trimEnd(vararg chars: Char): CharSequence = trimEnd { it in chars }\n\n/**\n * Returns a string having trailing characters from the [chars] array removed.\n */\npublic fun String.trimEnd(vararg chars: Char): String = trimEnd { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing whitespace removed.\n */\npublic fun CharSequence.trim(): CharSequence = trim(Char::isWhitespace)\n\n/**\n * Returns a string having leading and trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trim(): String = (this as CharSequence).trim().toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading whitespace removed.\n */\npublic fun CharSequence.trimStart(): CharSequence = trimStart(Char::isWhitespace)\n\n/**\n * Returns a string having leading whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimStart(): String = (this as CharSequence).trimStart().toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing whitespace removed.\n */\npublic fun CharSequence.trimEnd(): CharSequence = trimEnd(Char::isWhitespace)\n\n/**\n * Returns a string having trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimEnd(): String = (this as CharSequence).trimEnd().toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the beginning\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun CharSequence.padStart(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    sb.append(this)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the beginning with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun String.padStart(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padStart(length, padChar).toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the end\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun CharSequence.padEnd(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    sb.append(this)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the end with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun String.padEnd(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padEnd(length, padChar).toString()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty.\n *\n * @sample samples.text.Strings.stringIsNullOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.length == 0\n}\n\n/**\n * Returns `true` if this char sequence is empty (contains no characters).\n *\n * @sample samples.text.Strings.stringIsEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isEmpty(): Boolean = length == 0\n\n/**\n * Returns `true` if this char sequence is not empty.\n *\n * @sample samples.text.Strings.stringIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotEmpty(): Boolean = length > 0\n\n// implemented differently in JVM and JS\n//public fun String.isBlank(): Boolean = length() == 0 || all { it.isWhitespace() }\n\n\n/**\n * Returns `true` if this char sequence is not empty and contains some characters except of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNotBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotBlank(): Boolean = !isBlank()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty or consists solely of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNullOrBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrBlank(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrBlank != null)\n    }\n\n    return this == null || this.isBlank()\n}\n\n/**\n * Iterator for characters of the given char sequence.\n */\npublic operator fun CharSequence.iterator(): CharIterator = object : CharIterator() {\n    private var index = 0\n\n    public override fun nextChar(): Char = get(index++)\n\n    public override fun hasNext(): Boolean = index < length\n}\n\n/** Returns the string if it is not `null`, or the empty string otherwise. */\n@kotlin.internal.InlineOnly\npublic inline fun String?.orEmpty(): String = this ?: \"\"\n\n/**\n * Returns this char sequence if it's not empty\n * or the result of calling [defaultValue] function if the char sequence is empty.\n *\n * @sample samples.text.Strings.stringIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Returns this char sequence if it is not empty and doesn't consist solely of whitespace characters,\n * or the result of calling [defaultValue] function otherwise.\n *\n * @sample samples.text.Strings.stringIfBlank\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifBlank(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isBlank()) defaultValue() else this\n\n/**\n * Returns the range of valid character indices for this char sequence.\n */\npublic val CharSequence.indices: IntRange\n    get() = 0..length - 1\n\n/**\n * Returns the index of the last character in the char sequence or -1 if it is empty.\n */\npublic val CharSequence.lastIndex: Int\n    get() = this.length - 1\n\n/**\n * Returns `true` if this CharSequence has Unicode surrogate pair at the specified [index].\n */\npublic fun CharSequence.hasSurrogatePairAt(index: Int): Boolean {\n    return index in 0..length - 2\n            && this[index].isHighSurrogate()\n            && this[index + 1].isLowSurrogate()\n}\n\n/**\n * Returns a substring specified by the given [range] of indices.\n */\npublic fun String.substring(range: IntRange): String = substring(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence specified by the given [range] of indices.\n */\npublic fun CharSequence.subSequence(range: IntRange): CharSequence = subSequence(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence.\n *\n * This extension is chosen only for invocation with old-named parameters.\n * Replace parameter names with the same as those of [CharSequence.subSequence].\n */\n@kotlin.internal.InlineOnly\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning\n@Deprecated(\"Use parameters named startIndex and endIndex.\", ReplaceWith(\"subSequence(startIndex = start, endIndex = end)\"))\npublic inline fun String.subSequence(start: Int, end: Int): CharSequence = subSequence(start, end)\n\n/**\n * Returns a substring of chars from a range of this char sequence starting at the [startIndex] and ending right before the [endIndex].\n *\n * @param startIndex the start index (inclusive).\n * @param endIndex the end index (exclusive). If not specified, the length of the char sequence is used.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.substring(startIndex: Int, endIndex: Int = length): String = subSequence(startIndex, endIndex).toString()\n\n/**\n * Returns a substring of chars at indices from the specified [range] of this char sequence.\n */\npublic fun CharSequence.substring(range: IntRange): String = subSequence(range.start, range.endInclusive + 1).toString()\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range\n * is replaced with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\n@UseExperimental(ExperimentalStdlibApi::class)\npublic fun CharSequence.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n    val sb = StringBuilder()\n    sb.appendRange(this, 0, startIndex)\n    sb.append(replacement)\n    sb.appendRange(this, endIndex, length)\n    return sb\n}\n\n/**\n * Replaces the part of the string at the given range with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(startIndex, endIndex, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range]\n * is replaced with the [replacement] char sequence.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\npublic fun CharSequence.replaceRange(range: IntRange, replacement: CharSequence): CharSequence =\n    replaceRange(range.start, range.endInclusive + 1, replacement)\n\n/**\n * Replace the part of string at the given [range] with the [replacement] string.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(range: IntRange, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(range, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range is removed.\n *\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n * [endIndex] is not included in the removed part.\n */\n@UseExperimental(ExperimentalStdlibApi::class)\npublic fun CharSequence.removeRange(startIndex: Int, endIndex: Int): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n\n    if (endIndex == startIndex)\n        return this.subSequence(0, length)\n\n    val sb = StringBuilder(length - (endIndex - startIndex))\n    sb.appendRange(this, 0, startIndex)\n    sb.appendRange(this, endIndex, length)\n    return sb\n}\n\n/**\n * Removes the part of a string at a given range.\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n *  [endIndex] is not included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(startIndex: Int, endIndex: Int): String =\n    (this as CharSequence).removeRange(startIndex, endIndex).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range] is removed.\n *\n * The end index of the [range] is included in the removed part.\n */\npublic fun CharSequence.removeRange(range: IntRange): CharSequence = removeRange(range.start, range.endInclusive + 1)\n\n/**\n * Removes the part of a string at the given [range].\n *\n * The end index of the [range] is included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(range: IntRange): String =\n    (this as CharSequence).removeRange(range).toString()\n\n/**\n * If this char sequence starts with the given [prefix], returns a new char sequence\n * with the prefix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removePrefix(prefix: CharSequence): CharSequence {\n    if (startsWith(prefix)) {\n        return subSequence(prefix.length, length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string starts with the given [prefix], returns a copy of this string\n * with the prefix removed. Otherwise, returns this string.\n */\npublic fun String.removePrefix(prefix: CharSequence): String {\n    if (startsWith(prefix)) {\n        return substring(prefix.length)\n    }\n    return this\n}\n\n/**\n * If this char sequence ends with the given [suffix], returns a new char sequence\n * with the suffix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSuffix(suffix: CharSequence): CharSequence {\n    if (endsWith(suffix)) {\n        return subSequence(0, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string ends with the given [suffix], returns a copy of this string\n * with the suffix removed. Otherwise, returns this string.\n */\npublic fun String.removeSuffix(suffix: CharSequence): String {\n    if (endsWith(suffix)) {\n        return substring(0, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with the given [prefix] and ends with the given [suffix],\n * returns a new char sequence having both the given [prefix] and [suffix] removed.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(prefix: CharSequence, suffix: CharSequence): CharSequence {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return subSequence(prefix.length, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Removes from a string both the given [prefix] and [suffix] if and only if\n * it starts with the [prefix] and ends with the [suffix].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(prefix: CharSequence, suffix: CharSequence): String {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return substring(prefix.length, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with and ends with the given [delimiter],\n * returns a new char sequence having this [delimiter] removed both from the start and end.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(delimiter: CharSequence): CharSequence = removeSurrounding(delimiter, delimiter)\n\n/**\n * Removes the given [delimiter] string from both the start and the end of this string\n * if and only if it starts with and ends with the [delimiter].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(delimiter: CharSequence): String = removeSurrounding(delimiter, delimiter)\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n\n// public fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean): String // JVM- and JS-specific\n// public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean): String // JVM- and JS-specific\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the given [replacement].\n *\n * The [replacement] can consist of any combination of literal text and $-substitutions. To treat the replacement string\n * literally escape it with the [kotlin.text.Regex.Companion.escapeReplacement] method.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, replacement: String): String = regex.replace(this, replacement)\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the result of the given function [transform] that takes [MatchResult] and returns a string to be used as a\n * replacement for that match.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, noinline transform: (MatchResult) -> CharSequence): String =\n    regex.replace(this, transform)\n\n/**\n * Replaces the first occurrence of the given regular expression [regex] in this char sequence with specified [replacement] expression.\n *\n * @param replacement A replacement expression that can include substitutions. See [Regex.replaceFirst] for details.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replaceFirst(regex: Regex, replacement: String): String = regex.replaceFirst(this, replacement)\n\n\n/**\n * Returns `true` if this char sequence matches the given regular expression.\n */\n@kotlin.internal.InlineOnly\npublic inline infix fun CharSequence.matches(regex: Regex): Boolean = regex.matches(this)\n\n/**\n * Implementation of [regionMatches] for CharSequences.\n * Invoked when it's already known that arguments are not Strings, so that no additional type checks are performed.\n */\ninternal fun CharSequence.regionMatchesImpl(thisOffset: Int, other: CharSequence, otherOffset: Int, length: Int, ignoreCase: Boolean): Boolean {\n    if ((otherOffset < 0) || (thisOffset < 0) || (thisOffset > this.length - length) || (otherOffset > other.length - length)) {\n        return false\n    }\n\n    for (index in 0 until length) {\n        if (!this[thisOffset + index].equals(other[otherOffset + index], ignoreCase))\n            return false\n    }\n    return true\n}\n\n/**\n * Returns `true` if this char sequence starts with the specified character.\n */\npublic fun CharSequence.startsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[0].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence ends with the specified character.\n */\npublic fun CharSequence.endsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[lastIndex].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix)\n    else\n        return regionMatchesImpl(0, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if a substring of this char sequence starting at the specified offset [startIndex] starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, startIndex: Int, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix, startIndex)\n    else\n        return regionMatchesImpl(startIndex, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if this char sequence ends with the specified suffix.\n */\npublic fun CharSequence.endsWith(suffix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && suffix is String)\n        return this.endsWith(suffix)\n    else\n        return regionMatchesImpl(length - suffix.length, suffix, 0, suffix.length, ignoreCase)\n}\n\n\n// common prefix and suffix\n\n/**\n * Returns the longest string `prefix` such that this char sequence and [other] char sequence both start with this prefix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common prefix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonPrefixWith\n */\npublic fun CharSequence.commonPrefixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val shortestLength = minOf(this.length, other.length)\n\n    var i = 0\n    while (i < shortestLength && this[i].equals(other[i], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(i - 1) || other.hasSurrogatePairAt(i - 1)) {\n        i--\n    }\n    return subSequence(0, i).toString()\n}\n\n/**\n * Returns the longest string `suffix` such that this char sequence and [other] char sequence both end with this suffix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common suffix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonSuffixWith\n */\npublic fun CharSequence.commonSuffixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val thisLength = this.length\n    val otherLength = other.length\n    val shortestLength = minOf(thisLength, otherLength)\n\n    var i = 0\n    while (i < shortestLength && this[thisLength - i - 1].equals(other[otherLength - i - 1], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(thisLength - i - 1) || other.hasSurrogatePairAt(otherLength - i - 1)) {\n        i--\n    }\n    return subSequence(thisLength - i, thisLength).toString()\n}\n\n\n// indexOfAny()\n\n/**\n * Finds the index of the first occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.indexOfAny(chars: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeIndexOf(char, startIndex)\n    }\n\n    for (index in startIndex.coerceAtLeast(0)..lastIndex) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n    return -1\n}\n\n/**\n * Finds the index of the last occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.lastIndexOfAny(chars: CharArray, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeLastIndexOf(char, startIndex)\n    }\n\n\n    for (index in startIndex.coerceAtMost(lastIndex) downTo 0) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n\n    return -1\n}\n\n\nprivate fun CharSequence.indexOf(other: CharSequence, startIndex: Int, endIndex: Int, ignoreCase: Boolean, last: Boolean = false): Int {\n    val indices = if (!last)\n        startIndex.coerceAtLeast(0)..endIndex.coerceAtMost(length)\n    else\n        startIndex.coerceAtMost(lastIndex) downTo endIndex.coerceAtLeast(0)\n\n    if (this is String && other is String) { // smart cast\n        for (index in indices) {\n            if (other.regionMatches(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    } else {\n        for (index in indices) {\n            if (other.regionMatchesImpl(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    }\n    return -1\n}\n\nprivate fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int, ignoreCase: Boolean, last: Boolean): Pair<Int, String>? {\n    if (!ignoreCase && strings.size == 1) {\n        val string = strings.single()\n        val index = if (!last) indexOf(string, startIndex) else lastIndexOf(string, startIndex)\n        return if (index < 0) null else index to string\n    }\n\n    val indices = if (!last) startIndex.coerceAtLeast(0)..length else startIndex.coerceAtMost(lastIndex) downTo 0\n\n    if (this is String) {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatches(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    } else {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatchesImpl(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    }\n\n    return null\n}\n\n/**\n * Finds the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the first occurrence of matched string from [strings] and the string matched\n * or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)\n\n/**\n * Finds the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the last occurrence of matched string from [strings] and the string matched or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findLastAnyOf(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)\n\n/**\n * Finds the index of the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.indexOfAny(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)?.first ?: -1\n\n/**\n * Finds the index of the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.lastIndexOfAny(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)?.first ?: -1\n\n\n// indexOf\n\n/**\n * Returns the index within this string of the first occurrence of the specified character, starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.indexOf(char: Char, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the first occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of [string] or `-1` if none is found.\n * @sample samples.text.Strings.indexOf\n */\npublic fun CharSequence.indexOf(string: String, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, length, ignoreCase)\n    else\n        nativeIndexOf(string, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified character,\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(char: Char, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        lastIndexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeLastIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of [string] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(string: String, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, 0, ignoreCase, last = true)\n    else\n        nativeLastIndexOf(string, startIndex)\n}\n\n/**\n * Returns `true` if this char sequence contains the specified [other] sequence of characters as a substring.\n *\n * @param ignoreCase `true` to ignore character case when comparing strings. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = false): Boolean =\n    if (other is String)\n        indexOf(other, ignoreCase = ignoreCase) >= 0\n    else\n        indexOf(other, 0, length, ignoreCase) >= 0\n\n\n\n/**\n * Returns `true` if this char sequence contains the specified character [char].\n *\n * @param ignoreCase `true` to ignore character case when comparing characters. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(char: Char, ignoreCase: Boolean = false): Boolean =\n    indexOf(char, ignoreCase = ignoreCase) >= 0\n\n/**\n * Returns `true` if this char sequence contains at least one match of the specified regular expression [regex].\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharSequence.contains(regex: Regex): Boolean = regex.containsMatchIn(this)\n\n\n// rangesDelimitedBy\n\n\nprivate class DelimitedRangesSequence(\n    private val input: CharSequence,\n    private val startIndex: Int,\n    private val limit: Int,\n    private val getNextMatch: CharSequence.(currentIndex: Int) -> Pair<Int, Int>?\n) : Sequence<IntRange> {\n\n    override fun iterator(): Iterator<IntRange> = object : Iterator<IntRange> {\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var currentStartIndex: Int = startIndex.coerceIn(0, input.length)\n        var nextSearchIndex: Int = currentStartIndex\n        var nextItem: IntRange? = null\n        var counter: Int = 0\n\n        private fun calcNext() {\n            if (nextSearchIndex < 0) {\n                nextState = 0\n                nextItem = null\n            } else {\n                if (limit > 0 && ++counter >= limit || nextSearchIndex > input.length) {\n                    nextItem = currentStartIndex..input.lastIndex\n                    nextSearchIndex = -1\n                } else {\n                    val match = input.getNextMatch(nextSearchIndex)\n                    if (match == null) {\n                        nextItem = currentStartIndex..input.lastIndex\n                        nextSearchIndex = -1\n                    } else {\n                        val (index, length) = match\n                        nextItem = currentStartIndex until index\n                        currentStartIndex = index + length\n                        nextSearchIndex = currentStartIndex + if (length == 0) 1 else 0\n                    }\n                }\n                nextState = 1\n            }\n        }\n\n        override fun next(): IntRange {\n            if (nextState == -1)\n                calcNext()\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem as IntRange\n            // Clean next to avoid keeping reference on yielded instance\n            nextItem = null\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex ->\n        indexOfAny(delimiters, currentIndex, ignoreCase = ignoreCase).let { if (it < 0) null else it to 1 }\n    })\n}\n\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: Array<out String>, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" } )\n    val delimitersList = delimiters.asList()\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex -> findAnyOf(delimitersList, currentIndex, ignoreCase = ignoreCase, last = false)?.let { it.first to it.second.length } })\n\n}\n\n\n// split\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and matches at each position the first element in [delimiters]\n * that is equal to a delimiter in this instance at that position.\n */\npublic fun CharSequence.split(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        val delimiter = delimiters[0]\n        if (!delimiter.isEmpty()) {\n            return split(delimiter, ignoreCase, limit)\n        }\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.split(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        return split(delimiters[0].toString(), ignoreCase, limit)\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiter].\n * This is specialized version of split which receives single non-empty delimiter and offers better performance\n *\n * @param delimiter String used as delimiter\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\nprivate fun CharSequence.split(delimiter: String, ignoreCase: Boolean, limit: Int): List<String> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    var currentOffset = 0\n    var nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    if (nextIndex == -1 || limit == 1) {\n        return listOf(this.toString())\n    }\n\n    val isLimited = limit > 0\n    val result = ArrayList<String>(if (isLimited) limit.coerceAtMost(10) else 10)\n    do {\n        result.add(substring(currentOffset, nextIndex))\n        currentOffset = nextIndex + delimiter.length\n        // Do not search for next occurrence if we're reaching limit\n        if (isLimited && result.size == limit - 1) break\n        nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    } while (nextIndex != -1)\n\n    result.add(substring(currentOffset, length))\n    return result\n}\n\n/**\n * Splits this char sequence around matches of the given regular expression.\n *\n * @param limit Non-negative value specifying the maximum number of substrings to return.\n * Zero by default means no limit is set.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.split(regex: Regex, limit: Int = 0): List<String> = regex.split(this, limit)\n\n/**\n * Splits this char sequence to a sequence of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lineSequence(): Sequence<String> = splitToSequence(\"\\r\\n\", \"\\n\", \"\\r\")\n\n/**\n * Splits this char sequence to a list of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lines(): List<String> = lineSequence().toList()\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n/*\n * Based on GWT AbstractMap\n * Copyright 2007 Google Inc.\n */\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the read-only [Map] interface.\n *\n * The implementor is required to implement [entries] property, which should return read-only set of map entries.\n *\n * @param K the type of map keys. The map is invariant on its key type.\n * @param V the type of map values. The map is covariant on its value type.\n */\n@SinceKotlin(\"1.1\")\npublic abstract class AbstractMap<K, out V> protected constructor() : Map<K, V> {\n\n    override fun containsKey(key: K): Boolean {\n        return implFindEntry(key) != null\n    }\n\n    override fun containsValue(value: @UnsafeVariance V): Boolean = entries.any { it.value == value }\n\n    internal fun containsEntry(entry: Map.Entry<*, *>?): Boolean {\n        // since entry comes from @UnsafeVariance parameters it can be virtually anything\n        if (entry !is Map.Entry<*, *>) return false\n        val key = entry.key\n        val value = entry.value\n        val ourValue = get(key)\n\n        if (value != ourValue) {\n            return false\n        }\n\n        // Perhaps it was null and we don't contain the key?\n        if (ourValue == null && !containsKey(key)) {\n            return false\n        }\n\n        return true\n    }\n\n\n    /**\n     * Compares this map with other instance with the ordered structural equality.\n     *\n     * @return true, if [other] instance is a [Map] of the same size, all entries of which are contained in the [entries] set of this map.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is Map<*, *>) return false\n        if (size != other.size) return false\n\n        return other.entries.all { containsEntry(it) }\n    }\n\n    override operator fun get(key: K): V? = implFindEntry(key)?.value\n\n\n    /**\n     * Returns the hash code value for this map.\n     *\n     * It is the same as the hashCode of [entries] set.\n     */\n    override fun hashCode(): Int = entries.hashCode()\n\n    override fun isEmpty(): Boolean = size == 0\n    override val size: Int get() = entries.size\n\n    /**\n     * Returns a read-only [Set] of all keys in this map.\n     *\n     * Accessing this property first time creates a keys view from [entries].\n     * All subsequent accesses just return the created instance.\n     */\n    override val keys: Set<K>\n        get() {\n            if (_keys == null) {\n                _keys = object : AbstractSet<K>() {\n                    override operator fun contains(element: K): Boolean = containsKey(element)\n\n                    override operator fun iterator(): Iterator<K> {\n                        val entryIterator = entries.iterator()\n                        return object : Iterator<K> {\n                            override fun hasNext(): Boolean = entryIterator.hasNext()\n                            override fun next(): K = entryIterator.next().key\n                        }\n                    }\n\n                    override val size: Int get() = this@AbstractMap.size\n                }\n            }\n            return _keys!!\n        }\n\n    @kotlin.jvm.Volatile\n    private var _keys: Set<K>? = null\n\n\n    override fun toString(): String = entries.joinToString(\", \", \"{\", \"}\") { toString(it) }\n\n    private fun toString(entry: Map.Entry<K, V>): String = toString(entry.key) + \"=\" + toString(entry.value)\n\n    private fun toString(o: Any?): String = if (o === this) \"(this Map)\" else o.toString()\n\n    /**\n     * Returns a read-only [Collection] of all values in this map.\n     *\n     * Accessing this property first time creates a values view from [entries].\n     * All subsequent accesses just return the created instance.\n     */\n    override val values: Collection<V>\n        get() {\n            if (_values == null) {\n                _values = object : AbstractCollection<V>() {\n                    override operator fun contains(element: @UnsafeVariance V): Boolean = containsValue(element)\n\n                    override operator fun iterator(): Iterator<V> {\n                        val entryIterator = entries.iterator()\n                        return object : Iterator<V> {\n                            override fun hasNext(): Boolean = entryIterator.hasNext()\n                            override fun next(): V = entryIterator.next().value\n                        }\n                    }\n\n                    override val size: Int get() = this@AbstractMap.size\n                }\n            }\n            return _values!!\n        }\n\n    @kotlin.jvm.Volatile\n    private var _values: Collection<V>? = null\n\n    private fun implFindEntry(key: K): Map.Entry<K, V>? = entries.firstOrNull { it.key == key }\n\n    internal companion object {\n\n        internal fun entryHashCode(e: Map.Entry<*, *>): Int = with(e) { (key?.hashCode() ?: 0) xor (value?.hashCode() ?: 0) }\n        internal fun entryToString(e: Map.Entry<*, *>): String = with(e) { \"$key=$value\" }\n        internal fun entryEquals(e: Map.Entry<*, *>, other: Any?): Boolean {\n            if (other !is Map.Entry<*, *>) return false\n            return e.key == other.key && e.value == other.value\n        }\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the read-only [Set] interface.\n *\n * This class is intended to help implementing read-only sets so it doesn't support concurrent modification tracking.\n *\n * @param E the type of elements contained in the set. The set is covariant on its element type.\n */\n@SinceKotlin(\"1.1\")\npublic abstract class AbstractSet<out E> protected constructor() : AbstractCollection<E>(), Set<E> {\n\n    /**\n     * Compares this set with other set instance with the unordered structural equality.\n     *\n     * @return true, if [other] instance is a [Set] of the same size, all elements of which are contained in this set.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is Set<*>) return false\n        return setEquals(this, other)\n    }\n\n    /**\n     * Returns the hash code value for this set.\n     */\n    override fun hashCode(): Int = unorderedHashCode(this)\n\n    internal companion object {\n        internal fun unorderedHashCode(c: Collection<*>): Int {\n            var hashCode = 0\n            for (element in c) {\n                hashCode += (element?.hashCode() ?: 0)\n            }\n            return hashCode\n        }\n\n        internal fun setEquals(c: Set<*>, other: Set<*>): Boolean {\n            if (c.size != other.size) return false\n            return c.containsAll(other)\n        }\n    }\n\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n/**\n * Data class representing a value from a collection or sequence, along with its index in that collection or sequence.\n *\n * @property value the underlying value.\n * @property index the index of the value in the collection or sequence.\n */\npublic data class IndexedValue<out T>(public val index: Int, public val value: T)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n\npackage kotlin.collections\n\n/**\n * Returns the value for the given key, or the implicit default value for this map.\n * By default no implicit value is provided for maps and a [NoSuchElementException] is thrown.\n * To create a map with implicit default value use [withDefault] method.\n *\n * @throws NoSuchElementException when the map doesn't contain a value for the specified key and no implicit default was provided for that map.\n */\n@kotlin.jvm.JvmName(\"getOrImplicitDefaultNullable\")\n@PublishedApi\ninternal fun <K, V> Map<K, V>.getOrImplicitDefault(key: K): V {\n    if (this is MapWithDefault)\n        return this.getOrImplicitDefault(key)\n\n    return getOrElseNullable(key, { throw NoSuchElementException(\"Key $key is missing in the map.\") })\n}\n\n/**\n * Returns a wrapper of this read-only map, having the implicit default value provided with the specified function [defaultValue].\n *\n * This implicit default value is used when the original map doesn't contain a value for the key specified\n * and a value is obtained with [Map.getValue] function, for example when properties are delegated to the map.\n *\n * When this map already has an implicit default value provided with a former call to [withDefault], it is being replaced by this call.\n */\npublic fun <K, V> Map<K, V>.withDefault(defaultValue: (key: K) -> V): Map<K, V> =\n    when (this) {\n        is MapWithDefault -> this.map.withDefault(defaultValue)\n        else -> MapWithDefaultImpl(this, defaultValue)\n    }\n\n/**\n * Returns a wrapper of this mutable map, having the implicit default value provided with the specified function [defaultValue].\n *\n * This implicit default value is used when the original map doesn't contain a value for the key specified\n * and a value is obtained with [Map.getValue] function, for example when properties are delegated to the map.\n *\n * When this map already has an implicit default value provided with a former call to [withDefault], it is being replaced by this call.\n */\n@kotlin.jvm.JvmName(\"withDefaultMutable\")\npublic fun <K, V> MutableMap<K, V>.withDefault(defaultValue: (key: K) -> V): MutableMap<K, V> =\n    when (this) {\n        is MutableMapWithDefault -> this.map.withDefault(defaultValue)\n        else -> MutableMapWithDefaultImpl(this, defaultValue)\n    }\n\n\nprivate interface MapWithDefault<K, out V> : Map<K, V> {\n    public val map: Map<K, V>\n    public fun getOrImplicitDefault(key: K): V\n}\n\nprivate interface MutableMapWithDefault<K, V> : MutableMap<K, V>, MapWithDefault<K, V> {\n    public override val map: MutableMap<K, V>\n}\n\n\nprivate class MapWithDefaultImpl<K, out V>(public override val map: Map<K, V>, private val default: (key: K) -> V) : MapWithDefault<K, V> {\n    override fun equals(other: Any?): Boolean = map.equals(other)\n    override fun hashCode(): Int = map.hashCode()\n    override fun toString(): String = map.toString()\n    override val size: Int get() = map.size\n    override fun isEmpty(): Boolean = map.isEmpty()\n    override fun containsKey(key: K): Boolean = map.containsKey(key)\n    override fun containsValue(value: @UnsafeVariance V): Boolean = map.containsValue(value)\n    override fun get(key: K): V? = map.get(key)\n    override val keys: Set<K> get() = map.keys\n    override val values: Collection<V> get() = map.values\n    override val entries: Set<Map.Entry<K, V>> get() = map.entries\n\n    override fun getOrImplicitDefault(key: K): V = map.getOrElseNullable(key, { default(key) })\n}\n\nprivate class MutableMapWithDefaultImpl<K, V>(public override val map: MutableMap<K, V>, private val default: (key: K) -> V) : MutableMapWithDefault<K, V> {\n    override fun equals(other: Any?): Boolean = map.equals(other)\n    override fun hashCode(): Int = map.hashCode()\n    override fun toString(): String = map.toString()\n    override val size: Int get() = map.size\n    override fun isEmpty(): Boolean = map.isEmpty()\n    override fun containsKey(key: K): Boolean = map.containsKey(key)\n    override fun containsValue(value: @UnsafeVariance V): Boolean = map.containsValue(value)\n    override fun get(key: K): V? = map.get(key)\n    override val keys: MutableSet<K> get() = map.keys\n    override val values: MutableCollection<V> get() = map.values\n    override val entries: MutableSet<MutableMap.MutableEntry<K, V>> get() = map.entries\n\n    override fun put(key: K, value: V): V? = map.put(key, value)\n    override fun remove(key: K): V? = map.remove(key)\n    override fun putAll(from: Map<out K, V>) = map.putAll(from)\n    override fun clear() = map.clear()\n\n    override fun getOrImplicitDefault(key: K): V = map.getOrElseNullable(key, { default(key) })\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\nimport kotlin.random.Random\n\n/**\n * Removes a single instance of the specified element from this\n * collection, if it is present.\n *\n * Allows to overcome type-safety restriction of `remove` that requires to pass an element of type `E`.\n *\n * @return `true` if the element has been successfully removed; `false` if it was not present in the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.remove(element: T): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).remove(element)\n\n/**\n * Removes all of this collection's elements that are also contained in the specified collection.\n\n * Allows to overcome type-safety restriction of `removeAll` that requires to pass a collection of type `Collection<E>`.\n *\n * @return `true` if any of the specified elements was removed from the collection, `false` if the collection was not modified.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.removeAll(elements: Collection<T>): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).removeAll(elements)\n\n/**\n * Retains only the elements in this collection that are contained in the specified collection.\n *\n * Allows to overcome type-safety restriction of `retainAll` that requires to pass a collection of type `Collection<E>`.\n *\n * @return `true` if any element was removed from the collection, `false` if the collection was not modified.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.retainAll(elements: Collection<T>): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).retainAll(elements)\n\n/**\n * Adds the specified [element] to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(element: T) {\n    this.add(element)\n}\n\n/**\n * Adds all elements of the given [elements] collection to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Iterable<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] array to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Array<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] sequence to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Sequence<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Removes a single instance of the specified [element] from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(element: T) {\n    this.remove(element)\n}\n\n/**\n * Removes all elements contained in the given [elements] collection from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Iterable<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Removes all elements contained in the given [elements] array from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Array<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Removes all elements contained in the given [elements] sequence from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Sequence<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] collection to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Iterable<T>): Boolean {\n    when (elements) {\n        is Collection -> return addAll(elements)\n        else -> {\n            var result: Boolean = false\n            for (item in elements)\n                if (add(item)) result = true\n            return result\n        }\n    }\n}\n\n/**\n * Adds all elements of the given [elements] sequence to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Sequence<T>): Boolean {\n    var result: Boolean = false\n    for (item in elements) {\n        if (add(item)) result = true\n    }\n    return result\n}\n\n/**\n * Adds all elements of the given [elements] array to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Array<out T>): Boolean {\n    return addAll(elements.asList())\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] collection.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Iterable<T>): Boolean {\n    return removeAll(elements.convertToSetForSetOperationWith(this))\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] sequence.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Sequence<T>): Boolean {\n    val set = elements.toHashSet()\n    return set.isNotEmpty() && removeAll(set)\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] array.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Array<out T>): Boolean {\n    return elements.isNotEmpty() && removeAll(elements.toHashSet())\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] collection.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Iterable<T>): Boolean {\n    return retainAll(elements.convertToSetForSetOperationWith(this))\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] array.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Array<out T>): Boolean {\n    if (elements.isNotEmpty())\n        return retainAll(elements.toHashSet())\n    else\n        return retainNothing()\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] sequence.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Sequence<T>): Boolean {\n    val set = elements.toHashSet()\n    if (set.isNotEmpty())\n        return retainAll(set)\n    else\n        return retainNothing()\n}\n\nprivate fun MutableCollection<*>.retainNothing(): Boolean {\n    val result = isNotEmpty()\n    clear()\n    return result\n}\n\n\n/**\n * Removes all elements from this [MutableIterable] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when no elements were removed and collection was not modified.\n */\npublic fun <T> MutableIterable<T>.removeAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, true)\n\n/**\n * Retains only elements of this [MutableIterable] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when all elements were retained and collection was not modified.\n */\npublic fun <T> MutableIterable<T>.retainAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, false)\n\nprivate fun <T> MutableIterable<T>.filterInPlace(predicate: (T) -> Boolean, predicateResultToRemove: Boolean): Boolean {\n    var result = false\n    with(iterator()) {\n        while (hasNext())\n            if (predicate(next()) == predicateResultToRemove) {\n                remove()\n                result = true\n            }\n    }\n    return result\n}\n\n\n/**\n * Returns a new list with the elements of this list randomly shuffled\n * using the specified [random] instance as the source of randomness.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Iterable<T>.shuffled(random: Random): List<T> = toMutableList().apply { shuffle(random) }\n\n\n/**\n * Removes the element at the specified [index] from this list.\n * In Kotlin one should use the [MutableList.removeAt] function instead.\n */\n@Deprecated(\"Use removeAt(index) instead.\", ReplaceWith(\"removeAt(index)\"), level = DeprecationLevel.ERROR)\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList<T>.remove(index: Int): T = removeAt(index)\n\n/**\n * Removes the first element from this mutable list and returns that removed element, or throws [NoSuchElementException] if this list is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun <T> MutableList<T>.removeFirst(): T = if (isEmpty()) throw NoSuchElementException(\"List is empty.\") else removeAt(0)\n\n/**\n * Removes the first element from this mutable list and returns that removed element, or returns `null` if this list is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun <T> MutableList<T>.removeFirstOrNull(): T? = if (isEmpty()) null else removeAt(0)\n\n/**\n * Removes the last element from this mutable list and returns that removed element, or throws [NoSuchElementException] if this list is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun <T> MutableList<T>.removeLast(): T = if (isEmpty()) throw NoSuchElementException(\"List is empty.\") else removeAt(lastIndex)\n\n/**\n * Removes the last element from this mutable list and returns that removed element, or returns `null` if this list is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun <T> MutableList<T>.removeLastOrNull(): T? = if (isEmpty()) null else removeAt(lastIndex)\n\n/**\n * Removes all elements from this [MutableList] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when no elements were removed and collection was not modified.\n */\npublic fun <T> MutableList<T>.removeAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, true)\n\n/**\n * Retains only elements of this [MutableList] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when all elements were retained and collection was not modified.\n */\npublic fun <T> MutableList<T>.retainAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, false)\n\nprivate fun <T> MutableList<T>.filterInPlace(predicate: (T) -> Boolean, predicateResultToRemove: Boolean): Boolean {\n    if (this !is RandomAccess)\n        return (this as MutableIterable<T>).filterInPlace(predicate, predicateResultToRemove)\n\n    var writeIndex: Int = 0\n    for (readIndex in 0..lastIndex) {\n        val element = this[readIndex]\n        if (predicate(element) == predicateResultToRemove)\n            continue\n\n        if (writeIndex != readIndex)\n            this[writeIndex] = element\n\n        writeIndex++\n    }\n    if (writeIndex < size) {\n        for (removeIndex in lastIndex downTo writeIndex)\n            removeAt(removeIndex)\n\n        return true\n    } else {\n        return false\n    }\n}\n\n/**\n * Randomly shuffles elements in this mutable list using the specified [random] instance as the source of randomness.\n *\n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> MutableList<T>.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SequencesKt\")\n\npackage kotlin.sequences\n\n/**\n * Given an [iterator] function constructs a [Sequence] that returns values through the [Iterator]\n * provided by that function.\n * The values are evaluated lazily, and the sequence is potentially infinite.\n *\n * @sample samples.collections.Sequences.Building.sequenceFromIterator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence(crossinline iterator: () -> Iterator<T>): Sequence<T> = object : Sequence<T> {\n    override fun iterator(): Iterator<T> = iterator()\n}\n\n/**\n * Creates a sequence that returns all elements from this iterator. The sequence is constrained to be iterated only once.\n *\n * @sample samples.collections.Sequences.Building.sequenceFromIterator\n */\npublic fun <T> Iterator<T>.asSequence(): Sequence<T> = Sequence { this }.constrainOnce()\n\n/**\n * Creates a sequence that returns the specified values.\n *\n * @sample samples.collections.Sequences.Building.sequenceOfValues\n */\npublic fun <T> sequenceOf(vararg elements: T): Sequence<T> = if (elements.isEmpty()) emptySequence() else elements.asSequence()\n\n/**\n * Returns an empty sequence.\n */\npublic fun <T> emptySequence(): Sequence<T> = EmptySequence\n\nprivate object EmptySequence : Sequence<Nothing>, DropTakeSequence<Nothing> {\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun drop(n: Int) = EmptySequence\n    override fun take(n: Int) = EmptySequence\n}\n\n/**\n * Returns this sequence if it's not `null` and the empty sequence otherwise.\n * @sample samples.collections.Sequences.Usage.sequenceOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>?.orEmpty(): Sequence<T> = this ?: emptySequence()\n\n\n/**\n * Returns a sequence that iterates through the elements either of this sequence\n * or, if this sequence turns out to be empty, of the sequence returned by [defaultValue] function.\n *\n * @sample samples.collections.Sequences.Usage.sequenceIfEmpty\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Sequence<T>.ifEmpty(defaultValue: () -> Sequence<T>): Sequence<T> = sequence {\n    val iterator = this@ifEmpty.iterator()\n    if (iterator.hasNext()) {\n        yieldAll(iterator)\n    } else {\n        yieldAll(defaultValue())\n    }\n}\n\n/**\n * Returns a sequence of all elements from all sequences in this sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T> Sequence<Sequence<T>>.flatten(): Sequence<T> = flatten { it.iterator() }\n\n/**\n * Returns a sequence of all elements from all iterables in this sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@kotlin.jvm.JvmName(\"flattenSequenceOfIterable\")\npublic fun <T> Sequence<Iterable<T>>.flatten(): Sequence<T> = flatten { it.iterator() }\n\nprivate fun <T, R> Sequence<T>.flatten(iterator: (T) -> Iterator<R>): Sequence<R> {\n    if (this is TransformingSequence<*, *>) {\n        return (this as TransformingSequence<*, T>).flatten(iterator)\n    }\n    return FlatteningSequence(this, { it }, iterator)\n}\n\n/**\n * Returns a pair of lists, where\n * *first* list is built from the first values of each pair from this sequence,\n * *second* list is built from the second values of each pair from this sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T, R> Sequence<Pair<T, R>>.unzip(): Pair<List<T>, List<R>> {\n    val listT = ArrayList<T>()\n    val listR = ArrayList<R>()\n    for (pair in this) {\n        listT.add(pair.first)\n        listR.add(pair.second)\n    }\n    return listT to listR\n}\n\n/**\n * A sequence that returns the values from the underlying [sequence] that either match or do not match\n * the specified [predicate].\n *\n * @param sendWhen If `true`, values for which the predicate returns `true` are returned. Otherwise,\n * values for which the predicate returns `false` are returned\n */\ninternal class FilteringSequence<T>(\n    private val sequence: Sequence<T>,\n    private val sendWhen: Boolean = true,\n    private val predicate: (T) -> Boolean\n) : Sequence<T> {\n\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        val iterator = sequence.iterator()\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var nextItem: T? = null\n\n        private fun calcNext() {\n            while (iterator.hasNext()) {\n                val item = iterator.next()\n                if (predicate(item) == sendWhen) {\n                    nextItem = item\n                    nextState = 1\n                    return\n                }\n            }\n            nextState = 0\n        }\n\n        override fun next(): T {\n            if (nextState == -1)\n                calcNext()\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem\n            nextItem = null\n            nextState = -1\n            @Suppress(\"UNCHECKED_CAST\")\n            return result as T\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * A sequence which returns the results of applying the given [transformer] function to the values\n * in the underlying [sequence].\n */\n\ninternal class TransformingSequence<T, R>\nconstructor(private val sequence: Sequence<T>, private val transformer: (T) -> R) : Sequence<R> {\n    override fun iterator(): Iterator<R> = object : Iterator<R> {\n        val iterator = sequence.iterator()\n        override fun next(): R {\n            return transformer(iterator.next())\n        }\n\n        override fun hasNext(): Boolean {\n            return iterator.hasNext()\n        }\n    }\n\n    internal fun <E> flatten(iterator: (R) -> Iterator<E>): Sequence<E> {\n        return FlatteningSequence<T, R, E>(sequence, transformer, iterator)\n    }\n}\n\n/**\n * A sequence which returns the results of applying the given [transformer] function to the values\n * in the underlying [sequence], where the transformer function takes the index of the value in the underlying\n * sequence along with the value itself.\n */\ninternal class TransformingIndexedSequence<T, R>\nconstructor(private val sequence: Sequence<T>, private val transformer: (Int, T) -> R) : Sequence<R> {\n    override fun iterator(): Iterator<R> = object : Iterator<R> {\n        val iterator = sequence.iterator()\n        var index = 0\n        override fun next(): R {\n            return transformer(checkIndexOverflow(index++), iterator.next())\n        }\n\n        override fun hasNext(): Boolean {\n            return iterator.hasNext()\n        }\n    }\n}\n\n/**\n * A sequence which combines values from the underlying [sequence] with their indices and returns them as\n * [IndexedValue] objects.\n */\ninternal class IndexingSequence<T>\nconstructor(private val sequence: Sequence<T>) : Sequence<IndexedValue<T>> {\n    override fun iterator(): Iterator<IndexedValue<T>> = object : Iterator<IndexedValue<T>> {\n        val iterator = sequence.iterator()\n        var index = 0\n        override fun next(): IndexedValue<T> {\n            return IndexedValue(checkIndexOverflow(index++), iterator.next())\n        }\n\n        override fun hasNext(): Boolean {\n            return iterator.hasNext()\n        }\n    }\n}\n\n/**\n * A sequence which takes the values from two parallel underlying sequences, passes them to the given\n * [transform] function and returns the values returned by that function. The sequence stops returning\n * values as soon as one of the underlying sequences stops returning values.\n */\ninternal class MergingSequence<T1, T2, V>\nconstructor(\n    private val sequence1: Sequence<T1>,\n    private val sequence2: Sequence<T2>,\n    private val transform: (T1, T2) -> V\n) : Sequence<V> {\n    override fun iterator(): Iterator<V> = object : Iterator<V> {\n        val iterator1 = sequence1.iterator()\n        val iterator2 = sequence2.iterator()\n        override fun next(): V {\n            return transform(iterator1.next(), iterator2.next())\n        }\n\n        override fun hasNext(): Boolean {\n            return iterator1.hasNext() && iterator2.hasNext()\n        }\n    }\n}\n\ninternal class FlatteningSequence<T, R, E>\nconstructor(\n    private val sequence: Sequence<T>,\n    private val transformer: (T) -> R,\n    private val iterator: (R) -> Iterator<E>\n) : Sequence<E> {\n    override fun iterator(): Iterator<E> = object : Iterator<E> {\n        val iterator = sequence.iterator()\n        var itemIterator: Iterator<E>? = null\n\n        override fun next(): E {\n            if (!ensureItemIterator())\n                throw NoSuchElementException()\n            return itemIterator!!.next()\n        }\n\n        override fun hasNext(): Boolean {\n            return ensureItemIterator()\n        }\n\n        private fun ensureItemIterator(): Boolean {\n            if (itemIterator?.hasNext() == false)\n                itemIterator = null\n\n            while (itemIterator == null) {\n                if (!iterator.hasNext()) {\n                    return false\n                } else {\n                    val element = iterator.next()\n                    val nextItemIterator = iterator(transformer(element))\n                    if (nextItemIterator.hasNext()) {\n                        itemIterator = nextItemIterator\n                        return true\n                    }\n                }\n            }\n            return true\n        }\n    }\n}\n\n/**\n * A sequence that supports drop(n) and take(n) operations\n */\ninternal interface DropTakeSequence<T> : Sequence<T> {\n    fun drop(n: Int): Sequence<T>\n    fun take(n: Int): Sequence<T>\n}\n\n/**\n * A sequence that skips [startIndex] values from the underlying [sequence]\n * and stops returning values right before [endIndex], i.e. stops at `endIndex - 1`\n */\ninternal class SubSequence<T>(\n    private val sequence: Sequence<T>,\n    private val startIndex: Int,\n    private val endIndex: Int\n) : Sequence<T>, DropTakeSequence<T> {\n\n    init {\n        require(startIndex >= 0) { \"startIndex should be non-negative, but is $startIndex\" }\n        require(endIndex >= 0) { \"endIndex should be non-negative, but is $endIndex\" }\n        require(endIndex >= startIndex) { \"endIndex should be not less than startIndex, but was $endIndex < $startIndex\" }\n    }\n\n    private val count: Int get() = endIndex - startIndex\n\n    override fun drop(n: Int): Sequence<T> = if (n >= count) emptySequence() else SubSequence(sequence, startIndex + n, endIndex)\n    override fun take(n: Int): Sequence<T> = if (n >= count) this else SubSequence(sequence, startIndex, startIndex + n)\n\n    override fun iterator() = object : Iterator<T> {\n\n        val iterator = sequence.iterator()\n        var position = 0\n\n        // Shouldn't be called from constructor to avoid premature iteration\n        private fun drop() {\n            while (position < startIndex && iterator.hasNext()) {\n                iterator.next()\n                position++\n            }\n        }\n\n        override fun hasNext(): Boolean {\n            drop()\n            return (position < endIndex) && iterator.hasNext()\n        }\n\n        override fun next(): T {\n            drop()\n            if (position >= endIndex)\n                throw NoSuchElementException()\n            position++\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * A sequence that returns at most [count] values from the underlying [sequence], and stops returning values\n * as soon as that count is reached.\n */\ninternal class TakeSequence<T>(\n    private val sequence: Sequence<T>,\n    private val count: Int\n) : Sequence<T>, DropTakeSequence<T> {\n\n    init {\n        require(count >= 0) { \"count must be non-negative, but was $count.\" }\n    }\n\n    override fun drop(n: Int): Sequence<T> = if (n >= count) emptySequence() else SubSequence(sequence, n, count)\n    override fun take(n: Int): Sequence<T> = if (n >= count) this else TakeSequence(sequence, n)\n\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        var left = count\n        val iterator = sequence.iterator()\n\n        override fun next(): T {\n            if (left == 0)\n                throw NoSuchElementException()\n            left--\n            return iterator.next()\n        }\n\n        override fun hasNext(): Boolean {\n            return left > 0 && iterator.hasNext()\n        }\n    }\n}\n\n/**\n * A sequence that returns values from the underlying [sequence] while the [predicate] function returns\n * `true`, and stops returning values once the function returns `false` for the next element.\n */\ninternal class TakeWhileSequence<T>\nconstructor(\n    private val sequence: Sequence<T>,\n    private val predicate: (T) -> Boolean\n) : Sequence<T> {\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        val iterator = sequence.iterator()\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var nextItem: T? = null\n\n        private fun calcNext() {\n            if (iterator.hasNext()) {\n                val item = iterator.next()\n                if (predicate(item)) {\n                    nextState = 1\n                    nextItem = item\n                    return\n                }\n            }\n            nextState = 0\n        }\n\n        override fun next(): T {\n            if (nextState == -1)\n                calcNext() // will change nextState\n            if (nextState == 0)\n                throw NoSuchElementException()\n            @Suppress(\"UNCHECKED_CAST\")\n            val result = nextItem as T\n\n            // Clean next to avoid keeping reference on yielded instance\n            nextItem = null\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext() // will change nextState\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * A sequence that skips the specified number of values from the underlying [sequence] and returns\n * all values after that.\n */\ninternal class DropSequence<T>(\n    private val sequence: Sequence<T>,\n    private val count: Int\n) : Sequence<T>, DropTakeSequence<T> {\n    init {\n        require(count >= 0) { \"count must be non-negative, but was $count.\" }\n    }\n\n    override fun drop(n: Int): Sequence<T> = (count + n).let { n1 -> if (n1 < 0) DropSequence(this, n) else DropSequence(sequence, n1) }\n    override fun take(n: Int): Sequence<T> = (count + n).let { n1 -> if (n1 < 0) TakeSequence(this, n) else SubSequence(sequence, count, n1) }\n\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        val iterator = sequence.iterator()\n        var left = count\n\n        // Shouldn't be called from constructor to avoid premature iteration\n        private fun drop() {\n            while (left > 0 && iterator.hasNext()) {\n                iterator.next()\n                left--\n            }\n        }\n\n        override fun next(): T {\n            drop()\n            return iterator.next()\n        }\n\n        override fun hasNext(): Boolean {\n            drop()\n            return iterator.hasNext()\n        }\n    }\n}\n\n/**\n * A sequence that skips the values from the underlying [sequence] while the given [predicate] returns `true` and returns\n * all values after that.\n */\ninternal class DropWhileSequence<T>\nconstructor(\n    private val sequence: Sequence<T>,\n    private val predicate: (T) -> Boolean\n) : Sequence<T> {\n\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        val iterator = sequence.iterator()\n        var dropState: Int = -1 // -1 for not dropping, 1 for nextItem, 0 for normal iteration\n        var nextItem: T? = null\n\n        private fun drop() {\n            while (iterator.hasNext()) {\n                val item = iterator.next()\n                if (!predicate(item)) {\n                    nextItem = item\n                    dropState = 1\n                    return\n                }\n            }\n            dropState = 0\n        }\n\n        override fun next(): T {\n            if (dropState == -1)\n                drop()\n\n            if (dropState == 1) {\n                @Suppress(\"UNCHECKED_CAST\")\n                val result = nextItem as T\n                nextItem = null\n                dropState = 0\n                return result\n            }\n            return iterator.next()\n        }\n\n        override fun hasNext(): Boolean {\n            if (dropState == -1)\n                drop()\n            return dropState == 1 || iterator.hasNext()\n        }\n    }\n}\n\ninternal class DistinctSequence<T, K>(private val source: Sequence<T>, private val keySelector: (T) -> K) : Sequence<T> {\n    override fun iterator(): Iterator<T> = DistinctIterator(source.iterator(), keySelector)\n}\n\nprivate class DistinctIterator<T, K>(private val source: Iterator<T>, private val keySelector: (T) -> K) : AbstractIterator<T>() {\n    private val observed = HashSet<K>()\n\n    override fun computeNext() {\n        while (source.hasNext()) {\n            val next = source.next()\n            val key = keySelector(next)\n\n            if (observed.add(key)) {\n                setNext(next)\n                return\n            }\n        }\n\n        done()\n    }\n}\n\n\nprivate class GeneratorSequence<T : Any>(private val getInitialValue: () -> T?, private val getNextValue: (T) -> T?) : Sequence<T> {\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        var nextItem: T? = null\n        var nextState: Int = -2 // -2 for initial unknown, -1 for next unknown, 0 for done, 1 for continue\n\n        private fun calcNext() {\n            nextItem = if (nextState == -2) getInitialValue() else getNextValue(nextItem!!)\n            nextState = if (nextItem == null) 0 else 1\n        }\n\n        override fun next(): T {\n            if (nextState < 0)\n                calcNext()\n\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem as T\n            // Do not clean nextItem (to avoid keeping reference on yielded instance) -- need to keep state for getNextValue\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState < 0)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * Returns a wrapper sequence that provides values of this sequence, but ensures it can be iterated only one time.\n *\n * The operation is _intermediate_ and _stateless_.\n *\n * [IllegalStateException] is thrown on iterating the returned sequence from the second time.\n *\n */\npublic fun <T> Sequence<T>.constrainOnce(): Sequence<T> {\n    // as? does not work in js\n    //return this as? ConstrainedOnceSequence<T> ?: ConstrainedOnceSequence(this)\n    return if (this is ConstrainedOnceSequence<T>) this else ConstrainedOnceSequence(this)\n}\n\n\n/**\n * Returns a sequence which invokes the function to calculate the next value on each iteration until the function returns `null`.\n *\n * The returned sequence is constrained to be iterated only once.\n *\n * @see constrainOnce\n * @see kotlin.sequences.sequence\n *\n * @sample samples.collections.Sequences.Building.generateSequence\n */\npublic fun <T : Any> generateSequence(nextFunction: () -> T?): Sequence<T> {\n    return GeneratorSequence(nextFunction, { nextFunction() }).constrainOnce()\n}\n\n/**\n * Returns a sequence defined by the starting value [seed] and the function [nextFunction],\n * which is invoked to calculate the next value based on the previous one on each iteration.\n *\n * The sequence produces values until it encounters first `null` value.\n * If [seed] is `null`, an empty sequence is produced.\n *\n * The sequence can be iterated multiple times, each time starting with [seed].\n *\n * @see kotlin.sequences.sequence\n *\n * @sample samples.collections.Sequences.Building.generateSequenceWithSeed\n */\n@kotlin.internal.LowPriorityInOverloadResolution\npublic fun <T : Any> generateSequence(seed: T?, nextFunction: (T) -> T?): Sequence<T> =\n    if (seed == null)\n        EmptySequence\n    else\n        GeneratorSequence({ seed }, nextFunction)\n\n/**\n * Returns a sequence defined by the function [seedFunction], which is invoked to produce the starting value,\n * and the [nextFunction], which is invoked to calculate the next value based on the previous one on each iteration.\n *\n * The sequence produces values until it encounters first `null` value.\n * If [seedFunction] returns `null`, an empty sequence is produced.\n *\n * The sequence can be iterated multiple times.\n *\n * @see kotlin.sequences.sequence\n *\n * @sample samples.collections.Sequences.Building.generateSequenceWithLazySeed\n */\npublic fun <T : Any> generateSequence(seedFunction: () -> T?, nextFunction: (T) -> T?): Sequence<T> =\n    GeneratorSequence(seedFunction, nextFunction)\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SequencesKt\")\n@file:UseExperimental(ExperimentalTypeInference::class)\n\npackage kotlin.sequences\n\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\nimport kotlin.experimental.ExperimentalTypeInference\n\n/**\n * Builds a [Sequence] lazily yielding values one by one.\n *\n * @see kotlin.sequences.generateSequence\n *\n * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n * @sample samples.collections.Sequences.Building.buildFibonacciSequence\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> sequence(@BuilderInference block: suspend SequenceScope<T>.() -> Unit): Sequence<T> = Sequence { iterator(block) }\n\n@SinceKotlin(\"1.3\")\n@Deprecated(\"Use 'sequence { }' function instead.\", ReplaceWith(\"sequence(builderAction)\"), level = DeprecationLevel.ERROR)\n@kotlin.internal.InlineOnly\npublic inline fun <T> buildSequence(@BuilderInference noinline builderAction: suspend SequenceScope<T>.() -> Unit): Sequence<T> = Sequence { iterator(builderAction) }\n\n/**\n * Builds an [Iterator] lazily yielding values one by one.\n *\n * @sample samples.collections.Sequences.Building.buildIterator\n * @sample samples.collections.Iterables.Building.iterable\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> iterator(@BuilderInference block: suspend SequenceScope<T>.() -> Unit): Iterator<T> {\n    val iterator = SequenceBuilderIterator<T>()\n    iterator.nextStep = block.createCoroutineUnintercepted(receiver = iterator, completion = iterator)\n    return iterator\n}\n\n@SinceKotlin(\"1.3\")\n@Deprecated(\"Use 'iterator { }' function instead.\", ReplaceWith(\"iterator(builderAction)\"), level = DeprecationLevel.ERROR)\n@kotlin.internal.InlineOnly\npublic inline fun <T> buildIterator(@BuilderInference noinline builderAction: suspend SequenceScope<T>.() -> Unit): Iterator<T> = iterator(builderAction)\n\n/**\n * The scope for yielding values of a [Sequence] or an [Iterator], provides [yield] and [yieldAll] suspension functions.\n *\n * @see sequence\n * @see iterator\n *\n * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n * @sample samples.collections.Sequences.Building.buildFibonacciSequence\n */\n@RestrictsSuspension\n@SinceKotlin(\"1.3\")\npublic abstract class SequenceScope<in T> internal constructor() {\n    /**\n     * Yields a value to the [Iterator] being built and suspends\n     * until the next value is requested.\n     *\n     * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n     * @sample samples.collections.Sequences.Building.buildFibonacciSequence\n     */\n    public abstract suspend fun yield(value: T)\n\n    /**\n     * Yields all values from the `iterator` to the [Iterator] being built\n     * and suspends until all these values are iterated and the next one is requested.\n     *\n     * The sequence of values returned by the given iterator can be potentially infinite.\n     *\n     * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n     */\n    public abstract suspend fun yieldAll(iterator: Iterator<T>)\n\n    /**\n     * Yields a collections of values to the [Iterator] being built\n     * and suspends until all these values are iterated and the next one is requested.\n     *\n     * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n     */\n    public suspend fun yieldAll(elements: Iterable<T>) {\n        if (elements is Collection && elements.isEmpty()) return\n        return yieldAll(elements.iterator())\n    }\n\n    /**\n     * Yields potentially infinite sequence of values  to the [Iterator] being built\n     * and suspends until all these values are iterated and the next one is requested.\n     *\n     * The sequence can be potentially infinite.\n     *\n     * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n     */\n    public suspend fun yieldAll(sequence: Sequence<T>) = yieldAll(sequence.iterator())\n}\n\n@Deprecated(\"Use SequenceScope class instead.\", ReplaceWith(\"SequenceScope<T>\"), level = DeprecationLevel.ERROR)\npublic typealias SequenceBuilder<T> = SequenceScope<T>\n\nprivate typealias State = Int\n\nprivate const val State_NotReady: State = 0\nprivate const val State_ManyNotReady: State = 1\nprivate const val State_ManyReady: State = 2\nprivate const val State_Ready: State = 3\nprivate const val State_Done: State = 4\nprivate const val State_Failed: State = 5\n\nprivate class SequenceBuilderIterator<T> : SequenceScope<T>(), Iterator<T>, Continuation<Unit> {\n    private var state = State_NotReady\n    private var nextValue: T? = null\n    private var nextIterator: Iterator<T>? = null\n    var nextStep: Continuation<Unit>? = null\n\n    override fun hasNext(): Boolean {\n        while (true) {\n            when (state) {\n                State_NotReady -> {}\n                State_ManyNotReady ->\n                    if (nextIterator!!.hasNext()) {\n                        state = State_ManyReady\n                        return true\n                    } else {\n                        nextIterator = null\n                    }\n                State_Done -> return false\n                State_Ready, State_ManyReady -> return true\n                else -> throw exceptionalState()\n            }\n\n            state = State_Failed\n            val step = nextStep!!\n            nextStep = null\n            step.resume(Unit)\n        }\n    }\n\n    override fun next(): T {\n        when (state) {\n            State_NotReady, State_ManyNotReady -> return nextNotReady()\n            State_ManyReady -> {\n                state = State_ManyNotReady\n                return nextIterator!!.next()\n            }\n            State_Ready -> {\n                state = State_NotReady\n                @Suppress(\"UNCHECKED_CAST\")\n                val result = nextValue as T\n                nextValue = null\n                return result\n            }\n            else -> throw exceptionalState()\n        }\n    }\n\n    private fun nextNotReady(): T {\n        if (!hasNext()) throw NoSuchElementException() else return next()\n    }\n\n    private fun exceptionalState(): Throwable = when (state) {\n        State_Done -> NoSuchElementException()\n        State_Failed -> IllegalStateException(\"Iterator has failed.\")\n        else -> IllegalStateException(\"Unexpected state of the iterator: $state\")\n    }\n\n\n    override suspend fun yield(value: T) {\n        nextValue = value\n        state = State_Ready\n        return suspendCoroutineUninterceptedOrReturn { c ->\n            nextStep = c\n            COROUTINE_SUSPENDED\n        }\n    }\n\n    override suspend fun yieldAll(iterator: Iterator<T>) {\n        if (!iterator.hasNext()) return\n        nextIterator = iterator\n        state = State_ManyReady\n        return suspendCoroutineUninterceptedOrReturn { c ->\n            nextStep = c\n            COROUTINE_SUSPENDED\n        }\n    }\n\n    // Completion continuation implementation\n    override fun resumeWith(result: Result<Unit>) {\n        result.getOrThrow() // just rethrow exception if it is there\n        state = State_Done\n    }\n\n    override val context: CoroutineContext\n        get() = EmptyCoroutineContext\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\n/**\n * Marks coroutine context element that intercepts coroutine continuations.\n * The coroutines framework uses [ContinuationInterceptor.Key] to retrieve the interceptor and\n * intercepts all coroutine continuations with [interceptContinuation] invocations.\n *\n * [ContinuationInterceptor] behaves like a [polymorphic element][AbstractCoroutineContextKey], meaning that\n * its implementation delegates [get][CoroutineContext.Element.get] and [minusKey][CoroutineContext.Element.minusKey]\n * to [getPolymorphicElement] and [minusPolymorphicKey] respectively.\n * [ContinuationInterceptor] subtypes can be extracted from the coroutine context using either [ContinuationInterceptor.Key]\n * or subtype key if it extends [AbstractCoroutineContextKey].\n */\n@SinceKotlin(\"1.3\")\npublic interface ContinuationInterceptor : CoroutineContext.Element {\n    /**\n     * The key that defines *the* context interceptor.\n     */\n    companion object Key : CoroutineContext.Key<ContinuationInterceptor>\n\n    /**\n     * Returns continuation that wraps the original [continuation], thus intercepting all resumptions.\n     * This function is invoked by coroutines framework when needed and the resulting continuations are\n     * cached internally per each instance of the original [continuation].\n     *\n     * This function may simply return original [continuation] if it does not want to intercept this particular continuation.\n     *\n     * When the original [continuation] completes, coroutine framework invokes [releaseInterceptedContinuation]\n     * with the resulting continuation if it was intercepted, that is if `interceptContinuation` had previously\n     * returned a different continuation instance.\n     */\n    public fun <T> interceptContinuation(continuation: Continuation<T>): Continuation<T>\n\n    /**\n     * Invoked for the continuation instance returned by [interceptContinuation] when the original\n     * continuation completes and will not be used anymore. This function is invoked only if [interceptContinuation]\n     * had returned a different continuation instance from the one it was invoked with.\n     *\n     * Default implementation does nothing.\n     *\n     * @param continuation Continuation instance returned by this interceptor's [interceptContinuation] invocation.\n     */\n    public fun releaseInterceptedContinuation(continuation: Continuation<*>) {\n        /* do nothing by default */\n    }\n\n    public override operator fun <E : CoroutineContext.Element> get(key: CoroutineContext.Key<E>): E? {\n        // getPolymorphicKey specialized for ContinuationInterceptor key\n        @OptIn(ExperimentalStdlibApi::class)\n        if (key is AbstractCoroutineContextKey<*, *>) {\n            @Suppress(\"UNCHECKED_CAST\")\n            return if (key.isSubKey(this.key)) key.tryCast(this) as? E else null\n        }\n        @Suppress(\"UNCHECKED_CAST\")\n        return if (ContinuationInterceptor === key) this as E else null\n    }\n\n\n    public override fun minusKey(key: CoroutineContext.Key<*>): CoroutineContext {\n        // minusPolymorphicKey specialized for ContinuationInterceptor key\n        @OptIn(ExperimentalStdlibApi::class)\n        if (key is AbstractCoroutineContextKey<*, *>) {\n            return if (key.isSubKey(this.key) && key.tryCast(this) != null) EmptyCoroutineContext else this\n        }\n        return if (ContinuationInterceptor === key) EmptyCoroutineContext else this\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\n/**\n * Persistent context for the coroutine. It is an indexed set of [Element] instances.\n * An indexed set is a mix between a set and a map.\n * Every element in this set has a unique [Key].\n */\n@SinceKotlin(\"1.3\")\npublic interface CoroutineContext {\n    /**\n     * Returns the element with the given [key] from this context or `null`.\n     */\n    public operator fun <E : Element> get(key: Key<E>): E?\n\n    /**\n     * Accumulates entries of this context starting with [initial] value and applying [operation]\n     * from left to right to current accumulator value and each element of this context.\n     */\n    public fun <R> fold(initial: R, operation: (R, Element) -> R): R\n\n    /**\n     * Returns a context containing elements from this context and elements from  other [context].\n     * The elements from this context with the same key as in the other one are dropped.\n     */\n    public operator fun plus(context: CoroutineContext): CoroutineContext =\n        if (context === EmptyCoroutineContext) this else // fast path -- avoid lambda creation\n            context.fold(this) { acc, element ->\n                val removed = acc.minusKey(element.key)\n                if (removed === EmptyCoroutineContext) element else {\n                    // make sure interceptor is always last in the context (and thus is fast to get when present)\n                    val interceptor = removed[ContinuationInterceptor]\n                    if (interceptor == null) CombinedContext(removed, element) else {\n                        val left = removed.minusKey(ContinuationInterceptor)\n                        if (left === EmptyCoroutineContext) CombinedContext(element, interceptor) else\n                            CombinedContext(CombinedContext(left, element), interceptor)\n                    }\n                }\n            }\n\n    /**\n     * Returns a context containing elements from this context, but without an element with\n     * the specified [key].\n     */\n    public fun minusKey(key: Key<*>): CoroutineContext\n\n    /**\n     * Key for the elements of [CoroutineContext]. [E] is a type of element with this key.\n     */\n    public interface Key<E : Element>\n\n    /**\n     * An element of the [CoroutineContext]. An element of the coroutine context is a singleton context by itself.\n     */\n    public interface Element : CoroutineContext {\n        /**\n         * A key of this coroutine context element.\n         */\n        public val key: Key<*>\n\n        public override operator fun <E : Element> get(key: Key<E>): E? =\n            @Suppress(\"UNCHECKED_CAST\")\n            if (this.key == key) this as E else null\n\n        public override fun <R> fold(initial: R, operation: (R, Element) -> R): R =\n            operation(initial, this)\n\n        public override fun minusKey(key: Key<*>): CoroutineContext =\n            if (this.key == key) EmptyCoroutineContext else this\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.coroutines.CoroutineContext.Element\nimport kotlin.coroutines.CoroutineContext.Key\n\n/**\n * Base class for [CoroutineContext.Element] implementations.\n */\n@SinceKotlin(\"1.3\")\npublic abstract class AbstractCoroutineContextElement(public override val key: Key<*>) : Element\n\n/**\n * Base class for [CoroutineContext.Key] associated with polymorphic [CoroutineContext.Element] implementation.\n * Polymorphic element implementation implies delegating its [get][Element.get] and [minusKey][Element.minusKey]\n * to [getPolymorphicElement] and [minusPolymorphicKey] respectively.\n *\n * Polymorphic elements can be extracted from the coroutine context using both element key and its supertype key.\n * Example of polymorphic elements:\n * ```\n * open class BaseElement : CoroutineContext.Element {\n *     companion object Key : CoroutineContext.Key<BaseElement>\n *     override val key: CoroutineContext.Key<*> get() = Key\n *     // It is important to use getPolymorphicKey and minusPolymorphicKey\n *     override fun <E : CoroutineContext.Element> get(key: CoroutineContext.Key<E>): E? = getPolymorphicElement(key)\n *     override fun minusKey(key: CoroutineContext.Key<*>): CoroutineContext = minusPolymorphicKey(key)\n * }\n *\n * class DerivedElement : BaseElement() {\n *     companion object Key : AbstractCoroutineContextKey<BaseElement, DerivedElement>(BaseElement, { it as? DerivedElement })\n * }\n * // Now it is possible to query both `BaseElement` and `DerivedElement`\n * someContext[BaseElement] // Returns BaseElement?, non-null both for BaseElement and DerivedElement instances\n * someContext[DerivedElement] // Returns DerivedElement?, non-null only for DerivedElement instance\n * ```\n * @param B base class of a polymorphic element\n * @param baseKey an instance of base key\n * @param E element type associated with the current key\n * @param safeCast a function that can safely cast abstract [CoroutineContext.Element] to the concrete [E] type\n *                 and return the element if it is a subtype of [E] or `null` otherwise.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic abstract class AbstractCoroutineContextKey<B : Element, E : B>(\n    baseKey: Key<B>,\n    private val safeCast: (element: Element) -> E?\n) : Key<E> {\n    private val topmostKey: Key<*> = if (baseKey is AbstractCoroutineContextKey<*, *>) baseKey.topmostKey else baseKey\n\n    internal fun tryCast(element: Element): E? = safeCast(element)\n    internal fun isSubKey(key: Key<*>): Boolean = key === this || topmostKey === key\n}\n\n/**\n * Returns the current element is it is associated with the given [key] in a polymorphic manner or `null` otherwise.\n * This method returns non-null value if either [Element.key] is equal to the given [key] or if the [key] is associated\n * with [Element.key] via [AbstractCoroutineContextKey].\n * See [AbstractCoroutineContextKey] for the example of usage.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun <E : Element> Element.getPolymorphicElement(key: Key<E>): E? {\n    if (key is AbstractCoroutineContextKey<*, *>) {\n        @Suppress(\"UNCHECKED_CAST\")\n        return if (key.isSubKey(this.key)) key.tryCast(this) as? E else null\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return if (this.key === key) this as E else null\n}\n\n/**\n * Returns empty coroutine context if the element is associated with the given [key] in a polymorphic manner\n * or `null` otherwise.\n * This method returns empty context if either [Element.key] is equal to the given [key] or if the [key] is associated\n * with [Element.key] via [AbstractCoroutineContextKey].\n * See [AbstractCoroutineContextKey] for the example of usage.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun Element.minusPolymorphicKey(key: Key<*>): CoroutineContext {\n    if (key is AbstractCoroutineContextKey<*, *>) {\n        return if (key.isSubKey(this.key) && key.tryCast(this) != null) EmptyCoroutineContext else this\n    }\n    return if (this.key === key) EmptyCoroutineContext else this\n}\n\n/**\n * An empty coroutine context.\n */\n@SinceKotlin(\"1.3\")\npublic object EmptyCoroutineContext : CoroutineContext, Serializable {\n    private const val serialVersionUID: Long = 0\n    private fun readResolve(): Any = EmptyCoroutineContext\n\n    public override fun <E : Element> get(key: Key<E>): E? = null\n    public override fun <R> fold(initial: R, operation: (R, Element) -> R): R = initial\n    public override fun plus(context: CoroutineContext): CoroutineContext = context\n    public override fun minusKey(key: Key<*>): CoroutineContext = this\n    public override fun hashCode(): Int = 0\n    public override fun toString(): String = \"EmptyCoroutineContext\"\n}\n\n//--------------------- internal impl ---------------------\n\n// this class is not exposed, but is hidden inside implementations\n// this is a left-biased list, so that `plus` works naturally\n@SinceKotlin(\"1.3\")\ninternal class CombinedContext(\n    private val left: CoroutineContext,\n    private val element: Element\n) : CoroutineContext, Serializable {\n\n    override fun <E : Element> get(key: Key<E>): E? {\n        var cur = this\n        while (true) {\n            cur.element[key]?.let { return it }\n            val next = cur.left\n            if (next is CombinedContext) {\n                cur = next\n            } else {\n                return next[key]\n            }\n        }\n    }\n\n    public override fun <R> fold(initial: R, operation: (R, Element) -> R): R =\n        operation(left.fold(initial, operation), element)\n\n    public override fun minusKey(key: Key<*>): CoroutineContext {\n        element[key]?.let { return left }\n        val newLeft = left.minusKey(key)\n        return when {\n            newLeft === left -> this\n            newLeft === EmptyCoroutineContext -> element\n            else -> CombinedContext(newLeft, element)\n        }\n    }\n\n    private fun size(): Int {\n        var cur = this\n        var size = 2\n        while (true) {\n            cur = cur.left as? CombinedContext ?: return size\n            size++\n        }\n    }\n\n    private fun contains(element: Element): Boolean =\n        get(element.key) == element\n\n    private fun containsAll(context: CombinedContext): Boolean {\n        var cur = context\n        while (true) {\n            if (!contains(cur.element)) return false\n            val next = cur.left\n            if (next is CombinedContext) {\n                cur = next\n            } else {\n                return contains(next as Element)\n            }\n        }\n    }\n\n    override fun equals(other: Any?): Boolean =\n        this === other || other is CombinedContext && other.size() == size() && other.containsAll(this)\n\n    override fun hashCode(): Int = left.hashCode() + element.hashCode()\n\n    override fun toString(): String =\n        \"[\" + fold(\"\") { acc, element ->\n            if (acc.isEmpty()) element.toString() else \"$acc, $element\"\n        } + \"]\"\n\n    private fun writeReplace(): Any {\n        val n = size()\n        val elements = arrayOfNulls<CoroutineContext>(n)\n        var index = 0\n        fold(Unit) { _, element -> elements[index++] = element }\n        check(index == n)\n        @Suppress(\"UNCHECKED_CAST\")\n        return Serialized(elements as Array<CoroutineContext>)\n    }\n\n    private class Serialized(val elements: Array<CoroutineContext>) : Serializable {\n        companion object {\n            private const val serialVersionUID: Long = 0L\n        }\n\n        private fun readResolve(): Any = elements.fold(EmptyCoroutineContext, CoroutineContext::plus)\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"IntrinsicsKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin.coroutines.intrinsics\n\nimport kotlin.coroutines.*\nimport kotlin.internal.InlineOnly\n\n/**\n * Obtains the current continuation instance inside suspend functions and either suspends\n * currently running coroutine or returns result immediately without suspension.\n *\n * If the [block] returns the special [COROUTINE_SUSPENDED] value, it means that suspend function did suspend the execution and will\n * not return any result immediately. In this case, the [Continuation] provided to the [block] shall be\n * resumed by invoking [Continuation.resumeWith] at some moment in the\n * future when the result becomes available to resume the computation.\n *\n * Otherwise, the return value of the [block] must have a type assignable to [T] and represents the result of this suspend function.\n * It means that the execution was not suspended and the [Continuation] provided to the [block] shall not be invoked.\n * As the result type of the [block] is declared as `Any?` and cannot be correctly type-checked,\n * its proper return type remains on the conscience of the suspend function's author.\n *\n * Invocation of [Continuation.resumeWith] resumes coroutine directly in the invoker's thread without going through the\n * [ContinuationInterceptor] that might be present in the coroutine's [CoroutineContext].\n * It is the invoker's responsibility to ensure that a proper invocation context is established.\n * [Continuation.intercepted] can be used to acquire the intercepted continuation.\n *\n * Note that it is not recommended to call either [Continuation.resume] nor [Continuation.resumeWithException] functions synchronously\n * in the same stackframe where suspension function is run. Use [suspendCoroutine] as a safer way to obtain current\n * continuation instance.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\n@Suppress(\"UNUSED_PARAMETER\", \"RedundantSuspendModifier\")\npublic suspend inline fun <T> suspendCoroutineUninterceptedOrReturn(crossinline block: (Continuation<T>) -> Any?): T =\n    throw NotImplementedError(\"Implementation of suspendCoroutineUninterceptedOrReturn is intrinsic\")\n\n/**\n * This value is used as a return value of [suspendCoroutineUninterceptedOrReturn] `block` argument to state that\n * the execution was suspended and will not return any result immediately.\n *\n * **Note: this value should not be used in general code.** Using it outside of the context of\n * `suspendCoroutineUninterceptedOrReturn` function return value  (including, but not limited to,\n * storing this value in other properties, returning it from other functions, etc)\n * can lead to unspecified behavior of the code.\n */\n// It is implemented as property with getter to avoid ProGuard <clinit> problem with multifile IntrinsicsKt class\n@SinceKotlin(\"1.3\")\npublic val COROUTINE_SUSPENDED: Any get() = CoroutineSingletons.COROUTINE_SUSPENDED\n\n// Using enum here ensures two important properties:\n//  1. It makes SafeContinuation serializable with all kinds of serialization frameworks (since all of them natively support enums)\n//  2. It improves debugging experience, since you clearly see toString() value of those objects and what package they come from\n@SinceKotlin(\"1.3\")\n@PublishedApi // This class is Published API via serialized representation of SafeContinuation, don't rename/move\ninternal enum class CoroutineSingletons { COROUTINE_SUSPENDED, UNDECIDED, RESUMED }\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.random\n\nimport kotlin.math.nextDown\n\n/**\n * An abstract class that is implemented by random number generator algorithms.\n *\n * The companion object [Random.Default] is the default instance of [Random].\n *\n * To get a seeded instance of random generator use [Random] function.\n *\n * @sample samples.random.Randoms.defaultRandom\n */\n@SinceKotlin(\"1.3\")\npublic abstract class Random {\n\n    /**\n     * Gets the next random [bitCount] number of bits.\n     *\n     * Generates an `Int` whose lower [bitCount] bits are filled with random values and the remaining upper bits are zero.\n     *\n     * @param bitCount number of bits to generate, must be in range 0..32, otherwise the behavior is unspecified.\n     */\n    public abstract fun nextBits(bitCount: Int): Int\n\n    /**\n     * Gets the next random `Int` from the random number generator.\n     *\n     * Generates an `Int` random value uniformly distributed between `Int.MIN_VALUE` and `Int.MAX_VALUE` (inclusive).\n     */\n    public open fun nextInt(): Int = nextBits(32)\n\n    /**\n     * Gets the next random non-negative `Int` from the random number generator less than the specified [until] bound.\n     *\n     * Generates an `Int` random value uniformly distributed between `0` (inclusive) and the specified [until] bound (exclusive).\n     *\n     * @param until must be positive.\n     *\n     * @throws IllegalArgumentException if [until] is negative or zero.\n     */\n    public open fun nextInt(until: Int): Int = nextInt(0, until)\n\n    /**\n     * Gets the next random `Int` from the random number generator in the specified range.\n     *\n     * Generates an `Int` random value uniformly distributed between the specified [from] (inclusive) and [until] (exclusive) bounds.\n     *\n     * @throws IllegalArgumentException if [from] is greater than or equal to [until].\n     */\n    public open fun nextInt(from: Int, until: Int): Int {\n        checkRangeBounds(from, until)\n        val n = until - from\n        if (n > 0 || n == Int.MIN_VALUE) {\n            val rnd = if (n and -n == n) {\n                val bitCount = fastLog2(n)\n                nextBits(bitCount)\n            } else {\n                var v: Int\n                do {\n                    val bits = nextInt().ushr(1)\n                    v = bits % n\n                } while (bits - v + (n - 1) < 0)\n                v\n            }\n            return from + rnd\n        } else {\n            while (true) {\n                val rnd = nextInt()\n                if (rnd in from until until) return rnd\n            }\n        }\n    }\n\n    /**\n     * Gets the next random `Long` from the random number generator.\n     *\n     * Generates a `Long` random value uniformly distributed between `Long.MIN_VALUE` and `Long.MAX_VALUE` (inclusive).\n     */\n    public open fun nextLong(): Long = nextInt().toLong().shl(32) + nextInt()\n\n    /**\n     * Gets the next random non-negative `Long` from the random number generator less than the specified [until] bound.\n     *\n     * Generates a `Long` random value uniformly distributed between `0` (inclusive) and the specified [until] bound (exclusive).\n     *\n     * @param until must be positive.\n     *\n     * @throws IllegalArgumentException if [until] is negative or zero.\n     */\n    public open fun nextLong(until: Long): Long = nextLong(0, until)\n\n    /**\n     * Gets the next random `Long` from the random number generator in the specified range.\n     *\n     * Generates a `Long` random value uniformly distributed between the specified [from] (inclusive) and [until] (exclusive) bounds.\n     *\n     * @throws IllegalArgumentException if [from] is greater than or equal to [until].\n     */\n    public open fun nextLong(from: Long, until: Long): Long {\n        checkRangeBounds(from, until)\n        val n = until - from\n        if (n > 0) {\n            val rnd: Long\n            if (n and -n == n) {\n                val nLow = n.toInt()\n                val nHigh = (n ushr 32).toInt()\n                rnd = when {\n                    nLow != 0 -> {\n                        val bitCount = fastLog2(nLow)\n                        // toUInt().toLong()\n                        nextBits(bitCount).toLong() and 0xFFFF_FFFF\n                    }\n                    nHigh == 1 ->\n                        // toUInt().toLong()\n                        nextInt().toLong() and 0xFFFF_FFFF\n                    else -> {\n                        val bitCount = fastLog2(nHigh)\n                        nextBits(bitCount).toLong().shl(32) + nextInt()\n                    }\n                }\n            } else {\n                var v: Long\n                do {\n                    val bits = nextLong().ushr(1)\n                    v = bits % n\n                } while (bits - v + (n - 1) < 0)\n                rnd = v\n            }\n            return from + rnd\n        } else {\n            while (true) {\n                val rnd = nextLong()\n                if (rnd in from until until) return rnd\n            }\n        }\n    }\n\n    /**\n     * Gets the next random [Boolean] value.\n     */\n    public open fun nextBoolean(): Boolean = nextBits(1) != 0\n\n    /**\n     * Gets the next random [Double] value uniformly distributed between 0 (inclusive) and 1 (exclusive).\n     */\n    public open fun nextDouble(): Double = doubleFromParts(nextBits(26), nextBits(27))\n\n    /**\n     * Gets the next random non-negative `Double` from the random number generator less than the specified [until] bound.\n     *\n     * Generates a `Double` random value uniformly distributed between 0 (inclusive) and [until] (exclusive).\n     *\n     * @throws IllegalArgumentException if [until] is negative or zero.\n     */\n    public open fun nextDouble(until: Double): Double = nextDouble(0.0, until)\n\n    /**\n     * Gets the next random `Double` from the random number generator in the specified range.\n     *\n     * Generates a `Double` random value uniformly distributed between the specified [from] (inclusive) and [until] (exclusive) bounds.\n     *\n     * [from] and [until] must be finite otherwise the behavior is unspecified.\n     *\n     * @throws IllegalArgumentException if [from] is greater than or equal to [until].\n     */\n    public open fun nextDouble(from: Double, until: Double): Double {\n        checkRangeBounds(from, until)\n        val size = until - from\n        val r = if (size.isInfinite() && from.isFinite() && until.isFinite()) {\n            val r1 = nextDouble() * (until / 2 - from / 2)\n            from + r1 + r1\n        } else {\n            from + nextDouble() * size\n        }\n        return if (r >= until) until.nextDown() else r\n    }\n\n    /**\n     * Gets the next random [Float] value uniformly distributed between 0 (inclusive) and 1 (exclusive).\n     */\n    public open fun nextFloat(): Float = nextBits(24) / (1 shl 24).toFloat()\n\n    /**\n     * Fills a subrange of the specified byte [array] starting from [fromIndex] inclusive and ending [toIndex] exclusive\n     * with random bytes.\n     *\n     * @return [array] with the subrange filled with random bytes.\n     */\n    public open fun nextBytes(array: ByteArray, fromIndex: Int = 0, toIndex: Int = array.size): ByteArray {\n        require(fromIndex in 0..array.size && toIndex in 0..array.size) { \"fromIndex ($fromIndex) or toIndex ($toIndex) are out of range: 0..${array.size}.\" }\n        require(fromIndex <= toIndex) { \"fromIndex ($fromIndex) must be not greater than toIndex ($toIndex).\" }\n\n        val steps = (toIndex - fromIndex) / 4\n\n        var position = fromIndex\n        repeat(steps) {\n            val v = nextInt()\n            array[position] = v.toByte()\n            array[position + 1] = v.ushr(8).toByte()\n            array[position + 2] = v.ushr(16).toByte()\n            array[position + 3] = v.ushr(24).toByte()\n            position += 4\n        }\n\n        val remainder = toIndex - position\n        val vr = nextBits(remainder * 8)\n        for (i in 0 until remainder) {\n            array[position + i] = vr.ushr(i * 8).toByte()\n        }\n\n        return array\n    }\n\n    /**\n     * Fills the specified byte [array] with random bytes and returns it.\n     *\n     * @return [array] filled with random bytes.\n     */\n    public open fun nextBytes(array: ByteArray): ByteArray = nextBytes(array, 0, array.size)\n\n    /**\n     * Creates a byte array of the specified [size], filled with random bytes.\n     */\n    public open fun nextBytes(size: Int): ByteArray = nextBytes(ByteArray(size))\n\n\n    /**\n     * The default random number generator.\n     *\n     * On JVM this generator is thread-safe, its methods can be invoked from multiple threads.\n     *\n     * @sample samples.random.Randoms.defaultRandom\n     */\n    companion object Default : Random() {\n\n        private val defaultRandom: Random = defaultPlatformRandom()\n\n        override fun nextBits(bitCount: Int): Int = defaultRandom.nextBits(bitCount)\n        override fun nextInt(): Int = defaultRandom.nextInt()\n        override fun nextInt(until: Int): Int = defaultRandom.nextInt(until)\n        override fun nextInt(from: Int, until: Int): Int = defaultRandom.nextInt(from, until)\n\n        override fun nextLong(): Long = defaultRandom.nextLong()\n        override fun nextLong(until: Long): Long = defaultRandom.nextLong(until)\n        override fun nextLong(from: Long, until: Long): Long = defaultRandom.nextLong(from, until)\n\n        override fun nextBoolean(): Boolean = defaultRandom.nextBoolean()\n\n        override fun nextDouble(): Double = defaultRandom.nextDouble()\n        override fun nextDouble(until: Double): Double = defaultRandom.nextDouble(until)\n        override fun nextDouble(from: Double, until: Double): Double = defaultRandom.nextDouble(from, until)\n\n        override fun nextFloat(): Float = defaultRandom.nextFloat()\n\n        override fun nextBytes(array: ByteArray): ByteArray = defaultRandom.nextBytes(array)\n        override fun nextBytes(size: Int): ByteArray = defaultRandom.nextBytes(size)\n        override fun nextBytes(array: ByteArray, fromIndex: Int, toIndex: Int): ByteArray = defaultRandom.nextBytes(array, fromIndex, toIndex)\n\n        @Deprecated(\"Use Default companion object instead\", level = DeprecationLevel.HIDDEN)\n        @Suppress(\"DEPRECATION_ERROR\")\n        @kotlin.jvm.JvmField\n        public val Companion: Random.Companion = Random.Companion\n    }\n\n    @Deprecated(\"Use Default companion object instead\", level = DeprecationLevel.HIDDEN)\n    public object Companion : Random() {\n        override fun nextBits(bitCount: Int): Int = Default.nextBits(bitCount)\n    }\n}\n\n/**\n * Returns a repeatable random number generator seeded with the given [seed] `Int` value.\n *\n * Two generators with the same seed produce the same sequence of values within the same version of Kotlin runtime.\n *\n * *Note:* Future versions of Kotlin may change the algorithm of this seeded number generator so that it will return\n * a sequence of values different from the current one for a given seed.\n *\n * @sample samples.random.Randoms.seededRandom\n */\n@SinceKotlin(\"1.3\")\npublic fun Random(seed: Int): Random = XorWowRandom(seed, seed.shr(31))\n\n/**\n * Returns a repeatable random number generator seeded with the given [seed] `Long` value.\n *\n * Two generators with the same seed produce the same sequence of values within the same version of Kotlin runtime.\n *\n * *Note:* Future versions of Kotlin may change the algorithm of this seeded number generator so that it will return\n * a sequence of values different from the current one for a given seed.\n *\n * @sample samples.random.Randoms.seededRandom\n */\n@SinceKotlin(\"1.3\")\npublic fun Random(seed: Long): Random = XorWowRandom(seed.toInt(), seed.shr(32).toInt())\n\n\n\n/**\n * Gets the next random `Int` from the random number generator in the specified [range].\n *\n * Generates an `Int` random value uniformly distributed in the specified [range]:\n * from `range.start` inclusive to `range.endInclusive` inclusive.\n *\n * @throws IllegalArgumentException if [range] is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun Random.nextInt(range: IntRange): Int = when {\n    range.isEmpty() -> throw IllegalArgumentException(\"Cannot get random in empty range: $range\")\n    range.last < Int.MAX_VALUE -> nextInt(range.first, range.last + 1)\n    range.first > Int.MIN_VALUE -> nextInt(range.first - 1, range.last) + 1\n    else -> nextInt()\n}\n\n/**\n * Gets the next random `Long` from the random number generator in the specified [range].\n *\n * Generates a `Long` random value uniformly distributed in the specified [range]:\n * from `range.start` inclusive to `range.endInclusive` inclusive.\n *\n * @throws IllegalArgumentException if [range] is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun Random.nextLong(range: LongRange): Long = when {\n    range.isEmpty() -> throw IllegalArgumentException(\"Cannot get random in empty range: $range\")\n    range.last < Long.MAX_VALUE -> nextLong(range.first, range.last + 1)\n    range.first > Long.MIN_VALUE -> nextLong(range.first - 1, range.last) + 1\n    else -> nextLong()\n}\n\n\ninternal expect fun defaultPlatformRandom(): Random\ninternal expect fun doubleFromParts(hi26: Int, low27: Int): Double\n\n@UseExperimental(ExperimentalStdlibApi::class)\ninternal fun fastLog2(value: Int): Int = 31 - value.countLeadingZeroBits()\n\n/** Takes upper [bitCount] bits (0..32) from this number. */\ninternal fun Int.takeUpperBits(bitCount: Int): Int =\n    this.ushr(32 - bitCount) and (-bitCount).shr(31)\n\ninternal fun checkRangeBounds(from: Int, until: Int) = require(until > from) { boundsErrorMessage(from, until) }\ninternal fun checkRangeBounds(from: Long, until: Long) = require(until > from) { boundsErrorMessage(from, until) }\ninternal fun checkRangeBounds(from: Double, until: Double) = require(until > from) { boundsErrorMessage(from, until) }\n\ninternal fun boundsErrorMessage(from: Any, until: Any) = \"Random range is empty: [$from, $until).\"\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.random\n\n/**\n * Random number generator, using Marsaglia's \"xorwow\" algorithm\n *\n * Cycles after 2^192 - 2^32 repetitions.\n *\n * For more details, see Marsaglia, George (July 2003). \"Xorshift RNGs\". Journal of Statistical Software. 8 (14). doi:10.18637/jss.v008.i14\n *\n * Available at https://www.jstatsoft.org/v08/i14/paper\n *\n */\ninternal class XorWowRandom\ninternal constructor(\n    private var x: Int,\n    private var y: Int,\n    private var z: Int,\n    private var w: Int,\n    private var v: Int,\n    private var addend: Int\n) : Random() {\n\n    internal constructor(seed1: Int, seed2: Int) :\n            this(seed1, seed2, 0, 0, seed1.inv(), (seed1 shl 10) xor (seed2 ushr 4))\n\n    init {\n        require((x or y or z or w or v) != 0) { \"Initial state must have at least one non-zero element.\" }\n\n        // some trivial seeds can produce several values with zeroes in upper bits, so we discard first 64\n        repeat(64) { nextInt() }\n    }\n\n    override fun nextInt(): Int {\n        // Equivalent to the xorxow algorithm\n        // From Marsaglia, G. 2003. Xorshift RNGs. J. Statis. Soft. 8, 14, p. 5\n        var t = x\n        t = t xor (t ushr 2)\n        x = y\n        y = z\n        z = w\n        val v0 = v\n        w = v0\n        t = (t xor (t shl 1)) xor v0 xor (v0 shl 4)\n        v = t\n        addend += 362437\n        return t + addend\n    }\n\n    override fun nextBits(bitCount: Int): Int =\n        nextInt().takeUpperBits(bitCount)\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"RangesKt\")\n\npackage kotlin.ranges\n\n/**\n * Represents a range of [Comparable] values.\n */\nprivate open class ComparableRange<T : Comparable<T>>(\n    override val start: T,\n    override val endInclusive: T\n) : ClosedRange<T> {\n\n    override fun equals(other: Any?): Boolean {\n        return other is ComparableRange<*> && (isEmpty() && other.isEmpty() ||\n                start == other.start && endInclusive == other.endInclusive)\n    }\n\n    override fun hashCode(): Int {\n        return if (isEmpty()) -1 else 31 * start.hashCode() + endInclusive.hashCode()\n    }\n\n    override fun toString(): String = \"$start..$endInclusive\"\n}\n\n/**\n * Creates a range from this [Comparable] value to the specified [that] value.\n *\n * This value needs to be smaller than [that] value, otherwise the returned range will be empty.\n * @sample samples.ranges.Ranges.rangeFromComparable\n */\npublic operator fun <T : Comparable<T>> T.rangeTo(that: T): ClosedRange<T> = ComparableRange(this, that)\n\n\n/**\n * Represents a range of floating point numbers.\n * Extends [ClosedRange] interface providing custom operation [lessThanOrEquals] for comparing values of range domain type.\n *\n * This interface is implemented by floating point ranges returned by [Float.rangeTo] and [Double.rangeTo] operators to\n * achieve IEEE-754 comparison order instead of total order of floating point numbers.\n */\n@SinceKotlin(\"1.1\")\npublic interface ClosedFloatingPointRange<T : Comparable<T>> : ClosedRange<T> {\n    override fun contains(value: T): Boolean = lessThanOrEquals(start, value) && lessThanOrEquals(value, endInclusive)\n    override fun isEmpty(): Boolean = !lessThanOrEquals(start, endInclusive)\n\n    /**\n     * Compares two values of range domain type and returns true if first is less than or equal to second.\n     */\n    fun lessThanOrEquals(a: T, b: T): Boolean\n}\n\n\n/**\n * A closed range of values of type `Double`.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n */\nprivate class ClosedDoubleRange(\n    start: Double,\n    endInclusive: Double\n) : ClosedFloatingPointRange<Double> {\n    private val _start = start\n    private val _endInclusive = endInclusive\n    override val start: Double get() = _start\n    override val endInclusive: Double get() = _endInclusive\n\n    override fun lessThanOrEquals(a: Double, b: Double): Boolean = a <= b\n\n    override fun contains(value: Double): Boolean = value >= _start && value <= _endInclusive\n    override fun isEmpty(): Boolean = !(_start <= _endInclusive)\n\n    override fun equals(other: Any?): Boolean {\n        return other is ClosedDoubleRange && (isEmpty() && other.isEmpty() ||\n                _start == other._start && _endInclusive == other._endInclusive)\n    }\n\n    override fun hashCode(): Int {\n        return if (isEmpty()) -1 else 31 * _start.hashCode() + _endInclusive.hashCode()\n    }\n\n    override fun toString(): String = \"$_start..$_endInclusive\"\n}\n\n/**\n * Creates a range from this [Double] value to the specified [that] value.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n * @sample samples.ranges.Ranges.rangeFromDouble\n */\n@SinceKotlin(\"1.1\")\npublic operator fun Double.rangeTo(that: Double): ClosedFloatingPointRange<Double> = ClosedDoubleRange(this, that)\n\n\n/**\n * A closed range of values of type `Float`.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n */\nprivate class ClosedFloatRange(\n    start: Float,\n    endInclusive: Float\n) : ClosedFloatingPointRange<Float> {\n    private val _start = start\n    private val _endInclusive = endInclusive\n    override val start: Float get() = _start\n    override val endInclusive: Float get() = _endInclusive\n\n    override fun lessThanOrEquals(a: Float, b: Float): Boolean = a <= b\n\n    override fun contains(value: Float): Boolean = value >= _start && value <= _endInclusive\n    override fun isEmpty(): Boolean = !(_start <= _endInclusive)\n\n    override fun equals(other: Any?): Boolean {\n        return other is ClosedFloatRange && (isEmpty() && other.isEmpty() ||\n                _start == other._start && _endInclusive == other._endInclusive)\n    }\n\n    override fun hashCode(): Int {\n        return if (isEmpty()) -1 else 31 * _start.hashCode() + _endInclusive.hashCode()\n    }\n\n    override fun toString(): String = \"$_start..$_endInclusive\"\n}\n\n/**\n * Creates a range from this [Float] value to the specified [that] value.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n * @sample samples.ranges.Ranges.rangeFromFloat\n */\n@SinceKotlin(\"1.1\")\npublic operator fun Float.rangeTo(that: Float): ClosedFloatingPointRange<Float> = ClosedFloatRange(this, that)\n\n\n/**\n * Returns `true` if this iterable range contains the specified [element].\n *\n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <T, R> R.contains(element: T?): Boolean where T : Any, R : Iterable<T>, R : ClosedRange<T> =\n    element != null && contains(element)\n\n\ninternal fun checkStepIsPositive(isPositive: Boolean, step: Number) {\n    if (!isPositive) throw IllegalArgumentException(\"Step must be positive, was: $step.\")\n}\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n/**\n * An object to which char sequences and values can be appended.\n */\nexpect interface Appendable {\n    /**\n     * Appends the specified character [value] to this Appendable and returns this instance.\n     *\n     * @param value the character to append.\n     */\n    fun append(value: Char): Appendable\n\n    /**\n     * Appends the specified character sequence [value] to this Appendable and returns this instance.\n     *\n     * @param value the character sequence to append. If [value] is `null`, then the four characters `\"null\"` are appended to this Appendable.\n     */\n    fun append(value: CharSequence?): Appendable\n\n    /**\n     * Appends a subsequence of the specified character sequence [value] to this Appendable and returns this instance.\n     *\n     * @param value the character sequence from which a subsequence is appended. If [value] is `null`,\n     *  then characters are appended as if [value] contained the four characters `\"null\"`.\n     * @param startIndex the beginning (inclusive) of the subsequence to append.\n     * @param endIndex the end (exclusive) of the subsequence to append.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n     */\n    fun append(value: CharSequence?, startIndex: Int, endIndex: Int): Appendable\n}\n\n/**\n * Appends a subsequence of the specified character sequence [value] to this Appendable and returns this instance.\n *\n * @param value the character sequence from which a subsequence is appended. If [value] is `null`,\n *  then characters are appended as if [value] contained the four characters `\"null\"`.\n * @param startIndex the beginning (inclusive) of the subsequence to append.\n * @param endIndex the end (exclusive) of the subsequence to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun <T : Appendable> T.appendRange(value: CharSequence?, startIndex: Int, endIndex: Int): T {\n    @Suppress(\"UNCHECKED_CAST\")\n    return append(value, startIndex, endIndex) as T\n}\n\n/**\n * Appends all arguments to the given [Appendable].\n */\npublic fun <T : Appendable> T.append(vararg value: CharSequence?): T {\n    for (item in value)\n        append(item)\n    return this\n}\n\n\ninternal fun <T> Appendable.appendElement(element: T, transform: ((T) -> CharSequence)?) {\n    when {\n        transform != null -> append(transform(element))\n        element is CharSequence? -> append(element)\n        element is Char -> append(element)\n        else -> append(element.toString())\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"TuplesKt\")\n\npackage kotlin\n\n\n/**\n * Represents a generic pair of two values.\n *\n * There is no meaning attached to values in this class, it can be used for any purpose.\n * Pair exhibits value semantics, i.e. two pairs are equal if both components are equal.\n *\n * An example of decomposing it into values:\n * @sample samples.misc.Tuples.pairDestructuring\n *\n * @param A type of the first value.\n * @param B type of the second value.\n * @property first First value.\n * @property second Second value.\n * @constructor Creates a new instance of Pair.\n */\npublic data class Pair<out A, out B>(\n    public val first: A,\n    public val second: B\n) : Serializable {\n\n    /**\n     * Returns string representation of the [Pair] including its [first] and [second] values.\n     */\n    public override fun toString(): String = \"($first, $second)\"\n}\n\n/**\n * Creates a tuple of type [Pair] from this and [that].\n *\n * This can be useful for creating [Map] literals with less noise, for example:\n * @sample samples.collections.Maps.Instantiation.mapFromPairs\n */\npublic infix fun <A, B> A.to(that: B): Pair<A, B> = Pair(this, that)\n\n/**\n * Converts this pair into a list.\n * @sample samples.misc.Tuples.pairToList\n */\npublic fun <T> Pair<T, T>.toList(): List<T> = listOf(first, second)\n\n/**\n * Represents a triad of values\n *\n * There is no meaning attached to values in this class, it can be used for any purpose.\n * Triple exhibits value semantics, i.e. two triples are equal if all three components are equal.\n * An example of decomposing it into values:\n * @sample samples.misc.Tuples.tripleDestructuring\n *\n * @param A type of the first value.\n * @param B type of the second value.\n * @param C type of the third value.\n * @property first First value.\n * @property second Second value.\n * @property third Third value.\n */\npublic data class Triple<out A, out B, out C>(\n    public val first: A,\n    public val second: B,\n    public val third: C\n) : Serializable {\n\n    /**\n     * Returns string representation of the [Triple] including its [first], [second] and [third] values.\n     */\n    public override fun toString(): String = \"($first, $second, $third)\"\n}\n\n/**\n * Converts this triple into a list.\n * @sample samples.misc.Tuples.tripleToList\n */\npublic fun <T> Triple<T, T, T>.toList(): List<T> = listOf(first, second, third)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MathKt\")\n\n\npackage kotlin.math\n\n\n\n// constants, can't use them from nativeMath as they are not constants there\n\n/** Ratio of the circumference of a circle to its diameter, approximately 3.14159. */\n@SinceKotlin(\"1.2\")\npublic const val PI: Double = 3.141592653589793\n/** Base of the natural logarithms, approximately 2.71828. */\n@SinceKotlin(\"1.2\")\npublic const val E: Double = 2.718281828459045\n\n// region ================ Double Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun sin(x: Double): Double\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun cos(x: Double): Double\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun tan(x: Double): Double\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun asin(x: Double): Double\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun acos(x: Double): Double\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun atan(x: Double): Double\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun atan2(y: Double, x: Double): Double\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun sinh(x: Double): Double\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun cosh(x: Double): Double\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun tanh(x: Double): Double\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun asinh(x: Double): Double\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun acosh(x: Double): Double\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun atanh(x: Double): Double\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\npublic expect fun hypot(x: Double, y: Double): Double\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun sqrt(x: Double): Double\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun exp(x: Double): Double\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun expm1(x: Double): Double\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic expect fun log(x: Double, base: Double): Double\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun ln(x: Double): Double\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun log10(x: Double): Double\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun log2(x: Double): Double\n\n/**\n * Computes `ln(x + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\npublic expect fun ln1p(x: Double): Double\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest double value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun ceil(x: Double): Double\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest double value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun floor(x: Double): Double\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun truncate(x: Double): Double\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun round(x: Double): Double\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Double]\n */\n@SinceKotlin(\"1.2\")\npublic expect fun abs(x: Double): Double\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun sign(x: Double): Double\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun min(a: Double, b: Double): Double\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun max(a: Double, b: Double): Double\n\n// extensions\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.pow(x: Double): Double\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.pow(n: Int): Double\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\npublic expect val Double.absoluteValue: Double\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect val Double.sign: Double\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.withSign(sign: Double): Double\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.withSign(sign: Int): Double\n\n/**\n * Returns the ulp (unit in the last place) of this value.\n *\n * An ulp is a positive distance between this value and the next nearest [Double] value larger in magnitude.\n *\n * Special Cases:\n *   - `NaN.ulp` is `NaN`\n *   - `x.ulp` is `+Inf` when `x` is `+Inf` or `-Inf`\n *   - `0.0.ulp` is `Double.MIN_VALUE`\n */\n@SinceKotlin(\"1.2\")\npublic expect val Double.ulp: Double\n\n/**\n * Returns the [Double] value nearest to this value in direction of positive infinity.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.nextUp(): Double\n\n/**\n * Returns the [Double] value nearest to this value in direction of negative infinity.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.nextDown(): Double\n\n/**\n * Returns the [Double] value nearest to this value in direction from this value towards the value [to].\n *\n * Special cases:\n *   - `x.nextTowards(y)` is `NaN` if either `x` or `y` are `NaN`\n *   - `x.nextTowards(x) == x`\n *\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.nextTowards(to: Double): Double\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.roundToInt(): Int\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.roundToLong(): Long\n\n// endregion\n\n\n\n// region ================ Float Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun sin(x: Float): Float\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun cos(x: Float): Float\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun tan(x: Float): Float\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun asin(x: Float): Float\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun acos(x: Float): Float\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun atan(x: Float): Float\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun atan2(y: Float, x: Float): Float\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun sinh(x: Float): Float\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun cosh(x: Float): Float\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun tanh(x: Float): Float\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun asinh(x: Float): Float\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun acosh(x: Float): Float\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun atanh(x: Float): Float\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\npublic expect fun hypot(x: Float, y: Float): Float\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun sqrt(x: Float): Float\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun exp(x: Float): Float\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun expm1(x: Float): Float\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic expect fun log(x: Float, base: Float): Float\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun ln(x: Float): Float\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun log10(x: Float): Float\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun log2(x: Float): Float\n\n/**\n * Computes `ln(a + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\npublic expect fun ln1p(x: Float): Float\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest Float value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun ceil(x: Float): Float\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest Float value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun floor(x: Float): Float\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun truncate(x: Float): Float\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun round(x: Float): Float\n\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Float]\n */\n@SinceKotlin(\"1.2\")\npublic expect fun abs(x: Float): Float\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun sign(x: Float): Float\n\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun min(a: Float, b: Float): Float\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun max(a: Float, b: Float): Float\n\n// extensions\n\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Float.pow(x: Float): Float\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Float.pow(n: Int): Float\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\npublic expect val Float.absoluteValue: Float\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect val Float.sign: Float\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Float.withSign(sign: Float): Float\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Float.withSign(sign: Int): Float\n\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Float.roundToInt(): Int\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Float.roundToLong(): Long\n\n\n// endregion\n\n// region ================ Integer Math ========================================\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Int]\n */\n@SinceKotlin(\"1.2\")\npublic expect fun abs(n: Int): Int\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun min(a: Int, b: Int): Int\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun max(a: Int, b: Int): Int\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Int.MIN_VALUE.absoluteValue` is `Int.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\npublic expect val Int.absoluteValue: Int\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic expect val Int.sign: Int\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Long]\n */\n@SinceKotlin(\"1.2\")\npublic expect fun abs(n: Long): Long\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun min(a: Long, b: Long): Long\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun max(a: Long, b: Long): Long\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Long.MIN_VALUE.absoluteValue` is `Long.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\npublic expect val Long.absoluteValue: Long\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic expect val Long.sign: Int\n\n\n// endregion\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines.js.internal\n\nimport kotlin.coroutines.Continuation\nimport kotlin.coroutines.EmptyCoroutineContext\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal val EmptyContinuation = Continuation<Any?>(EmptyCoroutineContext) { result ->\n    result.getOrThrow()\n}","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n/** Returns the negative [size] if [throwOnMalformed] is false, throws [CharacterCodingException] otherwise. */\n@UseExperimental(ExperimentalStdlibApi::class)\nprivate fun malformed(size: Int, index: Int, throwOnMalformed: Boolean): Int {\n    if (throwOnMalformed) throw CharacterCodingException(\"Malformed sequence starting at ${index - 1}\")\n    return -size\n}\n\n/**\n * Returns code point corresponding to UTF-16 surrogate pair,\n * where the first of the pair is the [high] and the second is in the [string] at the [index].\n * Returns zero if the pair is malformed and [throwOnMalformed] is false.\n *\n * @throws CharacterCodingException if the pair is malformed and [throwOnMalformed] is true.\n */\nprivate fun codePointFromSurrogate(string: String, high: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int {\n    if (high !in 0xD800..0xDBFF || index >= endIndex) {\n        return malformed(0, index, throwOnMalformed)\n    }\n    val low = string[index].toInt()\n    if (low !in 0xDC00..0xDFFF) {\n        return malformed(0, index, throwOnMalformed)\n    }\n    return 0x10000 + ((high and 0x3FF) shl 10) or (low and 0x3FF)\n}\n\n/**\n * Returns code point corresponding to UTF-8 sequence of two bytes,\n * where the first byte of the sequence is the [byte1] and the second byte is in the [bytes] array at the [index].\n * Returns zero if the sequence is malformed and [throwOnMalformed] is false.\n *\n * @throws CharacterCodingException if the sequence of two bytes is malformed and [throwOnMalformed] is true.\n */\nprivate fun codePointFrom2(bytes: ByteArray, byte1: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int {\n    if (byte1 and 0x1E == 0 || index >= endIndex) {\n        return malformed(0, index, throwOnMalformed)\n    }\n    val byte2 = bytes[index].toInt()\n    if (byte2 and 0xC0 != 0x80) {\n        return malformed(0, index, throwOnMalformed)\n    }\n    return (byte1 shl 6) xor byte2 xor 0xF80\n}\n\n/**\n * Returns code point corresponding to UTF-8 sequence of three bytes,\n * where the first byte of the sequence is the [byte1] and the others are in the [bytes] array starting from the [index].\n * Returns a non-positive value indicating number of bytes from [bytes] included in malformed sequence\n * if the sequence is malformed and [throwOnMalformed] is false.\n *\n * @throws CharacterCodingException if the sequence of three bytes is malformed and [throwOnMalformed] is true.\n */\nprivate fun codePointFrom3(bytes: ByteArray, byte1: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int {\n    if (index >= endIndex) {\n        return malformed(0, index, throwOnMalformed)\n    }\n\n    val byte2 = bytes[index].toInt()\n    if (byte1 and 0xF == 0) {\n        if (byte2 and 0xE0 != 0xA0) {\n            // Non-shortest form\n            return malformed(0, index, throwOnMalformed)\n        }\n    } else if (byte1 and 0xF == 0xD) {\n        if (byte2 and 0xE0 != 0x80) {\n            // Surrogate code point\n            return malformed(0, index, throwOnMalformed)\n        }\n    } else if (byte2 and 0xC0 != 0x80) {\n        return malformed(0, index, throwOnMalformed)\n    }\n\n    if (index + 1 == endIndex) {\n        return malformed(1, index, throwOnMalformed)\n    }\n    val byte3 = bytes[index + 1].toInt()\n    if (byte3 and 0xC0 != 0x80) {\n        return malformed(1, index, throwOnMalformed)\n    }\n\n    return (byte1 shl 12) xor (byte2 shl 6) xor byte3 xor -0x1E080\n}\n\n/**\n * Returns code point corresponding to UTF-8 sequence of four bytes,\n * where the first byte of the sequence is the [byte1] and the others are in the [bytes] array starting from the [index].\n * Returns a non-positive value indicating number of bytes from [bytes] included in malformed sequence\n * if the sequence is malformed and [throwOnMalformed] is false.\n *\n * @throws CharacterCodingException if the sequence of four bytes is malformed and [throwOnMalformed] is true.\n */\nprivate fun codePointFrom4(bytes: ByteArray, byte1: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int {\n    if (index >= endIndex) {\n        malformed(0, index, throwOnMalformed)\n    }\n\n    val byte2 = bytes[index].toInt()\n    if (byte1 and 0xF == 0x0) {\n        if (byte2 and 0xF0 <= 0x80) {\n            // Non-shortest form\n            return malformed(0, index, throwOnMalformed)\n        }\n    } else if (byte1 and 0xF == 0x4) {\n        if (byte2 and 0xF0 != 0x80) {\n            // Out of Unicode code points domain (larger than U+10FFFF)\n            return malformed(0, index, throwOnMalformed)\n        }\n    } else if (byte1 and 0xF > 0x4) {\n        return malformed(0, index, throwOnMalformed)\n    } else if (byte2 and 0xC0 != 0x80) {\n        return malformed(0, index, throwOnMalformed)\n    }\n\n    if (index + 1 == endIndex) {\n        return malformed(1, index, throwOnMalformed)\n    }\n    val byte3 = bytes[index + 1].toInt()\n    if (byte3 and 0xC0 != 0x80) {\n        return malformed(1, index, throwOnMalformed)\n    }\n\n    if (index + 2 == endIndex) {\n        return malformed(2, index, throwOnMalformed)\n    }\n    val byte4 = bytes[index + 2].toInt()\n    if (byte4 and 0xC0 != 0x80) {\n        return malformed(2, index, throwOnMalformed)\n    }\n    return (byte1 shl 18) xor (byte2 shl 12) xor (byte3 shl 6) xor byte4 xor 0x381F80\n}\n\n/**\n * Maximum number of bytes needed to encode a single char.\n *\n * Code points in `0..0x7F` are encoded in a single byte.\n * Code points in `0x80..0x7FF` are encoded in two bytes.\n * Code points in `0x800..0xD7FF` or in `0xE000..0xFFFF` are encoded in three bytes.\n * Surrogate code points in `0xD800..0xDFFF` are not Unicode scalar values, therefore aren't encoded.\n * Code points in `0x10000..0x10FFFF` are represented by a pair of surrogate `Char`s and are encoded in four bytes.\n */\nprivate const val MAX_BYTES_PER_CHAR = 3\n\n/**\n * The byte sequence a malformed UTF-16 char sequence is replaced by.\n */\nprivate val REPLACEMENT_BYTE_SEQUENCE: ByteArray = byteArrayOf(0xEF.toByte(), 0xBF.toByte(), 0xBD.toByte())\n\n/**\n * Encodes the [string] using UTF-8 and returns the resulting [ByteArray].\n *\n * @param string the string to encode.\n * @param startIndex the start offset (inclusive) of the substring to encode.\n * @param endIndex the end offset (exclusive) of the substring to encode.\n * @param throwOnMalformed whether to throw on malformed char sequence or replace by the [REPLACEMENT_BYTE_SEQUENCE].\n *\n * @throws CharacterCodingException if the char sequence is malformed and [throwOnMalformed] is true.\n */\ninternal fun encodeUtf8(string: String, startIndex: Int, endIndex: Int, throwOnMalformed: Boolean): ByteArray {\n    require(startIndex >= 0 && endIndex <= string.length && startIndex <= endIndex)\n\n    val bytes = ByteArray((endIndex - startIndex) * MAX_BYTES_PER_CHAR)\n    var byteIndex = 0\n    var charIndex = startIndex\n\n    while (charIndex < endIndex) {\n        val code = string[charIndex++].toInt()\n        when {\n            code < 0x80 ->\n                bytes[byteIndex++] = code.toByte()\n            code < 0x800 -> {\n                bytes[byteIndex++] = ((code shr 6) or 0xC0).toByte()\n                bytes[byteIndex++] = ((code and 0x3F) or 0x80).toByte()\n            }\n            code < 0xD800 || code >= 0xE000 -> {\n                bytes[byteIndex++] = ((code shr 12) or 0xE0).toByte()\n                bytes[byteIndex++] = (((code shr 6) and 0x3F) or 0x80).toByte()\n                bytes[byteIndex++] = ((code and 0x3F) or 0x80).toByte()\n            }\n            else -> { // Surrogate char value\n                val codePoint = codePointFromSurrogate(string, code, charIndex, endIndex, throwOnMalformed)\n                if (codePoint <= 0) {\n                    bytes[byteIndex++] = REPLACEMENT_BYTE_SEQUENCE[0]\n                    bytes[byteIndex++] = REPLACEMENT_BYTE_SEQUENCE[1]\n                    bytes[byteIndex++] = REPLACEMENT_BYTE_SEQUENCE[2]\n                } else {\n                    bytes[byteIndex++] = ((codePoint shr 18) or 0xF0).toByte()\n                    bytes[byteIndex++] = (((codePoint shr 12) and 0x3F) or 0x80).toByte()\n                    bytes[byteIndex++] = (((codePoint shr 6) and 0x3F) or 0x80).toByte()\n                    bytes[byteIndex++] = ((codePoint and 0x3F) or 0x80).toByte()\n                    charIndex++\n                }\n            }\n        }\n    }\n\n    return if (bytes.size == byteIndex) bytes else bytes.copyOf(byteIndex)\n}\n\n/**\n * The character a malformed UTF-8 byte sequence is replaced by.\n */\nprivate const val REPLACEMENT_CHAR = '\\uFFFD'\n\n/**\n * Decodes the UTF-8 [bytes] array and returns the resulting [String].\n *\n * @param bytes the byte array to decode.\n * @param startIndex the start offset (inclusive) of the array to be decoded.\n * @param endIndex the end offset (exclusive) of the array to be encoded.\n * @param throwOnMalformed whether to throw on malformed byte sequence or replace by the [REPLACEMENT_CHAR].\n *\n * @throws CharacterCodingException if the array is malformed UTF-8 byte sequence and [throwOnMalformed] is true.\n */\ninternal fun decodeUtf8(bytes: ByteArray, startIndex: Int, endIndex: Int, throwOnMalformed: Boolean): String {\n    require(startIndex >= 0 && endIndex <= bytes.size && startIndex <= endIndex)\n\n    var byteIndex = startIndex\n    val stringBuilder = StringBuilder()\n\n    while (byteIndex < endIndex) {\n        val byte = bytes[byteIndex++].toInt()\n        when {\n            byte >= 0 ->\n                stringBuilder.append(byte.toChar())\n            byte shr 5 == -2 -> {\n                val code = codePointFrom2(bytes, byte, byteIndex, endIndex, throwOnMalformed)\n                if (code <= 0) {\n                    stringBuilder.append(REPLACEMENT_CHAR)\n                    byteIndex += -code\n                } else {\n                    stringBuilder.append(code.toChar())\n                    byteIndex += 1\n                }\n            }\n            byte shr 4 == -2 -> {\n                val code = codePointFrom3(bytes, byte, byteIndex, endIndex, throwOnMalformed)\n                if (code <= 0) {\n                    stringBuilder.append(REPLACEMENT_CHAR)\n                    byteIndex += -code\n                } else {\n                    stringBuilder.append(code.toChar())\n                    byteIndex += 2\n                }\n            }\n            byte shr 3 == -2 -> {\n                val code = codePointFrom4(bytes, byte, byteIndex, endIndex, throwOnMalformed)\n                if (code <= 0) {\n                    stringBuilder.append(REPLACEMENT_CHAR)\n                    byteIndex += -code\n                } else {\n                    val high = (code - 0x10000) shr 10 or 0xD800\n                    val low = (code and 0x3FF) or 0xDC00\n                    stringBuilder.append(high.toChar())\n                    stringBuilder.append(low.toChar())\n                    byteIndex += 3\n                }\n            }\n            else -> {\n                malformed(0, byteIndex, throwOnMalformed)\n                stringBuilder.append(REPLACEMENT_CHAR)\n            }\n        }\n    }\n\n    return stringBuilder.toString()\n}",null,null,null,null,"// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n",null,null,"/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n/**\n * A mutable sequence of characters.\n *\n * String builder can be used to efficiently perform multiple string manipulation operations.\n */\nexpect class StringBuilder : Appendable, CharSequence {\n    /** Constructs an empty string builder. */\n    constructor()\n\n    /** Constructs an empty string builder with the specified initial [capacity]. */\n    constructor(capacity: Int)\n\n    /** Constructs a string builder that contains the same characters as the specified [content] char sequence. */\n    constructor(content: CharSequence)\n\n    /** Constructs a string builder that contains the same characters as the specified [content] string. */\n    @SinceKotlin(\"1.3\")\n//    @ExperimentalStdlibApi\n    constructor(content: String)\n\n    override val length: Int\n\n    override operator fun get(index: Int): Char\n\n    override fun subSequence(startIndex: Int, endIndex: Int): CharSequence\n\n    override fun append(value: Char): StringBuilder\n    override fun append(value: CharSequence?): StringBuilder\n    override fun append(value: CharSequence?, startIndex: Int, endIndex: Int): StringBuilder\n\n    /**\n     * Reverses the contents of this string builder and returns this instance.\n     *\n     * Surrogate pairs included in this string builder are treated as single characters.\n     * Therefore, the order of the high-low surrogates is never reversed.\n     *\n     * Note that the reverse operation may produce new surrogate pairs that were unpaired low-surrogates and high-surrogates before the operation.\n     * For example, reversing `\"\\uDC00\\uD800\"` produces `\"\\uD800\\uDC00\"` which is a valid surrogate pair.\n     */\n    fun reverse(): StringBuilder\n\n    /**\n     * Appends the string representation of the specified object [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    fun append(value: Any?): StringBuilder\n\n    /**\n     * Appends the string representation of the specified boolean [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n//    @ExperimentalStdlibApi\n    fun append(value: Boolean): StringBuilder\n\n    /**\n     * Appends characters in the specified character array [value] to this string builder and returns this instance.\n     *\n     * Characters are appended in order, starting at the index 0.\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    fun append(value: CharArray): StringBuilder\n\n    /**\n     * Appends the specified string [value] to this string builder and returns this instance.\n     */\n    @SinceKotlin(\"1.3\")\n//    @ExperimentalStdlibApi\n    fun append(value: String): StringBuilder\n\n    /**\n     * Returns the current capacity of this string builder.\n     *\n     * The capacity is the maximum length this string builder can have before an allocation occurs.\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    fun capacity(): Int\n\n    /**\n     * Ensures that the capacity of this string builder is at least equal to the specified [minimumCapacity].\n     *\n     * If the current capacity is less than the [minimumCapacity], a new backing storage is allocated with greater capacity.\n     * Otherwise, this method takes no action and simply returns.\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    fun ensureCapacity(minimumCapacity: Int)\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    fun indexOf(string: String): Int\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string],\n     * starting at the specified [startIndex].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    fun indexOf(string: String, startIndex: Int): Int\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string].\n     * The last occurrence of empty string `\"\"` is considered to be at the index equal to `this.length`.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    fun lastIndexOf(string: String): Int\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string],\n     * starting from the specified [startIndex] toward the beginning.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    fun lastIndexOf(string: String, startIndex: Int): Int\n\n    /**\n     * Inserts the string representation of the specified boolean [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    fun insert(index: Int, value: Boolean): StringBuilder\n\n    /**\n     * Inserts the specified character [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    fun insert(index: Int, value: Char): StringBuilder\n\n    /**\n     * Inserts characters in the specified character array [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in same order as in the [value] character array, starting at [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    fun insert(index: Int, value: CharArray): StringBuilder\n\n    /**\n     * Inserts characters in the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n     *\n     * @param index the position in this string builder to insert at.\n     * @param value the character sequence from which characters are inserted. If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    fun insert(index: Int, value: CharSequence?): StringBuilder\n\n    /**\n     * Inserts the string representation of the specified object [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    fun insert(index: Int, value: Any?): StringBuilder\n\n    /**\n     * Inserts the string [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    fun insert(index: Int, value: String): StringBuilder\n\n    /**\n     *  Sets the length of this string builder to the specified [newLength].\n     *\n     *  If the [newLength] is less than the current length, it is changed to the specified [newLength].\n     *  Otherwise, null characters '\\u0000' are appended to this string builder until its length is less than the [newLength].\n     *\n     *  Note that in Kotlin/JS [set] operator function has non-constant execution time complexity.\n     *  Therefore, increasing length of this string builder and then updating each character by index may slow down your program.\n     *\n     *  @throws IndexOutOfBoundsException or [IllegalArgumentException] if [newLength] is less than zero.\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    fun setLength(newLength: Int)\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [length] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException if [startIndex] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    fun substring(startIndex: Int): String\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [endIndex] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    fun substring(startIndex: Int, endIndex: Int): String\n\n    /**\n     * Attempts to reduce storage used for this string builder.\n     *\n     * If the backing storage of this string builder is larger than necessary to hold its current contents,\n     * then it may be resized to become more space efficient.\n     * Calling this method may, but is not required to, affect the value of the [capacity] property.\n     */\n    @SinceKotlin(\"1.3\")\n    @ExperimentalStdlibApi\n    fun trimToSize()\n}\n\n\n/**\n * Clears the content of this string builder making it empty and returns this instance.\n *\n * @sample samples.text.Strings.clearStringBuilder\n */\n@SinceKotlin(\"1.3\")\npublic expect fun StringBuilder.clear(): StringBuilder\n\n/**\n * Sets the character at the specified [index] to the specified [value].\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic expect operator fun StringBuilder.set(index: Int, value: Char)\n\n/**\n * Replaces characters in the specified range of this string builder with characters in the specified string [value] and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to replace.\n * @param endIndex the end (exclusive) of the range to replace.\n * @param value the string to replace with.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] if [startIndex] is less than zero, greater than the length of this string builder, or `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic expect fun StringBuilder.setRange(startIndex: Int, endIndex: Int, value: String): StringBuilder\n\n/**\n * Removes the character at the specified [index] from this string builder and returns this instance.\n *\n * If the `Char` at the specified [index] is part of a supplementary code point, this method does not remove the entire supplementary character.\n *\n * @param index the index of `Char` to remove.\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic expect fun StringBuilder.deleteAt(index: Int): StringBuilder\n\n/**\n * Removes characters in the specified range from this string builder and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to remove.\n * @param endIndex the end (exclusive) of the range to remove.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic expect fun StringBuilder.deleteRange(startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Copies characters from this string builder into the [destination] character array.\n *\n * @param destination the array to copy to.\n * @param destinationOffset the position in the array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the range to copy, 0 by default.\n * @param endIndex the end (exclusive) of the range to copy, length of this string builder by default.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n *  or when that index is out of the [destination] array indices range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic expect fun StringBuilder.toCharArray(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = this.length)\n\n/**\n * Appends characters in a subarray of the specified character array [value] to this string builder and returns this instance.\n *\n * Characters are appended in order, starting at specified [startIndex].\n *\n * @param value the array from which characters are appended.\n * @param startIndex the beginning (inclusive) of the subarray to append.\n * @param endIndex the end (exclusive) of the subarray to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic expect fun StringBuilder.appendRange(value: CharArray, startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Appends a subsequence of the specified character sequence [value] to this string builder and returns this instance.\n *\n * @param value the character sequence from which a subsequence is appended. If [value] is `null`,\n *  then characters are appended as if [value] contained the four characters `\"null\"`.\n * @param startIndex the beginning (inclusive) of the subsequence to append.\n * @param endIndex the end (exclusive) of the subsequence to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic expect fun StringBuilder.appendRange(value: CharSequence?, startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Inserts characters in a subarray of the specified character array [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in same order as in the [value] array, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the array from which characters are inserted.\n * @param startIndex the beginning (inclusive) of the subarray to insert.\n * @param endIndex the end (exclusive) of the subarray to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic expect fun StringBuilder.insertRange(index: Int, value: CharArray, startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Inserts characters in a subsequence of the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the character sequence from which a subsequence is inserted. If [value] is `null`,\n *  then characters will be inserted as if [value] contained the four characters `\"null\"`.\n * @param startIndex the beginning (inclusive) of the subsequence to insert.\n * @param endIndex the end (exclusive) of the subsequence to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic expect fun StringBuilder.insertRange(index: Int, value: CharSequence?, startIndex: Int, endIndex: Int): StringBuilder\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\n@Deprecated(\"Use append(value: Any?) instead\", ReplaceWith(\"append(value = obj)\"), DeprecationLevel.WARNING)\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.append(obj: Any?): StringBuilder = this.append(obj)\n\n/**\n * Builds new string by populating newly created [StringBuilder] using provided [builderAction]\n * and then converting it to [String].\n */\n@kotlin.internal.InlineOnly\npublic inline fun buildString(builderAction: StringBuilder.() -> Unit): String =\n    StringBuilder().apply(builderAction).toString()\n\n/**\n * Builds new string by populating newly created [StringBuilder] initialized with the given [capacity]\n * using provided [builderAction] and then converting it to [String].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun buildString(capacity: Int, builderAction: StringBuilder.() -> Unit): String =\n    StringBuilder(capacity).apply(builderAction).toString()\n\n/**\n * Appends all arguments to the given StringBuilder.\n */\npublic fun StringBuilder.append(vararg value: String?): StringBuilder {\n    for (item in value)\n        append(item)\n    return this\n}\n\n/**\n * Appends all arguments to the given StringBuilder.\n */\npublic fun StringBuilder.append(vararg value: Any?): StringBuilder {\n    for (item in value)\n        append(item)\n    return this\n}\n",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SequencesKt\")\n\npackage kotlin.sequences\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns `true` if [element] is found in the sequence.\n *\n * The operation is _terminal_.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.contains(element: T): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Sequence<T>.elementAt(index: Int): T {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Sequence doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Sequence<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Sequence<T>.elementAtOrNull(index: Int): T? {\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the sequence is empty.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.first(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    return iterator.next()\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the sequence is empty.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.firstOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    return iterator.next()\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns first index of [element], or -1 if the sequence does not contain element.\n *\n * The operation is _terminal_.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.indexOf(element: T): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the sequence does not contain such element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the sequence does not contain such element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the sequence is empty.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.last(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    var last = iterator.next()\n    while (iterator.hasNext())\n        last = iterator.next()\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns last index of [element], or -1 if the sequence does not contain element.\n *\n * The operation is _terminal_.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.lastIndexOf(element: T): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns the last element, or `null` if the sequence is empty.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.lastOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    var last = iterator.next()\n    while (iterator.hasNext())\n        last = iterator.next()\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the single element, or throws an exception if the sequence is empty or has more than one element.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.single(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    val single = iterator.next()\n    if (iterator.hasNext())\n        throw IllegalArgumentException(\"Sequence has more than one element.\")\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Sequence contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the sequence is empty or has more than one element.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.singleOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    val single = iterator.next()\n    if (iterator.hasNext())\n        return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a sequence containing all elements except first [n] elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Sequence<T>.drop(n: Int): Sequence<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return when {\n        n == 0 -> this\n        this is DropTakeSequence -> this.drop(n)\n        else -> DropSequence(this, n)\n    }\n}\n\n/**\n * Returns a sequence containing all elements except first elements that satisfy the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Sequence<T>.dropWhile(predicate: (T) -> Boolean): Sequence<T> {\n    return DropWhileSequence(this, predicate)\n}\n\n/**\n * Returns a sequence containing only elements matching the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T> Sequence<T>.filter(predicate: (T) -> Boolean): Sequence<T> {\n    return FilteringSequence(this, true, predicate)\n}\n\n/**\n * Returns a sequence containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T> Sequence<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): Sequence<T> {\n    // TODO: Rewrite with generalized MapFilterIndexingSequence\n    return TransformingSequence(FilteringSequence(IndexingSequence(this), true, { predicate(it.index, it.value) }), { it.value })\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a sequence containing all elements that are instances of specified type parameter R.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic inline fun <reified R> Sequence<*>.filterIsInstance(): Sequence<@kotlin.internal.NoInfer R> {\n    @Suppress(\"UNCHECKED_CAST\")\n    return filter { it is R } as Sequence<R>\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Sequence<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a sequence containing all elements not matching the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T> Sequence<T>.filterNot(predicate: (T) -> Boolean): Sequence<T> {\n    return FilteringSequence(this, false, predicate)\n}\n\n/**\n * Returns a sequence containing all elements that are not `null`.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T : Any> Sequence<T?>.filterNotNull(): Sequence<T> {\n    @Suppress(\"UNCHECKED_CAST\")\n    return filterNot { it == null } as Sequence<T>\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic fun <C : MutableCollection<in T>, T : Any> Sequence<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a sequence containing first [n] elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Sequence<T>.take(n: Int): Sequence<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return when {\n        n == 0 -> emptySequence()\n        this is DropTakeSequence -> this.take(n)\n        else -> TakeSequence(this, n)\n    }\n}\n\n/**\n * Returns a sequence containing first elements satisfying the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Sequence<T>.takeWhile(predicate: (T) -> Boolean): Sequence<T> {\n    return TakeWhileSequence(this, predicate)\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T : Comparable<T>> Sequence<T>.sorted(): Sequence<T> {\n    return object : Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val sortedList = this@sorted.toMutableList()\n            sortedList.sort()\n            return sortedList.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic inline fun <T, R : Comparable<R>> Sequence<T>.sortedBy(crossinline selector: (T) -> R?): Sequence<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic inline fun <T, R : Comparable<R>> Sequence<T>.sortedByDescending(crossinline selector: (T) -> R?): Sequence<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T : Comparable<T>> Sequence<T>.sortedDescending(): Sequence<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T> Sequence<T>.sortedWith(comparator: Comparator<in T>): Sequence<T> {\n    return object : Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val sortedList = this@sortedWith.toMutableList()\n            sortedList.sortWith(comparator)\n            return sortedList.iterator()\n        }\n    }\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associate\n */\npublic inline fun <T, K, V> Sequence<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    return associateTo(LinkedHashMap<K, V>(), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given sequence indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateBy\n */\npublic inline fun <T, K> Sequence<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    return associateByTo(LinkedHashMap<K, T>(), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given sequence.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateByWithValueTransform\n */\npublic inline fun <T, K, V> Sequence<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    return associateByTo(LinkedHashMap<K, V>(), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given sequence\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Sequence<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given sequence.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Sequence<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Sequence<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given sequence and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Sequence<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given sequence,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Sequence<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n *\n * The operation is _terminal_.\n */\npublic fun <T, C : MutableCollection<in T>> Sequence<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a [HashSet] of all elements.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>())\n}\n\n/**\n * Returns a [List] containing all elements.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toList(): List<T> {\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toMutableList(): MutableList<T> {\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toSet(): Set<T> {\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single sequence of all elements from results of [transform] function being invoked on each element of original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic fun <T, R> Sequence<T>.flatMap(transform: (T) -> Sequence<R>): Sequence<R> {\n    return FlatteningSequence(this, transform, { it.iterator() })\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapTo(destination: C, transform: (T) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original sequence by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Sequence<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original sequence\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Sequence<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original sequence by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Sequence<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original sequence\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Sequence<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a sequence to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Sequence<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to each element in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic fun <T, R> Sequence<T>.map(transform: (T) -> R): Sequence<R> {\n    return TransformingSequence(this, transform)\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to each element and its index in the original sequence.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T, R> Sequence<T>.mapIndexed(transform: (index: Int, T) -> R): Sequence<R> {\n    return TransformingIndexedSequence(this, transform)\n}\n\n/**\n * Returns a sequence containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original sequence.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T, R : Any> Sequence<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): Sequence<R> {\n    return TransformingIndexedSequence(this, transform).filterNotNull()\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original sequence\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Sequence<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original sequence\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a sequence containing only the non-null results of applying the given [transform] function\n * to each element in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T, R : Any> Sequence<T>.mapNotNull(transform: (T) -> R?): Sequence<R> {\n    return TransformingSequence(this, transform).filterNotNull()\n}\n\n/**\n * Applies the given [transform] function to each element in the original sequence\n * and appends only the non-null results to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Sequence<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original sequence\n * and appends the results to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a sequence that wraps each element of the original sequence\n * into an [IndexedValue] containing the index of that element and the element itself.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T> Sequence<T>.withIndex(): Sequence<IndexedValue<T>> {\n    return IndexingSequence(this)\n}\n\n/**\n * Returns a sequence containing only distinct elements from the given sequence.\n * \n * The elements in the resulting sequence are in the same order as they were in the source sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Sequence<T>.distinct(): Sequence<T> {\n    return this.distinctBy { it }\n}\n\n/**\n * Returns a sequence containing only elements from the given sequence\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting sequence are in the same order as they were in the source sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T, K> Sequence<T>.distinctBy(selector: (T) -> K): Sequence<T> {\n    return DistinctSequence(this, selector)\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given sequence.\n * \n * The returned set preserves the element iteration order of the original sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toMutableSet(): MutableSet<T> {\n    val set = LinkedHashSet<T>()\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Sequence<T>.all(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if sequence has at least one element.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Sequence<T>.any(): Boolean {\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Sequence<T>.any(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.count(): Int {\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.count(predicate: (T) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R> Sequence<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original sequence.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R> Sequence<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Double>.max(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Float>.max(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\npublic fun <T : Comparable<T>> Sequence<T>.max(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.maxWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Double>.min(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Float>.min(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\npublic fun <T : Comparable<T>> Sequence<T>.min(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.minWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the sequence has no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Sequence<T>.none(): Boolean {\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Sequence<T>.none(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns a sequence which performs the given [action] on each element of the original sequence as they pass through it.\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@SinceKotlin(\"1.1\")\npublic fun <T> Sequence<T>.onEach(action: (T) -> Unit): Sequence<T> {\n    return map {\n        action(it)\n        it\n    }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Sequence<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty sequence can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original sequence.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Sequence<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty sequence can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element. Returns null if the sequence is empty.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun <S, T : S> Sequence<T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun <T, R> Sequence<T>.scan(initial: R, operation: (acc: R, T) -> R): Sequence<R> {\n    return sequence {\n        yield(initial)\n        var accumulator = initial\n        for (element in this@scan) {\n            accumulator = operation(accumulator, element)\n            yield(accumulator)\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun <T, R> Sequence<T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): Sequence<R> {\n    return sequence {\n        yield(initial)\n        var index = 0\n        var accumulator = initial\n        for (element in this@scanIndexed) {\n            accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n            yield(accumulator)\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.scanReduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun <S, T : S> Sequence<T>.scanReduce(operation: (acc: S, T) -> S): Sequence<S> {\n    return sequence {\n        val iterator = iterator()\n        if (iterator.hasNext()) {\n            var accumulator: S = iterator.next()\n            yield(accumulator)\n            while (iterator.hasNext()) {\n                accumulator = operation(accumulator, iterator.next())\n                yield(accumulator)\n            }\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original sequence and current accumulator value that starts with the first element of this sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.scanReduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun <S, T : S> Sequence<T>.scanReduceIndexed(operation: (index: Int, acc: S, T) -> S): Sequence<S> {\n    return sequence {\n        val iterator = iterator()\n        if (iterator.hasNext()) {\n            var accumulator: S = iterator.next()\n            yield(accumulator)\n            var index = 1\n            while (iterator.hasNext()) {\n                accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n                yield(accumulator)\n            }\n        }\n    }\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T : Any> Sequence<T?>.requireNoNulls(): Sequence<T> {\n    return map { it ?: throw IllegalArgumentException(\"null element found in $this.\") }\n}\n\n/**\n * Splits this sequence into a sequence of lists each not exceeding the given [size].\n * \n * The last list in the resulting sequence may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.chunked(size: Int): Sequence<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this sequence into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return sequence of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.chunked(size: Int, transform: (List<T>) -> R): Sequence<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence without the first occurrence of the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.minus(element: T): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            var removed = false\n            return this@minus.filter { if (!removed && it == element) { removed = true; false } else true }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] array.\n * \n * Note that the source sequence and the array being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * The [elements] array may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Array<out T>): Sequence<T> {\n    if (elements.isEmpty()) return this\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.toHashSet()\n            return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] collection.\n * \n * Note that the source sequence and the collection being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * The [elements] collection may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Iterable<T>): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.convertToSetForSetOperation()\n            if (other.isEmpty())\n                return this@minus.iterator()\n            else\n                return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] sequence.\n * \n * Note that the source sequence and the sequence being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * The operation is _intermediate_ for this sequence and _terminal_ and _stateful_ for the [elements] sequence.\n * \n * The [elements] sequence may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Sequence<T>): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.toHashSet()\n            if (other.isEmpty())\n                return this@minus.iterator()\n            else\n                return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence without the first occurrence of the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minusElement(element: T): Sequence<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original sequence into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence and then the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(element: T): Sequence<T> {\n    return sequenceOf(this, sequenceOf(element)).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] array.\n * \n * Note that the source sequence and the array being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Array<out T>): Sequence<T> {\n    return this.plus(elements.asList())\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] collection.\n * \n * Note that the source sequence and the collection being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Iterable<T>): Sequence<T> {\n    return sequenceOf(this, elements.asSequence()).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] sequence.\n * \n * Note that the source sequence and the sequence being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Sequence<T>): Sequence<T> {\n    return sequenceOf(this, elements).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence and then the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.plusElement(element: T): Sequence<T> {\n    return plus(element)\n}\n\n/**\n * Returns a sequence of snapshots of the window of the given [size]\n * sliding along this sequence with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): Sequence<List<T>> {\n    return windowedSequence(size, step, partialWindows, reuseBuffer = false)\n}\n\n/**\n * Returns a sequence of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this sequence with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): Sequence<R> {\n    return windowedSequence(size, step, partialWindows, reuseBuffer = true).map(transform)\n}\n\n/**\n * Returns a sequence of values built from the elements of `this` sequence and the [other] sequence with the same index.\n * The resulting sequence ends as soon as the shortest input sequence ends.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Sequences.Transformations.zip\n */\npublic infix fun <T, R> Sequence<T>.zip(other: Sequence<R>): Sequence<Pair<T, R>> {\n    return MergingSequence(this, other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a sequence of values built from the elements of `this` sequence and the [other] sequence with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The resulting sequence ends as soon as the shortest input sequence ends.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Sequences.Transformations.zipWithTransform\n */\npublic fun <T, R, V> Sequence<T>.zip(other: Sequence<R>, transform: (a: T, b: R) -> V): Sequence<V> {\n    return MergingSequence(this, other, transform)\n}\n\n/**\n * Returns a sequence of pairs of each two adjacent elements in this sequence.\n * \n * The returned sequence is empty if this sequence contains less than two elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.zipWithNext(): Sequence<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this sequence.\n * \n * The returned sequence is empty if this sequence contains less than two elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.zipWithNext(transform: (a: T, b: T) -> R): Sequence<R> {\n    return sequence result@ {\n        val iterator = iterator()\n        if (!iterator.hasNext()) return@result\n        var current = iterator.next()\n        while (iterator.hasNext()) {\n            val next = iterator.next()\n            yield(transform(current, next))\n            current = next\n        }\n    }\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Sequence<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Sequence<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original sequence returning its elements when being iterated.\n */\npublic fun <T> Sequence<T>.asIterable(): Iterable<T> {\n    return Iterable { this.iterator() }\n}\n\n/**\n * Returns this sequence as a [Sequence].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.asSequence(): Sequence<T> {\n    return this\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Sequence<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Sequence<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Sequence<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Sequence<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Sequence<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Sequence<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Sequence<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Sequence<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Sequence<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Sequence<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Sequence<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Sequence<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.js\n\n/**\n * Function corresponding to JavaScript's `typeof` operator\n */\n@kotlin.internal.InlineOnly\n@Suppress(\"UNUSED_PARAMETER\")\npublic inline fun jsTypeOf(a: Any?): String = js(\"typeof a\")\n",null,null,null,null,null,null,null,null,"import io.github.kgpu.*\n\n\nfun mathTest() {\n    val matrix = Matrix4f().translate(1f, 2f, 3f)\n\n    println(\"Op0 = ${matrix.toFloats().joinToString()}\")\n}\n\nsuspend fun runCubeExample(window: Window) {\n    val vertices = floatArrayOf(\n        -1f, -1f, 1f, 1f, 0f, 0f,\n        1f, -1f, 1f, 1f, 0f, 0f,\n        1f, 1f, 1f, 1f, 0f, 0f,\n        -1f, 1f, 1f, 1f, 0f, 0f,\n\n        -1f, 1f, -1f, 0f, 0f, 1f,\n        1f, 1f, -1f, 0f, 0f, 1f,\n        1f, -1f, -1f, 0f, 0f, 1f,\n        -1f, -1f, -1f, 0f, 0f, 1f,\n\n        1f, -1f, -1f, .25f, .4f, .5f,\n        1f, 1f, -1f, .25f, .4f, .5f,\n        1f, 1f, 1f, .25f, .4f, .5f,\n        1f, -1f, 1f, .25f, .4f, .5f,\n\n        -1f, -1f, 1f, .7f, .7f, .2f,\n        -1f, 1f, 1f, .7f, .7f, .2f,\n        -1f, 1f, -1f, .7f, .7f, .2f,\n        -1f, -1f, -1f, .7f, .7f, .2f,\n\n        1f, 1f, -1f, .1f, .4f, .1f,\n        -1f, 1f, -1f, .1f, .4f, .1f,\n        -1f, 1f, 1f, .1f, .4f, .1f,\n        1f, 1f, 1f, .1f, .4f, .1f,\n\n        1f, -1f, 1f, .9f, .5f, .5f,\n        -1f, -1f, 1f, .9f, .5f, .5f,\n        -1f, -1f, -1f, .9f, .5f, .5f,\n        1f, -1f, -1f, .9f, .5f, .5f\n    )\n\n    val indices = shortArrayOf(\n        0, 1, 2, 2, 3, 0,\n        4, 5, 6, 6, 7, 4,\n        8, 9, 10, 10, 11, 8,\n        12, 13, 14, 14, 15, 12,\n        16, 17, 18, 18, 19, 16,\n        20, 21, 22, 22, 23, 20\n    )\n\n    fun getProjectionMatrix(): Matrix4f {\n        val windowSize = window.getWindowSize()\n        val aspectRatio = windowSize.width.toFloat() / windowSize.height\n\n        return Matrix4f().perspective(MathUtils.toRadians(45f), aspectRatio, 1f, 10f)\n    }\n\n    val projMatrix = getProjectionMatrix()\n    val viewMatrix = Matrix4f().lookAt(\n        Vec3f(3.5f, 5f, 3f),\n        Vec3f(0f, 0f, 0f),\n        MathUtils.UNIT_Z\n    )\n    val transMatrix = projMatrix.mul(viewMatrix)\n\n    val adapter = window.requestAdapterAsync(PowerPreference.DEFAULT)\n    val device = adapter.requestDeviceAsync();\n\n    val vertexShader = ShaderUtils.fromInternalTextFile(device, \"cube.vert\", ShaderType.VERTEX)\n    val fragShader = ShaderUtils.fromInternalTextFile(device, \"shared.frag\", ShaderType.FRAGMENT)\n\n    val vertexBuffer = BufferUtils.createFloatBuffer(device, vertices, BufferUsage.VERTEX)\n    val indexBuffer = BufferUtils.createShortBuffer(device, indices, BufferUsage.INDEX)\n    val matrixBuffer = BufferUtils.createFloatBuffer(\n        device, transMatrix.toFloats(),\n        BufferUsage.UNIFORM or BufferUsage.COPY_DST\n    )\n\n    val descriptor = BindGroupLayoutDescriptor(\n        BindGroupLayoutEntry(0, ShaderVisibility.VERTEX, BindingType.UNIFORM_BUFFER)\n    )\n    val bindGroupLayout = device.createBindGroupLayout(descriptor);\n    val pipelineLayout = device.createPipelineLayout(PipelineLayoutDescriptor(bindGroupLayout))\n    val bindGroup = device.createBindGroup(BindGroupDescriptor(bindGroupLayout, BindGroupEntry(0, matrixBuffer)))\n\n    val pipelineDesc = createRenderPipeline(pipelineLayout, vertexShader, fragShader, CullMode.BACK)\n    val pipeline = device.createRenderPipeline(pipelineDesc)\n    val swapChainDescriptor = SwapChainDescriptor(device, TextureFormat.BGRA8_UNORM);\n\n    var swapChain = window.configureSwapChain(swapChainDescriptor)\n\n    Kgpu.runLoop(window) {\n        if (swapChain.isOutOfDate()) {\n            swapChain = window.configureSwapChain(swapChainDescriptor)\n        }\n\n        val swapChainTexture = swapChain.getCurrentTextureView();\n        val cmdEncoder = device.createCommandEncoder();\n\n        val colorAttachment = RenderPassColorAttachmentDescriptor(swapChainTexture, Color.WHITE)\n        val renderPassEncoder = cmdEncoder.beginRenderPass(RenderPassDescriptor(colorAttachment))\n        renderPassEncoder.setPipeline(pipeline)\n        renderPassEncoder.setBindGroup(0, bindGroup)\n        renderPassEncoder.setVertexBuffer(0, vertexBuffer)\n        renderPassEncoder.setIndexBuffer(indexBuffer)\n        renderPassEncoder.drawIndexed(indices.size, 1)\n        renderPassEncoder.endPass()\n\n        val cmdBuffer = cmdEncoder.finish()\n        val queue = device.getDefaultQueue()\n\n        viewMatrix.rotateZ(.01f)\n        queue.writeBuffer(matrixBuffer, getProjectionMatrix().mul(viewMatrix).toBytes())\n        queue.submit(cmdBuffer)\n        swapChain.present();\n    }\n}\n\nsuspend fun runTriangleExample(window: Window) {\n    mathTest()\n\n    val adapter = window.requestAdapterAsync(PowerPreference.DEFAULT)\n    val device = adapter.requestDeviceAsync();\n    val vertexShader = ShaderUtils.fromInternalTextFile(device, \"triangle.vert\", ShaderType.VERTEX)\n    val fragShader = ShaderUtils.fromInternalTextFile(device, \"shared.frag\", ShaderType.FRAGMENT)\n\n    val vertices = floatArrayOf(\n        -.5f, .5f, 0f, 1f, 0f, 0f,\n        .5f, .5f, 0f, 0f, 1f, 0f,\n        0f, -.5f, 0f, 0f, 0f, 1f\n    )\n    val buffer = BufferUtils.createFloatBuffer(device, vertices, BufferUsage.VERTEX)\n    val pipelineLayout = device.createPipelineLayout(PipelineLayoutDescriptor())\n\n    val pipelineDesc = createRenderPipeline(pipelineLayout, vertexShader, fragShader, CullMode.NONE)\n    val pipeline = device.createRenderPipeline(pipelineDesc)\n    val swapChainDescriptor = SwapChainDescriptor(device, TextureFormat.BGRA8_UNORM);\n\n    var swapChain = window.configureSwapChain(swapChainDescriptor)\n\n    Kgpu.runLoop(window) {\n        if (swapChain.isOutOfDate()) {\n            swapChain = window.configureSwapChain(swapChainDescriptor)\n        }\n\n        val swapChainTexture = swapChain.getCurrentTextureView();\n        val cmdEncoder = device.createCommandEncoder();\n\n        val colorAttachment = RenderPassColorAttachmentDescriptor(swapChainTexture, Color.WHITE)\n        val renderPassEncoder = cmdEncoder.beginRenderPass(RenderPassDescriptor(colorAttachment))\n        renderPassEncoder.setPipeline(pipeline)\n        renderPassEncoder.setVertexBuffer(0, buffer)\n        renderPassEncoder.draw(3, 1)\n        renderPassEncoder.endPass()\n\n        val cmdBuffer = cmdEncoder.finish()\n        val queue = device.getDefaultQueue()\n        queue.submit(cmdBuffer)\n        swapChain.present();\n    }\n}\n\nprivate fun createRenderPipeline(\n    pipelineLayout: PipelineLayout,\n    vertexModule: ShaderModule,\n    fragModule: ShaderModule,\n    cullMode: CullMode\n): RenderPipelineDescriptor {\n    return RenderPipelineDescriptor(\n        pipelineLayout,\n        ProgrammableStageDescriptor(vertexModule, \"main\"),\n        ProgrammableStageDescriptor(fragModule, \"main\"),\n        PrimitiveTopology.TRIANGLE_LIST,\n        RasterizationStateDescriptor(\n            FrontFace.CCW,\n            cullMode\n        ),\n        arrayOf(\n            ColorStateDescriptor(\n                TextureFormat.BGRA8_UNORM,\n                BlendDescriptor(),\n                BlendDescriptor(),\n                0xF\n            )\n        ),\n        Kgpu.undefined,\n        VertexStateDescriptor(\n            IndexFormat.UINT16, VertexBufferLayoutDescriptor(\n                6 * Primitives.FLOAT_BYTES,\n                InputStepMode.VERTEX,\n                VertexAttributeDescriptor(VertexFormat.FLOAT3, 0, 0),\n                VertexAttributeDescriptor(VertexFormat.FLOAT3, 3 * Primitives.FLOAT_BYTES, 1)\n            )\n        ),\n        1,\n        0xFFFFFFFF,\n        false\n    )\n}\n","import io.github.kgpu.Kgpu\nimport io.github.kgpu.Window\nimport kotlinx.coroutines.GlobalScope\nimport kotlinx.coroutines.launch\nimport org.w3c.dom.url.URL\nimport kotlin.browser.window\n\nfun main(){\n    Kgpu.init()\n\n    val kgpuWindow = Window()\n    kgpuWindow.setTitle(\"Kgpu - Web\")\n\n    val params = URL(window.location.href).searchParams;\n\n    GlobalScope.launch {\n        when(params.get(\"example\")){\n            \"1\" -> runCubeExample(kgpuWindow)\n            else -> runTriangleExample(kgpuWindow)\n        }\n    }\n}","package io.github.kgpu\n\nexpect object Kgpu {\n    val backendName: String\n    val undefined: Nothing?\n\n    fun init()\n\n    fun runLoop(window: Window, func: () -> Unit)\n}\n\nobject Primitives {\n    const val FLOAT_BYTES: Long = 4\n}\n\nexpect class Device {\n\n    fun createShaderModule(data: ByteArray): ShaderModule\n\n    fun createRenderPipeline(desc: RenderPipelineDescriptor): RenderPipeline\n\n    fun createPipelineLayout(desc: PipelineLayoutDescriptor): PipelineLayout\n\n    fun createTexture(desc: TextureDescriptor): Texture\n\n    fun createCommandEncoder(): CommandEncoder\n\n    fun getDefaultQueue(): Queue\n\n    fun createBuffer(desc: BufferDescriptor): Buffer\n\n    fun createBindGroupLayout(desc: BindGroupLayoutDescriptor): BindGroupLayout\n\n    @Deprecated(message = \"No longer part of the spec, but replacement has not been implemented in browsers!\")\n    fun createBufferWithData(desc: BufferDescriptor, data: ByteArray): Buffer\n\n    fun createBindGroup(desc: BindGroupDescriptor): BindGroup\n}\n\nexpect class Adapter {\n\n    suspend fun requestDeviceAsync(): Device\n\n}\n\nexpect enum class PowerPreference {\n    LOW_POWER, DEFAULT, HIGH_PERFORMANCE\n}\n\nexpect class Window() {\n\n    fun setTitle(title: String)\n\n    fun isCloseRequested(): Boolean\n\n    fun update()\n\n    suspend fun requestAdapterAsync(preference: PowerPreference): Adapter\n\n    fun getWindowSize(): WindowSize\n\n    fun configureSwapChain(desc: SwapChainDescriptor): SwapChain\n}\n\nclass Color(val r: Double, val g: Double, val b: Double, val a: Double) {\n\n    companion object {\n        val BLACK = Color(0.0, 0.0, 0.0, 1.0)\n        val WHITE = Color(1.0, 1.0, 1.0, 1.0)\n        val RED = Color(1.0, 0.0, 0.0, 1.0)\n        val GREEN = Color(0.0, 1.0, 0.0, 1.0)\n        val BLUE = Color(0.0, 0.0, 1.0, 1.0)\n        val CLEAR = Color(0.0, 0.0, 0.0, 0.0)\n    }\n\n}\n\nclass WindowSize(val width: Int, val height: Int) {\n    override fun toString(): String {\n        return \"WindowSize($width, $height)\"\n    }\n}\n\nexpect class CommandEncoder {\n\n    fun beginRenderPass(desc: RenderPassDescriptor): RenderPassEncoder\n\n    fun finish(): CommandBuffer\n}\n\nexpect class RenderPassEncoder {\n\n    fun setPipeline(pipeline: RenderPipeline)\n\n    fun draw(vertexCount: Int, instanceCount: Int, firstVertex: Int = 0, firstInstance: Int = 0)\n\n    fun endPass()\n\n    fun setVertexBuffer(slot: Long, buffer: Buffer, offset: Long = 0, size: Long = buffer.size)\n\n    fun drawIndexed(\n        indexCount: Int, instanceCount: Int, firstVertex: Int = 0, baseVertex: Int = 0, firstInstance: Int = 0\n    )\n\n    fun setIndexBuffer(buffer: Buffer, offset: Long = 0, size: Long = buffer.size)\n\n    fun setBindGroup(index: Int, bindGroup: BindGroup)\n}\n\nexpect class Queue {\n\n    fun submit(vararg cmdBuffers: CommandBuffer)\n\n    fun writeBuffer(\n        buffer: Buffer,\n        data: ByteArray,\n        offset: Long = 0,\n        dataOffset: Long = 0,\n        size: Long = data.size.toLong()\n    )\n}\n\nexpect interface IntoBindingResource\nexpect class TextureView\nexpect class ShaderModule\nexpect class ProgrammableStageDescriptor(module: ShaderModule, entryPoint: String)\nexpect class PipelineLayout\nexpect class BindGroupLayout\nexpect class PipelineLayoutDescriptor(vararg bindGroupLayouts: BindGroupLayout)\nexpect class RenderPipeline\nexpect class CommandBuffer\nexpect class BindGroup\n\nexpect class Extent3D(width: Long, height: Long, depth: Long)\n\nobject TextureUsage {\n    const val COPY_SRC: Long = 1\n    const val COPY_DST: Long = 2\n    const val SAMPLED: Long = 4\n    const val STORAGE: Long = 8\n    const val OUTPUT_ATTACHMENT: Long = 16\n}\n\nexpect class RenderPassColorAttachmentDescriptor(\n    attachment: TextureView,\n    clearColor: Color?,\n    storeOp: StoreOp = StoreOp.STORE\n)\n\nexpect class RenderPassDescriptor(\n    vararg colorAttachments: RenderPassColorAttachmentDescriptor\n)\n\nexpect class SwapChain {\n\n    fun getCurrentTextureView(): TextureView\n\n    fun present()\n\n    fun isOutOfDate(): Boolean\n}\n\nexpect class BindGroupEntry(binding: Long, resource: IntoBindingResource)\n\nexpect class BindGroupDescriptor(layout: BindGroupLayout, vararg entries: BindGroupEntry)\n\nobject ShaderVisibility {\n\n    const val VERTEX: Long = 1\n    const val FRAGMENT: Long = 2\n    const val COMPUTE: Long = 4\n\n}\n\nexpect class BindGroupLayoutEntry(\n    binding: Long,\n    visibility: Long,\n    type: BindingType\n)\n\nexpect class BindGroupLayoutDescriptor(vararg entries: BindGroupLayoutEntry)\n\nexpect class SwapChainDescriptor(\n    device: Device,\n    format: TextureFormat,\n    usage: Long = TextureUsage.OUTPUT_ATTACHMENT\n)\n\nexpect class Texture {\n    fun createView(desc: TextureViewDescriptor?): TextureView\n}\n\nobject BufferUsage {\n    const val MAP_READ: Long = 1\n    const val MAP_WRITE: Long = 2\n    const val COPY_SRC: Long = 4\n    const val COPY_DST: Long = 8\n    const val INDEX: Long = 16\n    const val VERTEX: Long = 32\n    const val UNIFORM: Long = 64\n    const val STORAGE: Long = 128\n    const val INDIRECT: Long = 256\n    const val QUERY_RESOLVE: Long = 512\n}\n\nexpect class BufferDescriptor(\n    size: Long,\n    usage: Long,\n    mappedAtCreation: Boolean\n)\n\nexpect class Buffer : IntoBindingResource {\n\n    val size: Long\n\n    fun getMappedData(start: Long, size: Long): BufferData\n\n    fun unmap();\n}\n\nexpect class BufferData {\n\n    fun putBytes(bytes: ByteArray, offset: Int = 0)\n\n}\n\nexpect class TextureViewDescriptor(\n    format: TextureFormat,\n    dimension: TextureViewDimension,\n    aspect: TextureAspect,\n    baseMipLevel: Long,\n    mipLevelCount: Long,\n    baseArrayLayer: Long,\n    arrayLayerCount: Long\n)\n\nexpect class TextureDescriptor(\n    size: Extent3D,\n    mipLevelCount: Long,\n    sampleCount: Int,\n    dimension: TextureDimension,\n    format: TextureFormat,\n    textureUsage: Long\n)\n\nexpect class RenderPipelineDescriptor(\n    layout: PipelineLayout,\n    vertexStage: ProgrammableStageDescriptor,\n    fragmentStage: ProgrammableStageDescriptor,\n    primitiveTopology: PrimitiveTopology,\n    rasterizationState: RasterizationStateDescriptor,\n    colorStates: Array<ColorStateDescriptor>,\n    depthStencilState: Any?,\n    vertexState: VertexStateDescriptor,\n    sampleCount: Int,\n    sampleMask: Long,\n    alphaToCoverage: Boolean\n);\n\n\nexpect enum class PrimitiveTopology {\n    POINT_LIST,\n    LINE_LIST,\n    LINE_STRIP,\n    TRIANGLE_LIST,\n    TRIANGLE_STRIP,\n}\n\nexpect enum class FrontFace {\n    CCW,\n    CW,\n}\n\nexpect enum class CullMode {\n    NONE,\n    FRONT,\n    BACK,\n}\n\nexpect class RasterizationStateDescriptor(\n    frontFace: FrontFace = FrontFace.CCW,\n    cullMode: CullMode = CullMode.NONE,\n    clampDepth: Boolean = false,\n    depthBias: Long = 0,\n    depthBiasSlopeScale: Float = 0f,\n    depthBiasClamp: Float = 0f\n)\n\nexpect class ColorStateDescriptor(\n    format: TextureFormat,\n    alphaBlend: BlendDescriptor,\n    colorBlend: BlendDescriptor,\n    writeMask: Long\n)\n\nexpect class VertexAttributeDescriptor(\n    format: VertexFormat,\n    offset: Long,\n    shaderLocation: Int\n)\n\nexpect class VertexBufferLayoutDescriptor(\n    arrayStride: Long,\n    stepMode: InputStepMode,\n    vararg attributes: VertexAttributeDescriptor\n)\n\nexpect class VertexStateDescriptor(\n    indexFormat: IndexFormat,\n    vararg vertexBuffers: VertexBufferLayoutDescriptor\n)\n\nexpect class BlendDescriptor(\n    srcFactor: BlendFactor = BlendFactor.ONE,\n    dstFactor: BlendFactor = BlendFactor.ZERO,\n    operation: BlendOperation = BlendOperation.ADD\n)\n\nexpect enum class TextureViewDimension {\n    D1,\n    D2,\n    D2_ARRAY,\n    CUBE,\n    CUBE_ARRAY,\n    D3,\n}\n\nexpect enum class TextureAspect {\n    ALL,\n    STENCIL_ONLY,\n    DEPTH_ONLY,\n}\n\nexpect enum class TextureDimension {\n    D1, D2, D3\n}\n\nexpect enum class TextureFormat {\n    R8_UNORM,\n    R8_SNORM,\n    R8_UINT,\n    R8_SINT,\n    R16_UINT,\n    R16_SINT,\n    R16_FLOAT,\n    RG8_UNORM,\n    RG8_SNORM,\n    RG8_UINT,\n    RG8_SINT,\n    R32_UINT,\n    R32_SINT,\n    R32_FLOAT,\n    RG16_UINT,\n    RG16_SINT,\n    RG16_FLOAT,\n    RGBA8_UNORM,\n    RGBA8_UNORM_SRGB,\n    RGBA8_SNORM,\n    RGBA8_UINT,\n    RGBA8_SINT,\n    BGRA8_UNORM,\n    BGRA8_UNORM_SRGB,\n    RGB10A2_UNORM,\n    RG11B10_FLOAT,\n    RG32_UINT,\n    RG32_SINT,\n    RG32_FLOAT,\n    RGBA16_UINT,\n    RGBA16_SINT,\n    RGBA16_FLOAT,\n    RGBA32_UINT,\n    RGBA32_SINT,\n    RGBA32_FLOAT,\n    DEPTH32_FLOAT,\n    DEPTH24_PLUS,\n    DEPTH24_PLUS_STENCIL8,\n}\n\nexpect enum class BlendOperation {\n    ADD,\n    SUBTRACT,\n    REVERSE_SUBTRACT,\n    MIN,\n    MAX,\n}\n\nexpect enum class StencilOperation {\n    KEEP,\n    ZERO,\n    REPLACE,\n    INVERT,\n    INCREMENT_CLAMP,\n    DECREMENT_CLAMP,\n    INCREMENT_WRAP,\n    DECREMENT_WRAP,\n}\n\nexpect enum class BlendFactor {\n    ZERO,\n    ONE,\n    SRC_COLOR,\n    ONE_MINUS_SRC_COLOR,\n    SRC_ALPHA,\n    ONE_MINUS_SRC_ALPHA,\n    DST_COLOR,\n    ONE_MINUS_DST_COLOR,\n    DST_ALPHA,\n    ONE_MINUS_DST_ALPHA,\n    SRC_ALPHA_SATURATED,\n    BLEND_COLOR,\n    ONE_MINUS_BLEND_COLOR,\n}\n\nexpect enum class IndexFormat {\n    UINT16,\n    UINT32,\n}\n\nexpect enum class VertexFormat {\n    UCHAR2,\n    UCHAR4,\n    CHAR2,\n    CHAR4,\n    UCHAR2_NORM,\n    UCHAR4_NORM,\n    CHAR2_NORM,\n    CHAR4_NORM,\n    USHORT2,\n    USHORT4,\n    SHORT2,\n    SHORT4,\n    USHORT2_NORM,\n    USHORT4_NORM,\n    SHORT2_NORM,\n    SHORT4_NORM,\n    HALF2,\n    HALF4,\n    FLOAT,\n    FLOAT2,\n    FLOAT3,\n    FLOAT4,\n    UINT,\n    UINT2,\n    UINT3,\n    UINT4,\n    INT,\n    INT2,\n    INT3,\n    INT4,\n}\n\nexpect enum class InputStepMode {\n    VERTEX,\n    INSTANCE,\n}\n\nexpect enum class LoadOp {\n    CLEAR,\n    LOAD,\n}\n\nexpect enum class StoreOp {\n    CLEAR,\n    STORE,\n}\n\nexpect enum class BindingType {\n    UNIFORM_BUFFER,\n    STORAGE_BUFFER,\n    READONLY_STORAGE_BUFFER,\n    SAMPLER,\n    COMPARISON_SAMPLER,\n    SAMPLED_TEXTURE,\n    READONLY_STORAGE_TEXTURE,\n    WRITEONLY_STORAGE_TEXTURE,\n}","package io.github.kgpu\n\nimport kotlin.math.PI\n\nobject MathUtils{\n\n    val UNIT_X = Vec3f(1f, 0f, 0f)\n    val UNIT_Y = Vec3f(0f, 1f, 0f)\n    val UNIT_Z = Vec3f(0f, 0f, 1f)\n    val VEC_ONE = Vec3f(1f, 1f, 1f)\n    const val PIf = PI.toFloat()\n\n    fun toRadians(degrees: Float) : Float{\n        return degrees * PIf / 180f\n    }\n}\n\nexpect class Matrix4f(){\n\n    fun toFloats() : FloatArray\n\n    fun toBytes() : ByteArray\n\n    fun translate(x: Float, y: Float, z: Float) : Matrix4f\n\n    fun ortho(left: Float, right: Float, bottom: Float, top: Float, near: Float, far: Float) : Matrix4f\n\n    fun lookAt(eye: Vec3f, center: Vec3f, up: Vec3f) : Matrix4f\n\n    fun mul(other: Matrix4f) : Matrix4f\n\n    fun rotateX(angle: Float) : Matrix4f\n\n    fun rotateY(angle: Float) : Matrix4f\n\n    fun rotateZ(angle: Float) : Matrix4f\n\n    fun perspective(fov: Float, aspect: Float, near: Float, far: Float) : Matrix4f\n}\n\nexpect class Vec3f(x: Float, y: Float, z: Float){\n    constructor()\n\n}","package io.github.kgpu\n\nobject ShaderUtils{\n\n    suspend fun fromInternalTextFile(device: Device, file: String, type: ShaderType) : ShaderModule{\n        val shaderSrc = KgpuFiles.loadInternalUtf8(file)\n        val vertexShader = ShaderCompiler.compile(file, shaderSrc, type)\n\n        return device.createShaderModule(vertexShader)\n    }\n\n}\n\nobject BufferUtils{\n\n    fun createBufferFromData(device: Device, data: ByteArray, usage: Long) : Buffer{\n        return device.createBufferWithData(\n            BufferDescriptor(\n                data.size.toLong(),\n                usage,\n                true\n            ),\n            data\n        )\n    }\n\n    fun createFloatBuffer(device: Device, data: FloatArray, usage: Long) : Buffer{\n        return createBufferFromData(device, ByteUtils.toByteArray(data), usage)\n    }\n\n    fun createShortBuffer(device: Device, data: ShortArray, usage: Long) : Buffer{\n        return createBufferFromData(device, ByteUtils.toByteArray(data), usage)\n    }\n}\n\nobject ByteUtils{\n    fun toByteArray(floatArray: FloatArray): ByteArray {\n        val bytes = ByteArray(floatArray.size * 4)\n        floatArray.forEachIndexed { index, float ->\n            run {\n                val i = index * 4\n                val bits = float.toRawBits()\n\n                bytes[i + 3] = (bits shr 24).toByte()\n                bytes[i + 2] = (bits shr 16).toByte()\n                bytes[i + 1] = (bits shr 8).toByte()\n                bytes[i + 0] = bits.toByte()\n            }\n        }\n\n        return bytes\n    }\n\n    fun toByteArray(shortArray: ShortArray): ByteArray {\n        val bytes = ByteArray(shortArray.size * 2)\n        shortArray.forEachIndexed { index, value ->\n            run {\n                val i = index * 2\n\n                bytes[i + 1] = (value.toInt() shr 8).toByte()\n                bytes[i + 0] = value.toByte()\n            }\n        }\n\n        return bytes\n    }\n}","package io.github.kgpu\n\nimport io.github.kgpu.internal.ArrayBufferUtils\nimport kotlinx.coroutines.GlobalScope\nimport kotlinx.coroutines.async\nimport kotlinx.coroutines.await\nimport org.khronos.webgl.Uint8Array\nimport org.khronos.webgl.get\nimport org.w3c.fetch.RequestCredentials\nimport org.w3c.fetch.RequestInit\nimport org.w3c.fetch.SAME_ORIGIN\nimport org.w3c.xhr.XMLHttpRequest\nimport kotlin.browser.window\n\nactual object KgpuFiles {\n\n    actual suspend fun loadInternal(path: String) : ByteArray {\n        val response = window.fetch(path, RequestInit()).await().arrayBuffer().await()\n\n        return ArrayBufferUtils.toByteArray(response);\n    }\n\n    actual suspend fun loadInternalUtf8(path: String) : String {\n        val response = window.fetch(path, RequestInit()).await().text()\n\n        return response.await();\n    }\n\n}","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// NOTE: THIS FILE IS AUTO-GENERATED, DO NOT EDIT!\n// See github.com/kotlin/dukat for details\n\npackage org.w3c.fetch\n\nimport kotlin.js.*\nimport org.khronos.webgl.*\nimport org.w3c.css.masking.*\nimport org.w3c.dom.*\nimport org.w3c.dom.clipboard.*\nimport org.w3c.dom.css.*\nimport org.w3c.dom.events.*\nimport org.w3c.dom.mediacapture.*\nimport org.w3c.dom.parsing.*\nimport org.w3c.dom.pointerevents.*\nimport org.w3c.dom.svg.*\nimport org.w3c.dom.url.*\nimport org.w3c.files.*\nimport org.w3c.notifications.*\nimport org.w3c.performance.*\nimport org.w3c.workers.*\nimport org.w3c.xhr.*\n\n/**\n * Exposes the JavaScript [Headers](https://developer.mozilla.org/en/docs/Web/API/Headers) to Kotlin\n */\npublic external open class Headers(init: dynamic = definedExternally) {\n    fun append(name: String, value: String)\n    fun delete(name: String)\n    fun get(name: String): String?\n    fun has(name: String): Boolean\n    fun set(name: String, value: String)\n}\n\n/**\n * Exposes the JavaScript [Body](https://developer.mozilla.org/en/docs/Web/API/Body) to Kotlin\n */\npublic external interface Body {\n    val bodyUsed: Boolean\n    fun arrayBuffer(): Promise<ArrayBuffer>\n    fun blob(): Promise<Blob>\n    fun formData(): Promise<FormData>\n    fun json(): Promise<Any?>\n    fun text(): Promise<String>\n}\n\n/**\n * Exposes the JavaScript [Request](https://developer.mozilla.org/en/docs/Web/API/Request) to Kotlin\n */\npublic external open class Request(input: dynamic, init: RequestInit = definedExternally) : Body {\n    open val method: String\n    open val url: String\n    open val headers: Headers\n    open val type: RequestType\n    open val destination: RequestDestination\n    open val referrer: String\n    open val referrerPolicy: dynamic\n    open val mode: RequestMode\n    open val credentials: RequestCredentials\n    open val cache: RequestCache\n    open val redirect: RequestRedirect\n    open val integrity: String\n    open val keepalive: Boolean\n    override val bodyUsed: Boolean\n    fun clone(): Request\n    override fun arrayBuffer(): Promise<ArrayBuffer>\n    override fun blob(): Promise<Blob>\n    override fun formData(): Promise<FormData>\n    override fun json(): Promise<Any?>\n    override fun text(): Promise<String>\n}\n\npublic external interface RequestInit {\n    var method: String?\n        get() = definedExternally\n        set(value) = definedExternally\n    var headers: dynamic\n        get() = definedExternally\n        set(value) = definedExternally\n    var body: dynamic\n        get() = definedExternally\n        set(value) = definedExternally\n    var referrer: String?\n        get() = definedExternally\n        set(value) = definedExternally\n    var referrerPolicy: dynamic\n        get() = definedExternally\n        set(value) = definedExternally\n    var mode: RequestMode?\n        get() = definedExternally\n        set(value) = definedExternally\n    var credentials: RequestCredentials?\n        get() = definedExternally\n        set(value) = definedExternally\n    var cache: RequestCache?\n        get() = definedExternally\n        set(value) = definedExternally\n    var redirect: RequestRedirect?\n        get() = definedExternally\n        set(value) = definedExternally\n    var integrity: String?\n        get() = definedExternally\n        set(value) = definedExternally\n    var keepalive: Boolean?\n        get() = definedExternally\n        set(value) = definedExternally\n    var window: Any?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun RequestInit(method: String? = undefined, headers: dynamic = undefined, body: dynamic = undefined, referrer: String? = undefined, referrerPolicy: dynamic = undefined, mode: RequestMode? = undefined, credentials: RequestCredentials? = undefined, cache: RequestCache? = undefined, redirect: RequestRedirect? = undefined, integrity: String? = undefined, keepalive: Boolean? = undefined, window: Any? = undefined): RequestInit {\n    val o = js(\"({})\")\n    o[\"method\"] = method\n    o[\"headers\"] = headers\n    o[\"body\"] = body\n    o[\"referrer\"] = referrer\n    o[\"referrerPolicy\"] = referrerPolicy\n    o[\"mode\"] = mode\n    o[\"credentials\"] = credentials\n    o[\"cache\"] = cache\n    o[\"redirect\"] = redirect\n    o[\"integrity\"] = integrity\n    o[\"keepalive\"] = keepalive\n    o[\"window\"] = window\n    return o\n}\n\n/**\n * Exposes the JavaScript [Response](https://developer.mozilla.org/en/docs/Web/API/Response) to Kotlin\n */\npublic external open class Response(body: dynamic = definedExternally, init: ResponseInit = definedExternally) : Body {\n    open val type: ResponseType\n    open val url: String\n    open val redirected: Boolean\n    open val status: Short\n    open val ok: Boolean\n    open val statusText: String\n    open val headers: Headers\n    open val body: dynamic\n    open val trailer: Promise<Headers>\n    override val bodyUsed: Boolean\n    fun clone(): Response\n    override fun arrayBuffer(): Promise<ArrayBuffer>\n    override fun blob(): Promise<Blob>\n    override fun formData(): Promise<FormData>\n    override fun json(): Promise<Any?>\n    override fun text(): Promise<String>\n\n    companion object {\n        fun error(): Response\n        fun redirect(url: String, status: Short = definedExternally): Response\n    }\n}\n\npublic external interface ResponseInit {\n    var status: Short? /* = 200 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var statusText: String? /* = \"OK\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var headers: dynamic\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ResponseInit(status: Short? = 200, statusText: String? = \"OK\", headers: dynamic = undefined): ResponseInit {\n    val o = js(\"({})\")\n    o[\"status\"] = status\n    o[\"statusText\"] = statusText\n    o[\"headers\"] = headers\n    return o\n}\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface RequestType {\n    companion object\n}\n\npublic inline val RequestType.Companion.EMPTY: RequestType get() = \"\".asDynamic().unsafeCast<RequestType>()\n\npublic inline val RequestType.Companion.AUDIO: RequestType get() = \"audio\".asDynamic().unsafeCast<RequestType>()\n\npublic inline val RequestType.Companion.FONT: RequestType get() = \"font\".asDynamic().unsafeCast<RequestType>()\n\npublic inline val RequestType.Companion.IMAGE: RequestType get() = \"image\".asDynamic().unsafeCast<RequestType>()\n\npublic inline val RequestType.Companion.SCRIPT: RequestType get() = \"script\".asDynamic().unsafeCast<RequestType>()\n\npublic inline val RequestType.Companion.STYLE: RequestType get() = \"style\".asDynamic().unsafeCast<RequestType>()\n\npublic inline val RequestType.Companion.TRACK: RequestType get() = \"track\".asDynamic().unsafeCast<RequestType>()\n\npublic inline val RequestType.Companion.VIDEO: RequestType get() = \"video\".asDynamic().unsafeCast<RequestType>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface RequestDestination {\n    companion object\n}\n\npublic inline val RequestDestination.Companion.EMPTY: RequestDestination get() = \"\".asDynamic().unsafeCast<RequestDestination>()\n\npublic inline val RequestDestination.Companion.DOCUMENT: RequestDestination get() = \"document\".asDynamic().unsafeCast<RequestDestination>()\n\npublic inline val RequestDestination.Companion.EMBED: RequestDestination get() = \"embed\".asDynamic().unsafeCast<RequestDestination>()\n\npublic inline val RequestDestination.Companion.FONT: RequestDestination get() = \"font\".asDynamic().unsafeCast<RequestDestination>()\n\npublic inline val RequestDestination.Companion.IMAGE: RequestDestination get() = \"image\".asDynamic().unsafeCast<RequestDestination>()\n\npublic inline val RequestDestination.Companion.MANIFEST: RequestDestination get() = \"manifest\".asDynamic().unsafeCast<RequestDestination>()\n\npublic inline val RequestDestination.Companion.MEDIA: RequestDestination get() = \"media\".asDynamic().unsafeCast<RequestDestination>()\n\npublic inline val RequestDestination.Companion.OBJECT: RequestDestination get() = \"object\".asDynamic().unsafeCast<RequestDestination>()\n\npublic inline val RequestDestination.Companion.REPORT: RequestDestination get() = \"report\".asDynamic().unsafeCast<RequestDestination>()\n\npublic inline val RequestDestination.Companion.SCRIPT: RequestDestination get() = \"script\".asDynamic().unsafeCast<RequestDestination>()\n\npublic inline val RequestDestination.Companion.SERVICEWORKER: RequestDestination get() = \"serviceworker\".asDynamic().unsafeCast<RequestDestination>()\n\npublic inline val RequestDestination.Companion.SHAREDWORKER: RequestDestination get() = \"sharedworker\".asDynamic().unsafeCast<RequestDestination>()\n\npublic inline val RequestDestination.Companion.STYLE: RequestDestination get() = \"style\".asDynamic().unsafeCast<RequestDestination>()\n\npublic inline val RequestDestination.Companion.WORKER: RequestDestination get() = \"worker\".asDynamic().unsafeCast<RequestDestination>()\n\npublic inline val RequestDestination.Companion.XSLT: RequestDestination get() = \"xslt\".asDynamic().unsafeCast<RequestDestination>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface RequestMode {\n    companion object\n}\n\npublic inline val RequestMode.Companion.NAVIGATE: RequestMode get() = \"navigate\".asDynamic().unsafeCast<RequestMode>()\n\npublic inline val RequestMode.Companion.SAME_ORIGIN: RequestMode get() = \"same-origin\".asDynamic().unsafeCast<RequestMode>()\n\npublic inline val RequestMode.Companion.NO_CORS: RequestMode get() = \"no-cors\".asDynamic().unsafeCast<RequestMode>()\n\npublic inline val RequestMode.Companion.CORS: RequestMode get() = \"cors\".asDynamic().unsafeCast<RequestMode>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface RequestCredentials {\n    companion object\n}\n\npublic inline val RequestCredentials.Companion.OMIT: RequestCredentials get() = \"omit\".asDynamic().unsafeCast<RequestCredentials>()\n\npublic inline val RequestCredentials.Companion.SAME_ORIGIN: RequestCredentials get() = \"same-origin\".asDynamic().unsafeCast<RequestCredentials>()\n\npublic inline val RequestCredentials.Companion.INCLUDE: RequestCredentials get() = \"include\".asDynamic().unsafeCast<RequestCredentials>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface RequestCache {\n    companion object\n}\n\npublic inline val RequestCache.Companion.DEFAULT: RequestCache get() = \"default\".asDynamic().unsafeCast<RequestCache>()\n\npublic inline val RequestCache.Companion.NO_STORE: RequestCache get() = \"no-store\".asDynamic().unsafeCast<RequestCache>()\n\npublic inline val RequestCache.Companion.RELOAD: RequestCache get() = \"reload\".asDynamic().unsafeCast<RequestCache>()\n\npublic inline val RequestCache.Companion.NO_CACHE: RequestCache get() = \"no-cache\".asDynamic().unsafeCast<RequestCache>()\n\npublic inline val RequestCache.Companion.FORCE_CACHE: RequestCache get() = \"force-cache\".asDynamic().unsafeCast<RequestCache>()\n\npublic inline val RequestCache.Companion.ONLY_IF_CACHED: RequestCache get() = \"only-if-cached\".asDynamic().unsafeCast<RequestCache>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface RequestRedirect {\n    companion object\n}\n\npublic inline val RequestRedirect.Companion.FOLLOW: RequestRedirect get() = \"follow\".asDynamic().unsafeCast<RequestRedirect>()\n\npublic inline val RequestRedirect.Companion.ERROR: RequestRedirect get() = \"error\".asDynamic().unsafeCast<RequestRedirect>()\n\npublic inline val RequestRedirect.Companion.MANUAL: RequestRedirect get() = \"manual\".asDynamic().unsafeCast<RequestRedirect>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface ResponseType {\n    companion object\n}\n\npublic inline val ResponseType.Companion.BASIC: ResponseType get() = \"basic\".asDynamic().unsafeCast<ResponseType>()\n\npublic inline val ResponseType.Companion.CORS: ResponseType get() = \"cors\".asDynamic().unsafeCast<ResponseType>()\n\npublic inline val ResponseType.Companion.DEFAULT: ResponseType get() = \"default\".asDynamic().unsafeCast<ResponseType>()\n\npublic inline val ResponseType.Companion.ERROR: ResponseType get() = \"error\".asDynamic().unsafeCast<ResponseType>()\n\npublic inline val ResponseType.Companion.OPAQUE: ResponseType get() = \"opaque\".asDynamic().unsafeCast<ResponseType>()\n\npublic inline val ResponseType.Companion.OPAQUEREDIRECT: ResponseType get() = \"opaqueredirect\".asDynamic().unsafeCast<ResponseType>()","package io.github.kgpu\n\nimport io.github.kgpu.internal.GlslangLibrary\nimport kotlinx.coroutines.await\nimport org.khronos.webgl.ArrayBuffer\nimport org.khronos.webgl.Int8Array\nimport org.khronos.webgl.Uint32Array\nimport org.khronos.webgl.Uint8Array\nimport org.w3c.dom.HTMLCanvasElement\nimport kotlin.js.Promise\nimport kotlin.browser.document as jsDocument\nimport kotlin.browser.window as jsWindow\n\nactual object Kgpu {\n    actual val backendName: String = \"Web\"\n    actual val undefined = kotlin.js.undefined\n\n    actual fun init() {\n        GlslangLibrary.init()\n    }\n\n    actual fun runLoop(window: Window, func: () -> Unit) {\n        func();\n\n        jsWindow.requestAnimationFrame {\n            runLoop(window, func)\n        };\n    }\n\n}\n\nactual class Window actual constructor() {\n\n    private val canvas = kotlin.browser.document.getElementById(\"kgpuCanvas\") as HTMLCanvasElement\n    private val context = canvas.getContext(\"gpupresent\")\n    private var canvasHackRan = false\n\n    actual fun setTitle(title: String) {\n        jsDocument.title = title\n    }\n\n    actual fun isCloseRequested(): Boolean {\n        return false\n    }\n\n    actual fun update() {\n\n    }\n\n    actual suspend fun requestAdapterAsync(preference: PowerPreference): Adapter {\n        return Adapter((js(\"navigator.gpu.requestAdapter()\") as Promise<GPUAdapter>).await())\n    }\n\n    actual fun getWindowSize(): WindowSize {\n        return WindowSize(canvas.width, canvas.height)\n    }\n\n    actual fun configureSwapChain(desc: SwapChainDescriptor): SwapChain {\n        if (!canvasHackRan) {\n            canvas.width += 1 //Hack to get around chromium not showing canvas unless clicked/resized\n            canvasHackRan = true\n        }\n\n        return SwapChain(context.asDynamic().configureSwapChain(desc) as GPUSwapChain)\n    }\n}\n\nopen external class GPUObjectBase {\n    val label: String\n}\n\nopen external class GPUObjectDescriptorBase {\n    val label: String\n}\n\n\nactual class Adapter(val jsType: GPUAdapter) {\n\n    actual suspend fun requestDeviceAsync(): Device {\n        return Device(jsType.requestDevice().await())\n    }\n\n    override fun toString(): String {\n        return \"Adapter($jsType)\"\n    }\n\n}\n\nopen external class GPUAdapter {\n    val name: String\n    val extensions: List<GPUExtensionName>\n\n    fun requestDevice(): Promise<GPUDevice>\n}\n\n/**\n * Eventually will be external once implemented in browsers\n */\nenum class GPUExtensionName {\n    TextureCompressionBC,\n    PipelineStatisticsQuery,\n    TimestampQuery,\n    DepthClamping\n}\n\nactual enum class PowerPreference(jsType: GPUPowerPreference?) {\n    LOW_POWER(GPUPowerPreference.LOW_POWER),\n    DEFAULT(null),\n    HIGH_PERFORMANCE(GPUPowerPreference.HIGH_PERFORMANCE)\n}\n\n/**\n * Eventually will be external once implemented in browsers\n */\nenum class GPUPowerPreference {\n    LOW_POWER, HIGH_PERFORMANCE\n}\n\nactual class Device(val jsType: GPUDevice) {\n\n    override fun toString(): String {\n        return \"Device($jsType)\"\n    }\n\n    actual fun createShaderModule(data: ByteArray): ShaderModule {\n        val desc = asDynamic()\n        val bytes = Int8Array(data.toTypedArray())\n        desc.code = Uint32Array(bytes.buffer, 0, data.size / 4)\n\n        return jsType.createShaderModule(desc)\n    }\n\n    actual fun createRenderPipeline(desc: RenderPipelineDescriptor): RenderPipeline {\n        return jsType.createRenderPipeline(desc)\n    }\n\n    actual fun createPipelineLayout(desc: PipelineLayoutDescriptor): PipelineLayout {\n        return jsType.createPipelineLayout(desc)\n    }\n\n    actual fun createTexture(desc: TextureDescriptor): Texture {\n        return Texture(jsType.createTexture(desc))\n    }\n\n    actual fun createCommandEncoder(): CommandEncoder {\n        return CommandEncoder(jsType.createCommandEncoder())\n    }\n\n    actual fun getDefaultQueue(): Queue {\n        val queue = jsType.asDynamic().defaultQueue as GPUQueue;\n\n        return Queue(queue)\n    }\n\n    actual fun createBuffer(desc: BufferDescriptor): Buffer {\n        return Buffer(jsType.createBuffer(desc), desc.size)\n    }\n\n    actual fun createBindGroupLayout(desc: BindGroupLayoutDescriptor): BindGroupLayout {\n        return BindGroupLayout(jsType.createBindGroupLayout(desc))\n    }\n\n    actual fun createBufferWithData(desc: BufferDescriptor, data: ByteArray): Buffer {\n        val values = jsType.createBufferMapped(desc)\n        val buffer = values[0] as GPUBuffer\n        val mapping = Int8Array(values[1] as ArrayBuffer)\n        mapping.set(data.toTypedArray(), 0)\n        buffer.unmap()\n\n        return Buffer(buffer, desc.size)\n    }\n\n    actual fun createBindGroup(desc: BindGroupDescriptor): BindGroup {\n        return BindGroup(jsType.createBindGroup(desc))\n    }\n\n}\n\nexternal class GPUDevice {\n    val adapter: GPUAdapter\n    val extensions: List<GPUExtensionName>\n    val limits: Any\n    val defaultQueue: Any\n\n    fun createShaderModule(desc: dynamic): GPUShaderModule\n\n    fun createPipelineLayout(desc: PipelineLayoutDescriptor): GPUPipelineLayout\n\n    fun createRenderPipeline(desc: RenderPipelineDescriptor): RenderPipeline\n\n    fun createTexture(desc: TextureDescriptor): GPUTexture\n\n    fun createCommandEncoder(): GPUCommandEncoder\n\n    fun createBuffer(desc: BufferDescriptor): GPUBuffer\n\n    fun createBindGroupLayout(desc: BindGroupLayoutDescriptor): GPUBindGroupLayout\n\n    @Deprecated(message = \"No longer part of the spec, but replacement has not been implemented in browsers!\")\n    fun createBufferMapped(desc: BufferDescriptor): Array<dynamic>\n\n    fun createBindGroup(desc: BindGroupDescriptor): GPUBindGroup\n}\n\nactual class CommandEncoder(val jsType: GPUCommandEncoder) {\n\n    actual fun beginRenderPass(desc: RenderPassDescriptor): RenderPassEncoder {\n        return RenderPassEncoder(jsType.beginRenderPass(desc))\n    }\n\n    actual fun finish(): CommandBuffer {\n        return CommandBuffer(jsType.finish())\n    }\n\n}\n\nexternal class GPUCommandEncoder {\n\n    fun beginRenderPass(desc: RenderPassDescriptor): GPURenderPassEncoder\n\n    fun finish(): GPUCommandBuffer\n\n}\n\nactual class RenderPassEncoder(val jsType: GPURenderPassEncoder) {\n    actual fun setPipeline(pipeline: RenderPipeline) {\n        jsType.setPipeline(pipeline)\n    }\n\n    actual fun draw(vertexCount: Int, instanceCount: Int, firstVertex: Int, firstInstance: Int) {\n        jsType.draw(vertexCount, instanceCount, firstVertex, firstInstance)\n    }\n\n    actual fun endPass() {\n        jsType.endPass()\n    }\n\n    actual fun setVertexBuffer(slot: Long, buffer: Buffer, offset: Long, size: Long) {\n        jsType.setVertexBuffer(slot, buffer.jsType, offset, size)\n    }\n\n    actual fun drawIndexed(indexCount: Int, instanceCount: Int, firstVertex: Int, baseVertex: Int, firstInstance: Int) {\n        jsType.drawIndexed(indexCount, instanceCount, firstVertex, baseVertex, firstInstance)\n    }\n\n    actual fun setIndexBuffer(buffer: Buffer, offset: Long, size: Long) {\n        jsType.setIndexBuffer(buffer.jsType, offset, size)\n    }\n\n    actual fun setBindGroup(index: Int, bindGroup: BindGroup) {\n        jsType.setBindGroup(0, bindGroup.jsType)\n    }\n}\n\nexternal class GPURenderPassEncoder {\n    fun setPipeline(pipeline: RenderPipeline)\n\n    fun draw(vertexCount: Int, instanceCount: Int, firstVertex: Int, firstInstance: Int)\n\n    fun endPass()\n\n    fun setVertexBuffer(slot: Long, buffer: GPUBuffer, offset: Long, size: Long)\n\n    fun drawIndexed(indexCount: Int, instanceCount: Int, firstVertex: Int, baseVertex: Int, firstInstance: Int)\n\n    fun setIndexBuffer(buffer: GPUBuffer, offset: Long, size: Long)\n\n    fun setBindGroup(index: Int, bindGroup: GPUBindGroup)\n}\n\nactual class Texture(val jsType: GPUTexture) {\n\n    actual fun createView(desc: TextureViewDescriptor?): TextureView {\n        return TextureView(jsType.createView(desc))\n    }\n\n}\n\nexternal class GPUTexture {\n\n    fun createView(desc: TextureViewDescriptor?): GPUTextureView\n\n}\n\nexternal class GPUShaderModule : GPUObjectBase {\n    val compilationInfo: Any\n}\nactual typealias ShaderModule = GPUShaderModule\n\nactual class ProgrammableStageDescriptor actual constructor(\n    val module: ShaderModule,\n    val entryPoint: String\n)\n\nactual enum class PrimitiveTopology(val jsType: GPUPrimitiveTopology = GPUPrimitiveTopology._NotImplemented) {\n    POINT_LIST,\n    LINE_LIST,\n    LINE_STRIP,\n    TRIANGLE_LIST(GPUPrimitiveTopology.triangle_list),\n    TRIANGLE_STRIP,\n}\n\nenum class GPUPrimitiveTopology {\n    point_list,\n    line_list,\n    line_strip,\n    triangle_list,\n    triangle_strip,\n    _NotImplemented\n}\n\nactual enum class FrontFace(val jsType: String) {\n    CCW(\"ccw\"),\n    CW(\"cw\"),\n}\n\nactual enum class CullMode(val jsType: String) {\n    NONE(\"none\"),\n    FRONT(\"front\"),\n    BACK(\"back\"),\n}\n\nactual class RasterizationStateDescriptor actual constructor(\n    frontFace: FrontFace,\n    cullMode: CullMode,\n    val clampDepth: Boolean,\n    val depthBias: Long,\n    val depthBiasSlopeScale: Float,\n    val depthBiasClamp: Float\n) {\n\n    val frontFace = frontFace.jsType\n    val cullMode = cullMode.jsType\n}\n\nactual class BlendDescriptor actual constructor(\n    srcFactor: BlendFactor,\n    dstFactor: BlendFactor,\n    operation: BlendOperation\n) {\n\n    val operation = operation.jsType\n    val srcFactor = srcFactor.jsType\n    val dstFactor = dstFactor.jsType\n}\n\nactual class ColorStateDescriptor actual constructor(\n    format: TextureFormat,\n    val alphaBlend: BlendDescriptor,\n    val colorBlend: BlendDescriptor,\n    val writeMask: Long\n) {\n\n    val format = format.jsType\n}\n\nactual class RenderPipelineDescriptor actual constructor(\n    val layout: PipelineLayout,\n    val vertexStage: ProgrammableStageDescriptor,\n    val fragmentStage: ProgrammableStageDescriptor,\n    primitiveTopology: PrimitiveTopology,\n    val rasterizationState: RasterizationStateDescriptor,\n    val colorStates: Array<ColorStateDescriptor>,\n    val depthStencilState: Any?,\n    val vertexState: VertexStateDescriptor,\n    val sampleCount: Int,\n    val sampleMask: Long,\n    val alphaToCoverage: Boolean\n) {\n\n    val primitiveTopology = \"triangle-list\"\n}\n\nactual class VertexAttributeDescriptor actual constructor(\n    format: VertexFormat,\n    val offset: Long,\n    val shaderLocation: Int\n) {\n    val format = format.jsType\n}\n\nactual class VertexBufferLayoutDescriptor actual constructor(\n    val arrayStride: Long,\n    stepMode: InputStepMode,\n    vararg val attributes: VertexAttributeDescriptor\n) {\n    val stepMode = stepMode.jsType\n}\n\nactual class VertexStateDescriptor actual constructor(\n    indexFormat: IndexFormat,\n    vararg val vertexBuffers: VertexBufferLayoutDescriptor\n) {\n\n    val indexFormat = indexFormat.jsType\n}\n\nactual class BindGroupLayoutEntry actual constructor(\n    val binding: Long,\n    val visibility: Long,\n    type: BindingType\n) {\n    val type = type.jsType\n}\n\nactual class BindGroupLayout(val jsType: GPUBindGroupLayout) {\n\n}\n\nexternal class GPUBindGroupLayout {\n\n}\n\nactual class PipelineLayoutDescriptor actual constructor(vararg bindGroupLayouts: BindGroupLayout) {\n    val bindGroupLayouts = bindGroupLayouts.map { it.jsType }.toTypedArray()\n}\n\nexternal class GPUPipelineLayout\nactual typealias PipelineLayout = GPUPipelineLayout\n\nactual class RenderPipeline\n\nactual enum class InputStepMode(val jsType: String) {\n    VERTEX(\"vertex\"),\n    INSTANCE(\"instance\"),\n}\n\nactual class Extent3D actual constructor(\n    val width: Long,\n    val height: Long,\n    val depth: Long\n)\n\nactual enum class TextureDimension(val jsType: String) {\n    D1(\"1d\"),\n    D2(\"2d\"),\n    D3(\"3d\")\n}\n\nactual class TextureDescriptor actual constructor(\n    val size: Extent3D,\n    val mipLevelCount: Long,\n    val sampleCount: Int,\n    dimension: TextureDimension,\n    format: TextureFormat,\n    val textureUsage: Long\n) {\n\n    val dimension = dimension.jsType\n    val format = format.jsType\n}\n\nactual class TextureViewDescriptor actual constructor(\n    format: TextureFormat,\n    dimension: TextureViewDimension,\n    aspect: TextureAspect,\n    val baseMipLevel: Long,\n    val mipLevelCount: Long,\n    val baseArrayLayer: Long,\n    val arrayLayerCount: Long\n) {\n\n    val format = format.jsType\n    val dimension = dimension.jsType\n    val aspect = aspect.jsType\n}\n\nactual class TextureView(val jsType: GPUTextureView)\nexternal class GPUTextureView\n\nactual class SwapChain(val jsType: GPUSwapChain) {\n\n    actual fun getCurrentTextureView(): TextureView {\n        val texture = Texture(jsType.getCurrentTexture())\n\n        return texture.createView(undefined)\n    }\n\n    actual fun present() {\n        //Not needed on WebGPU\n    }\n\n    actual fun isOutOfDate(): Boolean {\n        return false\n    }\n}\n\nexternal class GPUSwapChain {\n    fun getCurrentTexture(): GPUTexture\n}\n\nactual class SwapChainDescriptor actual constructor(\n    device: Device,\n    format: TextureFormat,\n    val usage: Long\n) {\n    val device = device.jsType\n    val format = format.jsType\n}\n\nactual class RenderPassColorAttachmentDescriptor actual constructor(\n    attachment: TextureView,\n    clearColor: Color?,\n    storeOp: StoreOp\n) {\n    val attachment = attachment.jsType\n    val storeOp = storeOp.jsType\n    val loadValue = clearColor ?: LoadOp.LOAD\n}\n\nactual class RenderPassDescriptor actual constructor(\n    vararg val colorAttachments: RenderPassColorAttachmentDescriptor\n)\n\nactual class CommandBuffer(val jsType: GPUCommandBuffer)\nexternal class GPUCommandBuffer\n\nactual class Queue(val jsType: GPUQueue) {\n\n    actual fun submit(vararg cmdBuffers: CommandBuffer) {\n        jsType.submit(cmdBuffers.map { it.jsType }.toTypedArray())\n    }\n\n    actual fun writeBuffer(buffer: Buffer, data: ByteArray, offset: Long, dataOffset: Long, size: Long) {\n        val arrayBuffer = ArrayBuffer(data.size)\n        Uint8Array(arrayBuffer).set(data.toTypedArray())\n\n        jsType.writeBuffer(buffer.jsType, offset, arrayBuffer, dataOffset, size)\n    }\n}\n\nexternal class GPUQueue {\n\n    fun submit(cmdBuffers: Array<GPUCommandBuffer>)\n\n    fun writeBuffer(buffer: GPUBuffer, offset: Long, data: ArrayBuffer, dataOffset: Long, size: Long)\n}\n\nactual class BufferDescriptor actual constructor(\n    val size: Long,\n    val usage: Long,\n    val mappedAtCreation: Boolean\n)\n\nactual class Buffer(val jsType: GPUBuffer, actual val size: Long) : IntoBindingResource {\n\n    actual fun getMappedData(start: Long, size: Long): BufferData {\n        val data = jsType.getMappedRange(start, size)\n\n        TODO(\"Not implemented in browsers yet. Use old function Device.createBufferWithData() instead\")\n//        return BufferData(Uint8Array(data))\n    }\n\n    actual fun unmap() {\n        jsType.unmap()\n    }\n\n    override fun intoBindingResource(): dynamic {\n        val binding = asDynamic()\n        binding.buffer = jsType\n        binding.offset = 0\n        binding.size = size\n\n        return binding\n    }\n\n}\n\nexternal class GPUBuffer {\n\n    fun getMappedRange(start: Long, size: Long): ArrayBuffer\n\n    fun unmap();\n}\n\n\nactual class BufferData(val data: Uint8Array) {\n\n    actual fun putBytes(bytes: ByteArray, offset: Int) {\n        data.set(bytes.toTypedArray(), offset)\n    }\n\n}\n\nactual class BindGroupLayoutDescriptor actual constructor(vararg val entries: BindGroupLayoutEntry) {\n}\n\nactual class BindGroupEntry actual constructor(val binding: Long, resource: IntoBindingResource) {\n\n    val resource = resource.intoBindingResource()\n\n}\n\nactual class BindGroupDescriptor actual constructor(\n    layout: BindGroupLayout,\n    vararg val entries: BindGroupEntry\n) {\n    val layout = layout.jsType\n}\n\nactual class BindGroup(val jsType: GPUBindGroup)\n\nexternal class GPUBindGroup\n\nactual interface IntoBindingResource {\n\n    fun intoBindingResource(): dynamic\n\n}\n\nactual enum class TextureFormat(val jsType: String = \"\") {\n    R8_UNORM,\n    R8_SNORM,\n    R8_UINT,\n    R8_SINT,\n    R16_UINT,\n    R16_SINT,\n    R16_FLOAT,\n    RG8_UNORM,\n    RG8_SNORM,\n    RG8_UINT,\n    RG8_SINT,\n    R32_UINT,\n    R32_SINT,\n    R32_FLOAT,\n    RG16_UINT,\n    RG16_SINT,\n    RG16_FLOAT,\n    RGBA8_UNORM,\n    RGBA8_UNORM_SRGB,\n    RGBA8_SNORM,\n    RGBA8_UINT,\n    RGBA8_SINT,\n    BGRA8_UNORM(\"bgra8unorm\"),\n    BGRA8_UNORM_SRGB,\n    RGB10A2_UNORM,\n    RG11B10_FLOAT,\n    RG32_UINT,\n    RG32_SINT,\n    RG32_FLOAT,\n    RGBA16_UINT,\n    RGBA16_SINT,\n    RGBA16_FLOAT,\n    RGBA32_UINT,\n    RGBA32_SINT,\n    RGBA32_FLOAT,\n    DEPTH32_FLOAT,\n    DEPTH24_PLUS,\n    DEPTH24_PLUS_STENCIL8,\n}\n\nactual enum class BlendOperation(val jsType: String = \"\") {\n    ADD(\"add\"),\n    SUBTRACT,\n    REVERSE_SUBTRACT,\n    MIN,\n    MAX,\n}\n\nactual enum class StencilOperation {\n    KEEP,\n    ZERO,\n    REPLACE,\n    INVERT,\n    INCREMENT_CLAMP,\n    DECREMENT_CLAMP,\n    INCREMENT_WRAP,\n    DECREMENT_WRAP,\n}\n\nactual enum class BlendFactor(val jsType: String = \"\") {\n    ZERO(\"zero\"),\n    ONE(\"one\"),\n    SRC_COLOR,\n    ONE_MINUS_SRC_COLOR,\n    SRC_ALPHA,\n    ONE_MINUS_SRC_ALPHA,\n    DST_COLOR,\n    ONE_MINUS_DST_COLOR,\n    DST_ALPHA,\n    ONE_MINUS_DST_ALPHA,\n    SRC_ALPHA_SATURATED,\n    BLEND_COLOR,\n    ONE_MINUS_BLEND_COLOR,\n}\n\nactual enum class IndexFormat(val jsType: String) {\n    UINT16(\"uint16\"),\n    UINT32(\"uint32\"),\n}\n\nactual enum class VertexFormat(val jsType: String) {\n    UCHAR2(\"uchar2\"),\n    UCHAR4(\"uchar4\"),\n    CHAR2(\"char2\"),\n    CHAR4(\"char4\"),\n    UCHAR2_NORM(\"uchar2norm\"),\n    UCHAR4_NORM(\"uchar4norm\"),\n    CHAR2_NORM(\"char2norm\"),\n    CHAR4_NORM(\"char4norm\"),\n    USHORT2(\"ushort2\"),\n    USHORT4(\"ushort4\"),\n    SHORT2(\"short2\"),\n    SHORT4(\"short4\"),\n    USHORT2_NORM(\"ushort2norm\"),\n    USHORT4_NORM(\"ushort4norm\"),\n    SHORT2_NORM(\"short2norm\"),\n    SHORT4_NORM(\"short4norm\"),\n    HALF2(\"half2\"),\n    HALF4(\"half4\"),\n    FLOAT(\"float\"),\n    FLOAT2(\"float2\"),\n    FLOAT3(\"float3\"),\n    FLOAT4(\"float4\"),\n    UINT(\"uint\"),\n    UINT2(\"uint2\"),\n    UINT3(\"uint3\"),\n    UINT4(\"uint4\"),\n    INT(\"int\"),\n    INT2(\"int2\"),\n    INT3(\"int3\"),\n    INT4(\"int4\"),\n}\n\nactual enum class TextureAspect(val jsType: String) {\n    ALL(\"all\"),\n    STENCIL_ONLY(\"stencil-only\"),\n    DEPTH_ONLY(\"depth-only\"),\n}\n\nactual enum class TextureViewDimension(val jsType: String) {\n    D1(\"1d\"),\n    D2(\"2d\"),\n    D2_ARRAY(\"2d-array\"),\n    CUBE(\"cube\"),\n    CUBE_ARRAY(\"cube-array\"),\n    D3(\"3d\"),\n}\n\nactual enum class LoadOp(val jsType: String) {\n    CLEAR(\"clear\"),\n    LOAD(\"load\"),\n}\n\nactual enum class StoreOp(val jsType: String) {\n    CLEAR(\"clear\"),\n    STORE(\"store\"),\n}\n\nactual enum class BindingType(val jsType: String) {\n    UNIFORM_BUFFER(\"uniform-buffer\"),\n    STORAGE_BUFFER(\"storage-buffer\"),\n    READONLY_STORAGE_BUFFER(\"readonly-storage-buffer\"),\n    SAMPLER(\"sampler\"),\n    COMPARISON_SAMPLER(\"comparison-sampler\"),\n    SAMPLED_TEXTURE(\"sampled-texture\"),\n    READONLY_STORAGE_TEXTURE(\"readonly-storage-texture\"),\n    WRITEONLY_STORAGE_TEXTURE(\"writeonly-storage-texture\"),\n}","package io.github.kgpu\n\nimport io.github.kgpu.internal.mat4\nimport io.github.kgpu.internal.vec3\nimport org.khronos.webgl.Float32Array\nimport org.khronos.webgl.get\n\nactual class Matrix4f actual constructor(){\n    val mat = mat4.create()\n\n    actual fun translate(x: Float, y: Float, z: Float): Matrix4f {\n        val xyz = vec3.fromValues(x, y, z)\n        mat4.translate(mat, mat, xyz)\n\n        return this\n    }\n\n    @Suppress(\"CAST_NEVER_SUCCEEDS\")\n    actual fun toFloats(): FloatArray {\n        val out = FloatArray(16)\n        val mat = mat as Float32Array\n\n        for(i in 0..16){\n            out[i] = mat[i]\n        }\n\n        return out\n    }\n\n    actual fun toBytes(): ByteArray {\n        return ByteUtils.toByteArray(toFloats())\n    }\n\n    actual fun ortho(left: Float, right: Float, bottom: Float, top: Float, near: Float, far: Float): Matrix4f {\n        mat4.ortho(mat, left, right, bottom, top, near, far)\n\n        return this\n    }\n\n    actual fun lookAt(eye: Vec3f, center: Vec3f, up: Vec3f): Matrix4f {\n        mat4.lookAt(mat, eye.vec, center.vec, up.vec)\n\n        return this\n    }\n\n    actual fun mul(other: Matrix4f): Matrix4f {\n        mat4.mul(mat, mat, other.mat)\n\n        return this\n    }\n\n    actual fun perspective(fov: Float, aspect: Float, near: Float, far: Float): Matrix4f {\n        mat4.perspective(mat, fov, aspect, near, far)\n\n        return this\n    }\n\n    actual fun rotateX(angle: Float): Matrix4f {\n        mat4.rotateX(mat, mat, angle)\n\n        return this\n    }\n\n    actual fun rotateY(angle: Float): Matrix4f {\n        mat4.rotateY(mat, mat, angle)\n\n        return this\n    }\n\n    actual fun rotateZ(angle: Float): Matrix4f {\n        mat4.rotateZ(mat, mat, angle)\n\n        return this\n    }\n}\n\nactual class Vec3f actual constructor(x: Float, y: Float, z: Float){\n    val vec = vec3.fromValues(x, y, z)\n\n    actual constructor() : this(0f, 0f, 0f)\n\n}","package io.github.kgpu\n\nimport io.github.kgpu.internal.ArrayBufferUtils\nimport io.github.kgpu.internal.GlslangLibrary\n\nactual object ShaderCompiler {\n\n    actual suspend fun compile(name: String, source: String, stage: ShaderType): ByteArray {\n        val glslang = GlslangLibrary.getGlslang()\n        val data = glslang.compileGLSL(source, stage.jsType, false)\n\n        return ArrayBufferUtils.toByteArray(data.buffer)\n    }\n\n}\n\nactual enum class ShaderType(val jsType: String){\n    VERTEX(\"vertex\"), FRAGMENT(\"fragment\"), COMPUTE(\"compute\")\n}","package io.github.kgpu.internal\n\nimport org.khronos.webgl.ArrayBuffer\nimport org.khronos.webgl.Uint8Array\nimport org.khronos.webgl.get\n\n\nobject ArrayBufferUtils {\n\n    fun toByteArray(buffer: ArrayBuffer) : ByteArray{\n        val bytes = Uint8Array(buffer)\n        val output = ByteArray(bytes.length);\n\n        for(i : Int in 0..bytes.length){\n            output[i] = bytes[i];\n        }\n\n        return output\n    }\n\n}","package io.github.kgpu.internal\n\nimport io.github.kgpu.ShaderType\nimport kotlinx.coroutines.await\nimport org.khronos.webgl.Uint32Array\nimport kotlin.browser.document\nimport kotlin.js.Promise\n\nprivate const val glslangGlobalVariable = \"window.test\"\nprivate const val glslangUrl = \"https://cdn.jsdelivr.net/npm/@webgpu/glslang@0.0.15/dist/web-devel/glslang.js\"\nprivate const val scriptSrc = \"\"\"\n    import * as glslang from '$glslangUrl'\n\n    $glslangGlobalVariable = glslang.default()\n    console.log(\"Setup glslang: \", $glslangGlobalVariable)\n\"\"\"\n\ninternal object GlslangLibrary{\n\n    fun init(){\n        val script = document.createElement(\"script\")\n        script.id = \"kgpu_internal_glslang\"\n        script.setAttribute(\"type\", \"module\")\n        script.innerHTML = scriptSrc\n\n        document.body?.append(script)\n    }\n\n    suspend fun getGlslang() : Glslang{\n        return (js(glslangGlobalVariable) as Promise<Glslang>).await()\n    }\n}\n\ninternal external class Glslang{\n\n    fun compileGLSL(glsl: String, shaderType: String, debug: Boolean) : Uint32Array\n\n}","/**\r\n * Common utilities\r\n * @module glMatrix\r\n */\n// Configuration Constants\nexport var EPSILON = 0.000001;\nexport var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;\nexport var RANDOM = Math.random;\n/**\r\n * Sets the type of array used when creating new vectors and matrices\r\n *\r\n * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array\r\n */\n\nexport function setMatrixArrayType(type) {\n  ARRAY_TYPE = type;\n}\nvar degree = Math.PI / 180;\n/**\r\n * Convert Degree To Radian\r\n *\r\n * @param {Number} a Angle in Degrees\r\n */\n\nexport function toRadian(a) {\n  return a * degree;\n}\n/**\r\n * Tests whether or not the arguments have approximately the same value, within an absolute\r\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\r\n * than or equal to 1.0, and a relative tolerance is used for larger values)\r\n *\r\n * @param {Number} a The first number to test.\r\n * @param {Number} b The second number to test.\r\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\r\n */\n\nexport function equals(a, b) {\n  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n}\nif (!Math.hypot) Math.hypot = function () {\n  var y = 0,\n      i = arguments.length;\n\n  while (i--) {\n    y += arguments[i] * arguments[i];\n  }\n\n  return Math.sqrt(y);\n};","import * as glMatrix from \"./common.js\";\n/**\r\n * 2x2 Matrix\r\n * @module mat2\r\n */\n\n/**\r\n * Creates a new identity mat2\r\n *\r\n * @returns {mat2} a new 2x2 matrix\r\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(4);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  out[0] = 1;\n  out[3] = 1;\n  return out;\n}\n/**\r\n * Creates a new mat2 initialized with values from an existing matrix\r\n *\r\n * @param {ReadonlyMat2} a matrix to clone\r\n * @returns {mat2} a new 2x2 matrix\r\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\r\n * Copy the values from one mat2 to another\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {ReadonlyMat2} a the source matrix\r\n * @returns {mat2} out\r\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\r\n * Set a mat2 to the identity matrix\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @returns {mat2} out\r\n */\n\nexport function identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  return out;\n}\n/**\r\n * Create a new mat2 with the given values\r\n *\r\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\r\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\r\n * @param {Number} m10 Component in column 1, row 0 position (index 2)\r\n * @param {Number} m11 Component in column 1, row 1 position (index 3)\r\n * @returns {mat2} out A new 2x2 matrix\r\n */\n\nexport function fromValues(m00, m01, m10, m11) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m10;\n  out[3] = m11;\n  return out;\n}\n/**\r\n * Set the components of a mat2 to the given values\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\r\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\r\n * @param {Number} m10 Component in column 1, row 0 position (index 2)\r\n * @param {Number} m11 Component in column 1, row 1 position (index 3)\r\n * @returns {mat2} out\r\n */\n\nexport function set(out, m00, m01, m10, m11) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m10;\n  out[3] = m11;\n  return out;\n}\n/**\r\n * Transpose the values of a mat2\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {ReadonlyMat2} a the source matrix\r\n * @returns {mat2} out\r\n */\n\nexport function transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache\n  // some values\n  if (out === a) {\n    var a1 = a[1];\n    out[1] = a[2];\n    out[2] = a1;\n  } else {\n    out[0] = a[0];\n    out[1] = a[2];\n    out[2] = a[1];\n    out[3] = a[3];\n  }\n\n  return out;\n}\n/**\r\n * Inverts a mat2\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {ReadonlyMat2} a the source matrix\r\n * @returns {mat2} out\r\n */\n\nexport function invert(out, a) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3]; // Calculate the determinant\n\n  var det = a0 * a3 - a2 * a1;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = a3 * det;\n  out[1] = -a1 * det;\n  out[2] = -a2 * det;\n  out[3] = a0 * det;\n  return out;\n}\n/**\r\n * Calculates the adjugate of a mat2\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {ReadonlyMat2} a the source matrix\r\n * @returns {mat2} out\r\n */\n\nexport function adjoint(out, a) {\n  // Caching this value is nessecary if out == a\n  var a0 = a[0];\n  out[0] = a[3];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = a0;\n  return out;\n}\n/**\r\n * Calculates the determinant of a mat2\r\n *\r\n * @param {ReadonlyMat2} a the source matrix\r\n * @returns {Number} determinant of a\r\n */\n\nexport function determinant(a) {\n  return a[0] * a[3] - a[2] * a[1];\n}\n/**\r\n * Multiplies two mat2's\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {ReadonlyMat2} a the first operand\r\n * @param {ReadonlyMat2} b the second operand\r\n * @returns {mat2} out\r\n */\n\nexport function multiply(out, a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  out[0] = a0 * b0 + a2 * b1;\n  out[1] = a1 * b0 + a3 * b1;\n  out[2] = a0 * b2 + a2 * b3;\n  out[3] = a1 * b2 + a3 * b3;\n  return out;\n}\n/**\r\n * Rotates a mat2 by the given angle\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {ReadonlyMat2} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat2} out\r\n */\n\nexport function rotate(out, a, rad) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  out[0] = a0 * c + a2 * s;\n  out[1] = a1 * c + a3 * s;\n  out[2] = a0 * -s + a2 * c;\n  out[3] = a1 * -s + a3 * c;\n  return out;\n}\n/**\r\n * Scales the mat2 by the dimensions in the given vec2\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {ReadonlyMat2} a the matrix to rotate\r\n * @param {ReadonlyVec2} v the vec2 to scale the matrix by\r\n * @returns {mat2} out\r\n **/\n\nexport function scale(out, a, v) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var v0 = v[0],\n      v1 = v[1];\n  out[0] = a0 * v0;\n  out[1] = a1 * v0;\n  out[2] = a2 * v1;\n  out[3] = a3 * v1;\n  return out;\n}\n/**\r\n * Creates a matrix from a given angle\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat2.identity(dest);\r\n *     mat2.rotate(dest, dest, rad);\r\n *\r\n * @param {mat2} out mat2 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat2} out\r\n */\n\nexport function fromRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  out[0] = c;\n  out[1] = s;\n  out[2] = -s;\n  out[3] = c;\n  return out;\n}\n/**\r\n * Creates a matrix from a vector scaling\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat2.identity(dest);\r\n *     mat2.scale(dest, dest, vec);\r\n *\r\n * @param {mat2} out mat2 receiving operation result\r\n * @param {ReadonlyVec2} v Scaling vector\r\n * @returns {mat2} out\r\n */\n\nexport function fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = v[1];\n  return out;\n}\n/**\r\n * Returns a string representation of a mat2\r\n *\r\n * @param {ReadonlyMat2} a matrix to represent as a string\r\n * @returns {String} string representation of the matrix\r\n */\n\nexport function str(a) {\n  return \"mat2(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \")\";\n}\n/**\r\n * Returns Frobenius norm of a mat2\r\n *\r\n * @param {ReadonlyMat2} a the matrix to calculate Frobenius norm of\r\n * @returns {Number} Frobenius norm\r\n */\n\nexport function frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3]);\n}\n/**\r\n * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix\r\n * @param {ReadonlyMat2} L the lower triangular matrix\r\n * @param {ReadonlyMat2} D the diagonal matrix\r\n * @param {ReadonlyMat2} U the upper triangular matrix\r\n * @param {ReadonlyMat2} a the input matrix to factorize\r\n */\n\nexport function LDU(L, D, U, a) {\n  L[2] = a[2] / a[0];\n  U[0] = a[0];\n  U[1] = a[1];\n  U[3] = a[3] - L[2] * U[1];\n  return [L, D, U];\n}\n/**\r\n * Adds two mat2's\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {ReadonlyMat2} a the first operand\r\n * @param {ReadonlyMat2} b the second operand\r\n * @returns {mat2} out\r\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  return out;\n}\n/**\r\n * Subtracts matrix b from matrix a\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {ReadonlyMat2} a the first operand\r\n * @param {ReadonlyMat2} b the second operand\r\n * @returns {mat2} out\r\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  return out;\n}\n/**\r\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {ReadonlyMat2} a The first matrix.\r\n * @param {ReadonlyMat2} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n/**\r\n * Returns whether or not the matrices have approximately the same elements in the same position.\r\n *\r\n * @param {ReadonlyMat2} a The first matrix.\r\n * @param {ReadonlyMat2} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));\n}\n/**\r\n * Multiply each element of the matrix by a scalar.\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {ReadonlyMat2} a the matrix to scale\r\n * @param {Number} b amount to scale the matrix's elements by\r\n * @returns {mat2} out\r\n */\n\nexport function multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  return out;\n}\n/**\r\n * Adds two mat2's after multiplying each element of the second operand by a scalar value.\r\n *\r\n * @param {mat2} out the receiving vector\r\n * @param {ReadonlyMat2} a the first operand\r\n * @param {ReadonlyMat2} b the second operand\r\n * @param {Number} scale the amount to scale b's elements by before adding\r\n * @returns {mat2} out\r\n */\n\nexport function multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  return out;\n}\n/**\r\n * Alias for {@link mat2.multiply}\r\n * @function\r\n */\n\nexport var mul = multiply;\n/**\r\n * Alias for {@link mat2.subtract}\r\n * @function\r\n */\n\nexport var sub = subtract;","import * as glMatrix from \"./common.js\";\n/**\r\n * 2x3 Matrix\r\n * @module mat2d\r\n * @description\r\n * A mat2d contains six elements defined as:\r\n * <pre>\r\n * [a, b,\r\n *  c, d,\r\n *  tx, ty]\r\n * </pre>\r\n * This is a short form for the 3x3 matrix:\r\n * <pre>\r\n * [a, b, 0,\r\n *  c, d, 0,\r\n *  tx, ty, 1]\r\n * </pre>\r\n * The last column is ignored so the array is shorter and operations are faster.\r\n */\n\n/**\r\n * Creates a new identity mat2d\r\n *\r\n * @returns {mat2d} a new 2x3 matrix\r\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(6);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[4] = 0;\n    out[5] = 0;\n  }\n\n  out[0] = 1;\n  out[3] = 1;\n  return out;\n}\n/**\r\n * Creates a new mat2d initialized with values from an existing matrix\r\n *\r\n * @param {ReadonlyMat2d} a matrix to clone\r\n * @returns {mat2d} a new 2x3 matrix\r\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(6);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  return out;\n}\n/**\r\n * Copy the values from one mat2d to another\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {ReadonlyMat2d} a the source matrix\r\n * @returns {mat2d} out\r\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  return out;\n}\n/**\r\n * Set a mat2d to the identity matrix\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @returns {mat2d} out\r\n */\n\nexport function identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = 0;\n  out[5] = 0;\n  return out;\n}\n/**\r\n * Create a new mat2d with the given values\r\n *\r\n * @param {Number} a Component A (index 0)\r\n * @param {Number} b Component B (index 1)\r\n * @param {Number} c Component C (index 2)\r\n * @param {Number} d Component D (index 3)\r\n * @param {Number} tx Component TX (index 4)\r\n * @param {Number} ty Component TY (index 5)\r\n * @returns {mat2d} A new mat2d\r\n */\n\nexport function fromValues(a, b, c, d, tx, ty) {\n  var out = new glMatrix.ARRAY_TYPE(6);\n  out[0] = a;\n  out[1] = b;\n  out[2] = c;\n  out[3] = d;\n  out[4] = tx;\n  out[5] = ty;\n  return out;\n}\n/**\r\n * Set the components of a mat2d to the given values\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {Number} a Component A (index 0)\r\n * @param {Number} b Component B (index 1)\r\n * @param {Number} c Component C (index 2)\r\n * @param {Number} d Component D (index 3)\r\n * @param {Number} tx Component TX (index 4)\r\n * @param {Number} ty Component TY (index 5)\r\n * @returns {mat2d} out\r\n */\n\nexport function set(out, a, b, c, d, tx, ty) {\n  out[0] = a;\n  out[1] = b;\n  out[2] = c;\n  out[3] = d;\n  out[4] = tx;\n  out[5] = ty;\n  return out;\n}\n/**\r\n * Inverts a mat2d\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {ReadonlyMat2d} a the source matrix\r\n * @returns {mat2d} out\r\n */\n\nexport function invert(out, a) {\n  var aa = a[0],\n      ab = a[1],\n      ac = a[2],\n      ad = a[3];\n  var atx = a[4],\n      aty = a[5];\n  var det = aa * ad - ab * ac;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = ad * det;\n  out[1] = -ab * det;\n  out[2] = -ac * det;\n  out[3] = aa * det;\n  out[4] = (ac * aty - ad * atx) * det;\n  out[5] = (ab * atx - aa * aty) * det;\n  return out;\n}\n/**\r\n * Calculates the determinant of a mat2d\r\n *\r\n * @param {ReadonlyMat2d} a the source matrix\r\n * @returns {Number} determinant of a\r\n */\n\nexport function determinant(a) {\n  return a[0] * a[3] - a[1] * a[2];\n}\n/**\r\n * Multiplies two mat2d's\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {ReadonlyMat2d} a the first operand\r\n * @param {ReadonlyMat2d} b the second operand\r\n * @returns {mat2d} out\r\n */\n\nexport function multiply(out, a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3],\n      b4 = b[4],\n      b5 = b[5];\n  out[0] = a0 * b0 + a2 * b1;\n  out[1] = a1 * b0 + a3 * b1;\n  out[2] = a0 * b2 + a2 * b3;\n  out[3] = a1 * b2 + a3 * b3;\n  out[4] = a0 * b4 + a2 * b5 + a4;\n  out[5] = a1 * b4 + a3 * b5 + a5;\n  return out;\n}\n/**\r\n * Rotates a mat2d by the given angle\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {ReadonlyMat2d} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat2d} out\r\n */\n\nexport function rotate(out, a, rad) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5];\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  out[0] = a0 * c + a2 * s;\n  out[1] = a1 * c + a3 * s;\n  out[2] = a0 * -s + a2 * c;\n  out[3] = a1 * -s + a3 * c;\n  out[4] = a4;\n  out[5] = a5;\n  return out;\n}\n/**\r\n * Scales the mat2d by the dimensions in the given vec2\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {ReadonlyMat2d} a the matrix to translate\r\n * @param {ReadonlyVec2} v the vec2 to scale the matrix by\r\n * @returns {mat2d} out\r\n **/\n\nexport function scale(out, a, v) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5];\n  var v0 = v[0],\n      v1 = v[1];\n  out[0] = a0 * v0;\n  out[1] = a1 * v0;\n  out[2] = a2 * v1;\n  out[3] = a3 * v1;\n  out[4] = a4;\n  out[5] = a5;\n  return out;\n}\n/**\r\n * Translates the mat2d by the dimensions in the given vec2\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {ReadonlyMat2d} a the matrix to translate\r\n * @param {ReadonlyVec2} v the vec2 to translate the matrix by\r\n * @returns {mat2d} out\r\n **/\n\nexport function translate(out, a, v) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5];\n  var v0 = v[0],\n      v1 = v[1];\n  out[0] = a0;\n  out[1] = a1;\n  out[2] = a2;\n  out[3] = a3;\n  out[4] = a0 * v0 + a2 * v1 + a4;\n  out[5] = a1 * v0 + a3 * v1 + a5;\n  return out;\n}\n/**\r\n * Creates a matrix from a given angle\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat2d.identity(dest);\r\n *     mat2d.rotate(dest, dest, rad);\r\n *\r\n * @param {mat2d} out mat2d receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat2d} out\r\n */\n\nexport function fromRotation(out, rad) {\n  var s = Math.sin(rad),\n      c = Math.cos(rad);\n  out[0] = c;\n  out[1] = s;\n  out[2] = -s;\n  out[3] = c;\n  out[4] = 0;\n  out[5] = 0;\n  return out;\n}\n/**\r\n * Creates a matrix from a vector scaling\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat2d.identity(dest);\r\n *     mat2d.scale(dest, dest, vec);\r\n *\r\n * @param {mat2d} out mat2d receiving operation result\r\n * @param {ReadonlyVec2} v Scaling vector\r\n * @returns {mat2d} out\r\n */\n\nexport function fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = v[1];\n  out[4] = 0;\n  out[5] = 0;\n  return out;\n}\n/**\r\n * Creates a matrix from a vector translation\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat2d.identity(dest);\r\n *     mat2d.translate(dest, dest, vec);\r\n *\r\n * @param {mat2d} out mat2d receiving operation result\r\n * @param {ReadonlyVec2} v Translation vector\r\n * @returns {mat2d} out\r\n */\n\nexport function fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = v[0];\n  out[5] = v[1];\n  return out;\n}\n/**\r\n * Returns a string representation of a mat2d\r\n *\r\n * @param {ReadonlyMat2d} a matrix to represent as a string\r\n * @returns {String} string representation of the matrix\r\n */\n\nexport function str(a) {\n  return \"mat2d(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \")\";\n}\n/**\r\n * Returns Frobenius norm of a mat2d\r\n *\r\n * @param {ReadonlyMat2d} a the matrix to calculate Frobenius norm of\r\n * @returns {Number} Frobenius norm\r\n */\n\nexport function frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], 1);\n}\n/**\r\n * Adds two mat2d's\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {ReadonlyMat2d} a the first operand\r\n * @param {ReadonlyMat2d} b the second operand\r\n * @returns {mat2d} out\r\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  return out;\n}\n/**\r\n * Subtracts matrix b from matrix a\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {ReadonlyMat2d} a the first operand\r\n * @param {ReadonlyMat2d} b the second operand\r\n * @returns {mat2d} out\r\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  return out;\n}\n/**\r\n * Multiply each element of the matrix by a scalar.\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {ReadonlyMat2d} a the matrix to scale\r\n * @param {Number} b amount to scale the matrix's elements by\r\n * @returns {mat2d} out\r\n */\n\nexport function multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  return out;\n}\n/**\r\n * Adds two mat2d's after multiplying each element of the second operand by a scalar value.\r\n *\r\n * @param {mat2d} out the receiving vector\r\n * @param {ReadonlyMat2d} a the first operand\r\n * @param {ReadonlyMat2d} b the second operand\r\n * @param {Number} scale the amount to scale b's elements by before adding\r\n * @returns {mat2d} out\r\n */\n\nexport function multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  return out;\n}\n/**\r\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {ReadonlyMat2d} a The first matrix.\r\n * @param {ReadonlyMat2d} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];\n}\n/**\r\n * Returns whether or not the matrices have approximately the same elements in the same position.\r\n *\r\n * @param {ReadonlyMat2d} a The first matrix.\r\n * @param {ReadonlyMat2d} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3],\n      b4 = b[4],\n      b5 = b[5];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5));\n}\n/**\r\n * Alias for {@link mat2d.multiply}\r\n * @function\r\n */\n\nexport var mul = multiply;\n/**\r\n * Alias for {@link mat2d.subtract}\r\n * @function\r\n */\n\nexport var sub = subtract;","import * as glMatrix from \"./common.js\";\n/**\r\n * 3x3 Matrix\r\n * @module mat3\r\n */\n\n/**\r\n * Creates a new identity mat3\r\n *\r\n * @returns {mat3} a new 3x3 matrix\r\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(9);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[5] = 0;\n    out[6] = 0;\n    out[7] = 0;\n  }\n\n  out[0] = 1;\n  out[4] = 1;\n  out[8] = 1;\n  return out;\n}\n/**\r\n * Copies the upper-left 3x3 values into the given mat3.\r\n *\r\n * @param {mat3} out the receiving 3x3 matrix\r\n * @param {ReadonlyMat4} a   the source 4x4 matrix\r\n * @returns {mat3} out\r\n */\n\nexport function fromMat4(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[4];\n  out[4] = a[5];\n  out[5] = a[6];\n  out[6] = a[8];\n  out[7] = a[9];\n  out[8] = a[10];\n  return out;\n}\n/**\r\n * Creates a new mat3 initialized with values from an existing matrix\r\n *\r\n * @param {ReadonlyMat3} a matrix to clone\r\n * @returns {mat3} a new 3x3 matrix\r\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(9);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\r\n * Copy the values from one mat3 to another\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {ReadonlyMat3} a the source matrix\r\n * @returns {mat3} out\r\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\r\n * Create a new mat3 with the given values\r\n *\r\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\r\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\r\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\r\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\r\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\r\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\r\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\r\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\r\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\r\n * @returns {mat3} A new mat3\r\n */\n\nexport function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  var out = new glMatrix.ARRAY_TYPE(9);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n/**\r\n * Set the components of a mat3 to the given values\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\r\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\r\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\r\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\r\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\r\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\r\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\r\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\r\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\r\n * @returns {mat3} out\r\n */\n\nexport function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n/**\r\n * Set a mat3 to the identity matrix\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @returns {mat3} out\r\n */\n\nexport function identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\r\n * Transpose the values of a mat3\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {ReadonlyMat3} a the source matrix\r\n * @returns {mat3} out\r\n */\n\nexport function transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n        a02 = a[2],\n        a12 = a[5];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a01;\n    out[5] = a[7];\n    out[6] = a02;\n    out[7] = a12;\n  } else {\n    out[0] = a[0];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a[1];\n    out[4] = a[4];\n    out[5] = a[7];\n    out[6] = a[2];\n    out[7] = a[5];\n    out[8] = a[8];\n  }\n\n  return out;\n}\n/**\r\n * Inverts a mat3\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {ReadonlyMat3} a the source matrix\r\n * @returns {mat3} out\r\n */\n\nexport function invert(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  var b01 = a22 * a11 - a12 * a21;\n  var b11 = -a22 * a10 + a12 * a20;\n  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant\n\n  var det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = b01 * det;\n  out[1] = (-a22 * a01 + a02 * a21) * det;\n  out[2] = (a12 * a01 - a02 * a11) * det;\n  out[3] = b11 * det;\n  out[4] = (a22 * a00 - a02 * a20) * det;\n  out[5] = (-a12 * a00 + a02 * a10) * det;\n  out[6] = b21 * det;\n  out[7] = (-a21 * a00 + a01 * a20) * det;\n  out[8] = (a11 * a00 - a01 * a10) * det;\n  return out;\n}\n/**\r\n * Calculates the adjugate of a mat3\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {ReadonlyMat3} a the source matrix\r\n * @returns {mat3} out\r\n */\n\nexport function adjoint(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  out[0] = a11 * a22 - a12 * a21;\n  out[1] = a02 * a21 - a01 * a22;\n  out[2] = a01 * a12 - a02 * a11;\n  out[3] = a12 * a20 - a10 * a22;\n  out[4] = a00 * a22 - a02 * a20;\n  out[5] = a02 * a10 - a00 * a12;\n  out[6] = a10 * a21 - a11 * a20;\n  out[7] = a01 * a20 - a00 * a21;\n  out[8] = a00 * a11 - a01 * a10;\n  return out;\n}\n/**\r\n * Calculates the determinant of a mat3\r\n *\r\n * @param {ReadonlyMat3} a the source matrix\r\n * @returns {Number} determinant of a\r\n */\n\nexport function determinant(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);\n}\n/**\r\n * Multiplies two mat3's\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {ReadonlyMat3} a the first operand\r\n * @param {ReadonlyMat3} b the second operand\r\n * @returns {mat3} out\r\n */\n\nexport function multiply(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  var b00 = b[0],\n      b01 = b[1],\n      b02 = b[2];\n  var b10 = b[3],\n      b11 = b[4],\n      b12 = b[5];\n  var b20 = b[6],\n      b21 = b[7],\n      b22 = b[8];\n  out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n  out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n  out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n  out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n  out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n  out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n  out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n  out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n  out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n  return out;\n}\n/**\r\n * Translate a mat3 by the given vector\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {ReadonlyMat3} a the matrix to translate\r\n * @param {ReadonlyVec2} v vector to translate by\r\n * @returns {mat3} out\r\n */\n\nexport function translate(out, a, v) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a10 = a[3],\n      a11 = a[4],\n      a12 = a[5],\n      a20 = a[6],\n      a21 = a[7],\n      a22 = a[8],\n      x = v[0],\n      y = v[1];\n  out[0] = a00;\n  out[1] = a01;\n  out[2] = a02;\n  out[3] = a10;\n  out[4] = a11;\n  out[5] = a12;\n  out[6] = x * a00 + y * a10 + a20;\n  out[7] = x * a01 + y * a11 + a21;\n  out[8] = x * a02 + y * a12 + a22;\n  return out;\n}\n/**\r\n * Rotates a mat3 by the given angle\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {ReadonlyMat3} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat3} out\r\n */\n\nexport function rotate(out, a, rad) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a10 = a[3],\n      a11 = a[4],\n      a12 = a[5],\n      a20 = a[6],\n      a21 = a[7],\n      a22 = a[8],\n      s = Math.sin(rad),\n      c = Math.cos(rad);\n  out[0] = c * a00 + s * a10;\n  out[1] = c * a01 + s * a11;\n  out[2] = c * a02 + s * a12;\n  out[3] = c * a10 - s * a00;\n  out[4] = c * a11 - s * a01;\n  out[5] = c * a12 - s * a02;\n  out[6] = a20;\n  out[7] = a21;\n  out[8] = a22;\n  return out;\n}\n/**\r\n * Scales the mat3 by the dimensions in the given vec2\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {ReadonlyMat3} a the matrix to rotate\r\n * @param {ReadonlyVec2} v the vec2 to scale the matrix by\r\n * @returns {mat3} out\r\n **/\n\nexport function scale(out, a, v) {\n  var x = v[0],\n      y = v[1];\n  out[0] = x * a[0];\n  out[1] = x * a[1];\n  out[2] = x * a[2];\n  out[3] = y * a[3];\n  out[4] = y * a[4];\n  out[5] = y * a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\r\n * Creates a matrix from a vector translation\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat3.identity(dest);\r\n *     mat3.translate(dest, dest, vec);\r\n *\r\n * @param {mat3} out mat3 receiving operation result\r\n * @param {ReadonlyVec2} v Translation vector\r\n * @returns {mat3} out\r\n */\n\nexport function fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = v[0];\n  out[7] = v[1];\n  out[8] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from a given angle\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat3.identity(dest);\r\n *     mat3.rotate(dest, dest, rad);\r\n *\r\n * @param {mat3} out mat3 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat3} out\r\n */\n\nexport function fromRotation(out, rad) {\n  var s = Math.sin(rad),\n      c = Math.cos(rad);\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n  out[3] = -s;\n  out[4] = c;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from a vector scaling\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat3.identity(dest);\r\n *     mat3.scale(dest, dest, vec);\r\n *\r\n * @param {mat3} out mat3 receiving operation result\r\n * @param {ReadonlyVec2} v Scaling vector\r\n * @returns {mat3} out\r\n */\n\nexport function fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = v[1];\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\r\n * Copies the values from a mat2d into a mat3\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {ReadonlyMat2d} a the matrix to copy\r\n * @returns {mat3} out\r\n **/\n\nexport function fromMat2d(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = 0;\n  out[3] = a[2];\n  out[4] = a[3];\n  out[5] = 0;\n  out[6] = a[4];\n  out[7] = a[5];\n  out[8] = 1;\n  return out;\n}\n/**\r\n * Calculates a 3x3 matrix from the given quaternion\r\n *\r\n * @param {mat3} out mat3 receiving operation result\r\n * @param {ReadonlyQuat} q Quaternion to create matrix from\r\n *\r\n * @returns {mat3} out\r\n */\n\nexport function fromQuat(out, q) {\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[3] = yx - wz;\n  out[6] = zx + wy;\n  out[1] = yx + wz;\n  out[4] = 1 - xx - zz;\n  out[7] = zy - wx;\n  out[2] = zx - wy;\n  out[5] = zy + wx;\n  out[8] = 1 - xx - yy;\n  return out;\n}\n/**\r\n * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix\r\n *\r\n * @param {mat3} out mat3 receiving operation result\r\n * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from\r\n *\r\n * @returns {mat3} out\r\n */\n\nexport function normalFromMat4(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  return out;\n}\n/**\r\n * Generates a 2D projection matrix with the given bounds\r\n *\r\n * @param {mat3} out mat3 frustum matrix will be written into\r\n * @param {number} width Width of your gl context\r\n * @param {number} height Height of gl context\r\n * @returns {mat3} out\r\n */\n\nexport function projection(out, width, height) {\n  out[0] = 2 / width;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -2 / height;\n  out[5] = 0;\n  out[6] = -1;\n  out[7] = 1;\n  out[8] = 1;\n  return out;\n}\n/**\r\n * Returns a string representation of a mat3\r\n *\r\n * @param {ReadonlyMat3} a matrix to represent as a string\r\n * @returns {String} string representation of the matrix\r\n */\n\nexport function str(a) {\n  return \"mat3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \", \" + a[6] + \", \" + a[7] + \", \" + a[8] + \")\";\n}\n/**\r\n * Returns Frobenius norm of a mat3\r\n *\r\n * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of\r\n * @returns {Number} Frobenius norm\r\n */\n\nexport function frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);\n}\n/**\r\n * Adds two mat3's\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {ReadonlyMat3} a the first operand\r\n * @param {ReadonlyMat3} b the second operand\r\n * @returns {mat3} out\r\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  return out;\n}\n/**\r\n * Subtracts matrix b from matrix a\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {ReadonlyMat3} a the first operand\r\n * @param {ReadonlyMat3} b the second operand\r\n * @returns {mat3} out\r\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  return out;\n}\n/**\r\n * Multiply each element of the matrix by a scalar.\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {ReadonlyMat3} a the matrix to scale\r\n * @param {Number} b amount to scale the matrix's elements by\r\n * @returns {mat3} out\r\n */\n\nexport function multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  return out;\n}\n/**\r\n * Adds two mat3's after multiplying each element of the second operand by a scalar value.\r\n *\r\n * @param {mat3} out the receiving vector\r\n * @param {ReadonlyMat3} a the first operand\r\n * @param {ReadonlyMat3} b the second operand\r\n * @param {Number} scale the amount to scale b's elements by before adding\r\n * @returns {mat3} out\r\n */\n\nexport function multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  return out;\n}\n/**\r\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {ReadonlyMat3} a The first matrix.\r\n * @param {ReadonlyMat3} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];\n}\n/**\r\n * Returns whether or not the matrices have approximately the same elements in the same position.\r\n *\r\n * @param {ReadonlyMat3} a The first matrix.\r\n * @param {ReadonlyMat3} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7],\n      a8 = a[8];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3],\n      b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7],\n      b8 = b[8];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));\n}\n/**\r\n * Alias for {@link mat3.multiply}\r\n * @function\r\n */\n\nexport var mul = multiply;\n/**\r\n * Alias for {@link mat3.subtract}\r\n * @function\r\n */\n\nexport var sub = subtract;","import * as glMatrix from \"./common.js\";\n/**\r\n * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.\r\n * @module mat4\r\n */\n\n/**\r\n * Creates a new identity mat4\r\n *\r\n * @returns {mat4} a new 4x4 matrix\r\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(16);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n  }\n\n  out[0] = 1;\n  out[5] = 1;\n  out[10] = 1;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a new mat4 initialized with values from an existing matrix\r\n *\r\n * @param {ReadonlyMat4} a matrix to clone\r\n * @returns {mat4} a new 4x4 matrix\r\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\r\n * Copy the values from one mat4 to another\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the source matrix\r\n * @returns {mat4} out\r\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\r\n * Create a new mat4 with the given values\r\n *\r\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\r\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\r\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\r\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\r\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\r\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\r\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\r\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\r\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\r\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\r\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\r\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\r\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\r\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\r\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\r\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\r\n * @returns {mat4} A new mat4\r\n */\n\nexport function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\r\n * Set the components of a mat4 to the given values\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\r\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\r\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\r\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\r\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\r\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\r\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\r\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\r\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\r\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\r\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\r\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\r\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\r\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\r\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\r\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\r\n * @returns {mat4} out\r\n */\n\nexport function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\r\n * Set a mat4 to the identity matrix\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @returns {mat4} out\r\n */\n\nexport function identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Transpose the values of a mat4\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the source matrix\r\n * @returns {mat4} out\r\n */\n\nexport function transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n        a02 = a[2],\n        a03 = a[3];\n    var a12 = a[6],\n        a13 = a[7];\n    var a23 = a[11];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a01;\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a02;\n    out[9] = a12;\n    out[11] = a[14];\n    out[12] = a03;\n    out[13] = a13;\n    out[14] = a23;\n  } else {\n    out[0] = a[0];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a[1];\n    out[5] = a[5];\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a[2];\n    out[9] = a[6];\n    out[10] = a[10];\n    out[11] = a[14];\n    out[12] = a[3];\n    out[13] = a[7];\n    out[14] = a[11];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\r\n * Inverts a mat4\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the source matrix\r\n * @returns {mat4} out\r\n */\n\nexport function invert(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n  return out;\n}\n/**\r\n * Calculates the adjugate of a mat4\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the source matrix\r\n * @returns {mat4} out\r\n */\n\nexport function adjoint(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);\n  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));\n  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);\n  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));\n  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));\n  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);\n  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));\n  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);\n  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);\n  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));\n  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);\n  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));\n  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));\n  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);\n  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));\n  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);\n  return out;\n}\n/**\r\n * Calculates the determinant of a mat4\r\n *\r\n * @param {ReadonlyMat4} a the source matrix\r\n * @returns {Number} determinant of a\r\n */\n\nexport function determinant(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n}\n/**\r\n * Multiplies two mat4s\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the first operand\r\n * @param {ReadonlyMat4} b the second operand\r\n * @returns {mat4} out\r\n */\n\nexport function multiply(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15]; // Cache only the current line of the second matrix\n\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[4];\n  b1 = b[5];\n  b2 = b[6];\n  b3 = b[7];\n  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[8];\n  b1 = b[9];\n  b2 = b[10];\n  b3 = b[11];\n  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[12];\n  b1 = b[13];\n  b2 = b[14];\n  b3 = b[15];\n  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  return out;\n}\n/**\r\n * Translate a mat4 by the given vector\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the matrix to translate\r\n * @param {ReadonlyVec3} v vector to translate by\r\n * @returns {mat4} out\r\n */\n\nexport function translate(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n\n  if (a === out) {\n    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n  } else {\n    a00 = a[0];\n    a01 = a[1];\n    a02 = a[2];\n    a03 = a[3];\n    a10 = a[4];\n    a11 = a[5];\n    a12 = a[6];\n    a13 = a[7];\n    a20 = a[8];\n    a21 = a[9];\n    a22 = a[10];\n    a23 = a[11];\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n    out[3] = a03;\n    out[4] = a10;\n    out[5] = a11;\n    out[6] = a12;\n    out[7] = a13;\n    out[8] = a20;\n    out[9] = a21;\n    out[10] = a22;\n    out[11] = a23;\n    out[12] = a00 * x + a10 * y + a20 * z + a[12];\n    out[13] = a01 * x + a11 * y + a21 * z + a[13];\n    out[14] = a02 * x + a12 * y + a22 * z + a[14];\n    out[15] = a03 * x + a13 * y + a23 * z + a[15];\n  }\n\n  return out;\n}\n/**\r\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the matrix to scale\r\n * @param {ReadonlyVec3} v the vec3 to scale the matrix by\r\n * @returns {mat4} out\r\n **/\n\nexport function scale(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  out[0] = a[0] * x;\n  out[1] = a[1] * x;\n  out[2] = a[2] * x;\n  out[3] = a[3] * x;\n  out[4] = a[4] * y;\n  out[5] = a[5] * y;\n  out[6] = a[6] * y;\n  out[7] = a[7] * y;\n  out[8] = a[8] * z;\n  out[9] = a[9] * z;\n  out[10] = a[10] * z;\n  out[11] = a[11] * z;\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\r\n * Rotates a mat4 by the given angle around the given axis\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @param {ReadonlyVec3} axis the axis to rotate around\r\n * @returns {mat4} out\r\n */\n\nexport function rotate(out, a, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n  var b00, b01, b02;\n  var b10, b11, b12;\n  var b20, b21, b22;\n\n  if (len < glMatrix.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c;\n  a00 = a[0];\n  a01 = a[1];\n  a02 = a[2];\n  a03 = a[3];\n  a10 = a[4];\n  a11 = a[5];\n  a12 = a[6];\n  a13 = a[7];\n  a20 = a[8];\n  a21 = a[9];\n  a22 = a[10];\n  a23 = a[11]; // Construct the elements of the rotation matrix\n\n  b00 = x * x * t + c;\n  b01 = y * x * t + z * s;\n  b02 = z * x * t - y * s;\n  b10 = x * y * t - z * s;\n  b11 = y * y * t + c;\n  b12 = z * y * t + x * s;\n  b20 = x * z * t + y * s;\n  b21 = y * z * t - x * s;\n  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication\n\n  out[0] = a00 * b00 + a10 * b01 + a20 * b02;\n  out[1] = a01 * b00 + a11 * b01 + a21 * b02;\n  out[2] = a02 * b00 + a12 * b01 + a22 * b02;\n  out[3] = a03 * b00 + a13 * b01 + a23 * b02;\n  out[4] = a00 * b10 + a10 * b11 + a20 * b12;\n  out[5] = a01 * b10 + a11 * b11 + a21 * b12;\n  out[6] = a02 * b10 + a12 * b11 + a22 * b12;\n  out[7] = a03 * b10 + a13 * b11 + a23 * b12;\n  out[8] = a00 * b20 + a10 * b21 + a20 * b22;\n  out[9] = a01 * b20 + a11 * b21 + a21 * b22;\n  out[10] = a02 * b20 + a12 * b21 + a22 * b22;\n  out[11] = a03 * b20 + a13 * b21 + a23 * b22;\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\r\n * Rotates a matrix by the given angle around the X axis\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\n\nexport function rotateX(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[4] = a10 * c + a20 * s;\n  out[5] = a11 * c + a21 * s;\n  out[6] = a12 * c + a22 * s;\n  out[7] = a13 * c + a23 * s;\n  out[8] = a20 * c - a10 * s;\n  out[9] = a21 * c - a11 * s;\n  out[10] = a22 * c - a12 * s;\n  out[11] = a23 * c - a13 * s;\n  return out;\n}\n/**\r\n * Rotates a matrix by the given angle around the Y axis\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\n\nexport function rotateY(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c - a20 * s;\n  out[1] = a01 * c - a21 * s;\n  out[2] = a02 * c - a22 * s;\n  out[3] = a03 * c - a23 * s;\n  out[8] = a00 * s + a20 * c;\n  out[9] = a01 * s + a21 * c;\n  out[10] = a02 * s + a22 * c;\n  out[11] = a03 * s + a23 * c;\n  return out;\n}\n/**\r\n * Rotates a matrix by the given angle around the Z axis\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\n\nexport function rotateZ(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[8] = a[8];\n    out[9] = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c + a10 * s;\n  out[1] = a01 * c + a11 * s;\n  out[2] = a02 * c + a12 * s;\n  out[3] = a03 * c + a13 * s;\n  out[4] = a10 * c - a00 * s;\n  out[5] = a11 * c - a01 * s;\n  out[6] = a12 * c - a02 * s;\n  out[7] = a13 * c - a03 * s;\n  return out;\n}\n/**\r\n * Creates a matrix from a vector translation\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.translate(dest, dest, vec);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {ReadonlyVec3} v Translation vector\r\n * @returns {mat4} out\r\n */\n\nexport function fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from a vector scaling\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.scale(dest, dest, vec);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {ReadonlyVec3} v Scaling vector\r\n * @returns {mat4} out\r\n */\n\nexport function fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = v[1];\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = v[2];\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from a given angle around a given axis\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.rotate(dest, dest, rad, axis);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @param {ReadonlyVec3} axis the axis to rotate around\r\n * @returns {mat4} out\r\n */\n\nexport function fromRotation(out, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n\n  if (len < glMatrix.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c; // Perform rotation-specific matrix multiplication\n\n  out[0] = x * x * t + c;\n  out[1] = y * x * t + z * s;\n  out[2] = z * x * t - y * s;\n  out[3] = 0;\n  out[4] = x * y * t - z * s;\n  out[5] = y * y * t + c;\n  out[6] = z * y * t + x * s;\n  out[7] = 0;\n  out[8] = x * z * t + y * s;\n  out[9] = y * z * t - x * s;\n  out[10] = z * z * t + c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from the given angle around the X axis\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.rotateX(dest, dest, rad);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\n\nexport function fromXRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = c;\n  out[6] = s;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = -s;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from the given angle around the Y axis\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.rotateY(dest, dest, rad);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\n\nexport function fromYRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = 0;\n  out[2] = -s;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = s;\n  out[9] = 0;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from the given angle around the Z axis\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.rotateZ(dest, dest, rad);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\n\nexport function fromZRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -s;\n  out[5] = c;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from a quaternion rotation and vector translation\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.translate(dest, vec);\r\n *     let quatMat = mat4.create();\r\n *     quat4.toMat4(quat, quatMat);\r\n *     mat4.multiply(dest, quatMat);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {quat4} q Rotation quaternion\r\n * @param {ReadonlyVec3} v Translation vector\r\n * @returns {mat4} out\r\n */\n\nexport function fromRotationTranslation(out, q, v) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - (yy + zz);\n  out[1] = xy + wz;\n  out[2] = xz - wy;\n  out[3] = 0;\n  out[4] = xy - wz;\n  out[5] = 1 - (xx + zz);\n  out[6] = yz + wx;\n  out[7] = 0;\n  out[8] = xz + wy;\n  out[9] = yz - wx;\n  out[10] = 1 - (xx + yy);\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a new mat4 from a dual quat.\r\n *\r\n * @param {mat4} out Matrix\r\n * @param {ReadonlyQuat2} a Dual Quaternion\r\n * @returns {mat4} mat4 receiving operation result\r\n */\n\nexport function fromQuat2(out, a) {\n  var translation = new glMatrix.ARRAY_TYPE(3);\n  var bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3],\n      ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7];\n  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense\n\n  if (magnitude > 0) {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;\n  } else {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;\n  }\n\n  fromRotationTranslation(out, a, translation);\n  return out;\n}\n/**\r\n * Returns the translation vector component of a transformation\r\n *  matrix. If a matrix is built with fromRotationTranslation,\r\n *  the returned vector will be the same as the translation vector\r\n *  originally supplied.\r\n * @param  {vec3} out Vector to receive translation component\r\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\r\n * @return {vec3} out\r\n */\n\nexport function getTranslation(out, mat) {\n  out[0] = mat[12];\n  out[1] = mat[13];\n  out[2] = mat[14];\n  return out;\n}\n/**\r\n * Returns the scaling factor component of a transformation\r\n *  matrix. If a matrix is built with fromRotationTranslationScale\r\n *  with a normalized Quaternion paramter, the returned vector will be\r\n *  the same as the scaling vector\r\n *  originally supplied.\r\n * @param  {vec3} out Vector to receive scaling factor component\r\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\r\n * @return {vec3} out\r\n */\n\nexport function getScaling(out, mat) {\n  var m11 = mat[0];\n  var m12 = mat[1];\n  var m13 = mat[2];\n  var m21 = mat[4];\n  var m22 = mat[5];\n  var m23 = mat[6];\n  var m31 = mat[8];\n  var m32 = mat[9];\n  var m33 = mat[10];\n  out[0] = Math.hypot(m11, m12, m13);\n  out[1] = Math.hypot(m21, m22, m23);\n  out[2] = Math.hypot(m31, m32, m33);\n  return out;\n}\n/**\r\n * Returns a quaternion representing the rotational component\r\n *  of a transformation matrix. If a matrix is built with\r\n *  fromRotationTranslation, the returned quaternion will be the\r\n *  same as the quaternion originally supplied.\r\n * @param {quat} out Quaternion to receive the rotation component\r\n * @param {ReadonlyMat4} mat Matrix to be decomposed (input)\r\n * @return {quat} out\r\n */\n\nexport function getRotation(out, mat) {\n  var scaling = new glMatrix.ARRAY_TYPE(3);\n  getScaling(scaling, mat);\n  var is1 = 1 / scaling[0];\n  var is2 = 1 / scaling[1];\n  var is3 = 1 / scaling[2];\n  var sm11 = mat[0] * is1;\n  var sm12 = mat[1] * is2;\n  var sm13 = mat[2] * is3;\n  var sm21 = mat[4] * is1;\n  var sm22 = mat[5] * is2;\n  var sm23 = mat[6] * is3;\n  var sm31 = mat[8] * is1;\n  var sm32 = mat[9] * is2;\n  var sm33 = mat[10] * is3;\n  var trace = sm11 + sm22 + sm33;\n  var S = 0;\n\n  if (trace > 0) {\n    S = Math.sqrt(trace + 1.0) * 2;\n    out[3] = 0.25 * S;\n    out[0] = (sm23 - sm32) / S;\n    out[1] = (sm31 - sm13) / S;\n    out[2] = (sm12 - sm21) / S;\n  } else if (sm11 > sm22 && sm11 > sm33) {\n    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;\n    out[3] = (sm23 - sm32) / S;\n    out[0] = 0.25 * S;\n    out[1] = (sm12 + sm21) / S;\n    out[2] = (sm31 + sm13) / S;\n  } else if (sm22 > sm33) {\n    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;\n    out[3] = (sm31 - sm13) / S;\n    out[0] = (sm12 + sm21) / S;\n    out[1] = 0.25 * S;\n    out[2] = (sm23 + sm32) / S;\n  } else {\n    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;\n    out[3] = (sm12 - sm21) / S;\n    out[0] = (sm31 + sm13) / S;\n    out[1] = (sm23 + sm32) / S;\n    out[2] = 0.25 * S;\n  }\n\n  return out;\n}\n/**\r\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.translate(dest, vec);\r\n *     let quatMat = mat4.create();\r\n *     quat4.toMat4(quat, quatMat);\r\n *     mat4.multiply(dest, quatMat);\r\n *     mat4.scale(dest, scale)\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {quat4} q Rotation quaternion\r\n * @param {ReadonlyVec3} v Translation vector\r\n * @param {ReadonlyVec3} s Scaling vector\r\n * @returns {mat4} out\r\n */\n\nexport function fromRotationTranslationScale(out, q, v, s) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  out[0] = (1 - (yy + zz)) * sx;\n  out[1] = (xy + wz) * sx;\n  out[2] = (xz - wy) * sx;\n  out[3] = 0;\n  out[4] = (xy - wz) * sy;\n  out[5] = (1 - (xx + zz)) * sy;\n  out[6] = (yz + wx) * sy;\n  out[7] = 0;\n  out[8] = (xz + wy) * sz;\n  out[9] = (yz - wx) * sz;\n  out[10] = (1 - (xx + yy)) * sz;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.translate(dest, vec);\r\n *     mat4.translate(dest, origin);\r\n *     let quatMat = mat4.create();\r\n *     quat4.toMat4(quat, quatMat);\r\n *     mat4.multiply(dest, quatMat);\r\n *     mat4.scale(dest, scale)\r\n *     mat4.translate(dest, negativeOrigin);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {quat4} q Rotation quaternion\r\n * @param {ReadonlyVec3} v Translation vector\r\n * @param {ReadonlyVec3} s Scaling vector\r\n * @param {ReadonlyVec3} o The origin vector around which to scale and rotate\r\n * @returns {mat4} out\r\n */\n\nexport function fromRotationTranslationScaleOrigin(out, q, v, s, o) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  var ox = o[0];\n  var oy = o[1];\n  var oz = o[2];\n  var out0 = (1 - (yy + zz)) * sx;\n  var out1 = (xy + wz) * sx;\n  var out2 = (xz - wy) * sx;\n  var out4 = (xy - wz) * sy;\n  var out5 = (1 - (xx + zz)) * sy;\n  var out6 = (yz + wx) * sy;\n  var out8 = (xz + wy) * sz;\n  var out9 = (yz - wx) * sz;\n  var out10 = (1 - (xx + yy)) * sz;\n  out[0] = out0;\n  out[1] = out1;\n  out[2] = out2;\n  out[3] = 0;\n  out[4] = out4;\n  out[5] = out5;\n  out[6] = out6;\n  out[7] = 0;\n  out[8] = out8;\n  out[9] = out9;\n  out[10] = out10;\n  out[11] = 0;\n  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);\n  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);\n  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Calculates a 4x4 matrix from the given quaternion\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {ReadonlyQuat} q Quaternion to create matrix from\r\n *\r\n * @returns {mat4} out\r\n */\n\nexport function fromQuat(out, q) {\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[1] = yx + wz;\n  out[2] = zx - wy;\n  out[3] = 0;\n  out[4] = yx - wz;\n  out[5] = 1 - xx - zz;\n  out[6] = zy + wx;\n  out[7] = 0;\n  out[8] = zx + wy;\n  out[9] = zy - wx;\n  out[10] = 1 - xx - yy;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Generates a frustum matrix with the given bounds\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {Number} left Left bound of the frustum\r\n * @param {Number} right Right bound of the frustum\r\n * @param {Number} bottom Bottom bound of the frustum\r\n * @param {Number} top Top bound of the frustum\r\n * @param {Number} near Near bound of the frustum\r\n * @param {Number} far Far bound of the frustum\r\n * @returns {mat4} out\r\n */\n\nexport function frustum(out, left, right, bottom, top, near, far) {\n  var rl = 1 / (right - left);\n  var tb = 1 / (top - bottom);\n  var nf = 1 / (near - far);\n  out[0] = near * 2 * rl;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = near * 2 * tb;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = (right + left) * rl;\n  out[9] = (top + bottom) * tb;\n  out[10] = (far + near) * nf;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = far * near * 2 * nf;\n  out[15] = 0;\n  return out;\n}\n/**\r\n * Generates a perspective projection matrix with the given bounds.\r\n * Passing null/undefined/no value for far will generate infinite projection matrix.\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {number} fovy Vertical field of view in radians\r\n * @param {number} aspect Aspect ratio. typically viewport width/height\r\n * @param {number} near Near bound of the frustum\r\n * @param {number} far Far bound of the frustum, can be null or Infinity\r\n * @returns {mat4} out\r\n */\n\nexport function perspective(out, fovy, aspect, near, far) {\n  var f = 1.0 / Math.tan(fovy / 2),\n      nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = (far + near) * nf;\n    out[14] = 2 * far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -2 * near;\n  }\n\n  return out;\n}\n/**\r\n * Generates a perspective projection matrix with the given field of view.\r\n * This is primarily useful for generating projection matrices to be used\r\n * with the still experiemental WebVR API.\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees\r\n * @param {number} near Near bound of the frustum\r\n * @param {number} far Far bound of the frustum\r\n * @returns {mat4} out\r\n */\n\nexport function perspectiveFromFieldOfView(out, fov, near, far) {\n  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);\n  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);\n  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);\n  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);\n  var xScale = 2.0 / (leftTan + rightTan);\n  var yScale = 2.0 / (upTan + downTan);\n  out[0] = xScale;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  out[4] = 0.0;\n  out[5] = yScale;\n  out[6] = 0.0;\n  out[7] = 0.0;\n  out[8] = -((leftTan - rightTan) * xScale * 0.5);\n  out[9] = (upTan - downTan) * yScale * 0.5;\n  out[10] = far / (near - far);\n  out[11] = -1.0;\n  out[12] = 0.0;\n  out[13] = 0.0;\n  out[14] = far * near / (near - far);\n  out[15] = 0.0;\n  return out;\n}\n/**\r\n * Generates a orthogonal projection matrix with the given bounds\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {number} left Left bound of the frustum\r\n * @param {number} right Right bound of the frustum\r\n * @param {number} bottom Bottom bound of the frustum\r\n * @param {number} top Top bound of the frustum\r\n * @param {number} near Near bound of the frustum\r\n * @param {number} far Far bound of the frustum\r\n * @returns {mat4} out\r\n */\n\nexport function ortho(out, left, right, bottom, top, near, far) {\n  var lr = 1 / (left - right);\n  var bt = 1 / (bottom - top);\n  var nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 2 * nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = (far + near) * nf;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Generates a look-at matrix with the given eye position, focal point, and up axis.\r\n * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {ReadonlyVec3} eye Position of the viewer\r\n * @param {ReadonlyVec3} center Point the viewer is looking at\r\n * @param {ReadonlyVec3} up vec3 pointing up\r\n * @returns {mat4} out\r\n */\n\nexport function lookAt(out, eye, center, up) {\n  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;\n  var eyex = eye[0];\n  var eyey = eye[1];\n  var eyez = eye[2];\n  var upx = up[0];\n  var upy = up[1];\n  var upz = up[2];\n  var centerx = center[0];\n  var centery = center[1];\n  var centerz = center[2];\n\n  if (Math.abs(eyex - centerx) < glMatrix.EPSILON && Math.abs(eyey - centery) < glMatrix.EPSILON && Math.abs(eyez - centerz) < glMatrix.EPSILON) {\n    return identity(out);\n  }\n\n  z0 = eyex - centerx;\n  z1 = eyey - centery;\n  z2 = eyez - centerz;\n  len = 1 / Math.hypot(z0, z1, z2);\n  z0 *= len;\n  z1 *= len;\n  z2 *= len;\n  x0 = upy * z2 - upz * z1;\n  x1 = upz * z0 - upx * z2;\n  x2 = upx * z1 - upy * z0;\n  len = Math.hypot(x0, x1, x2);\n\n  if (!len) {\n    x0 = 0;\n    x1 = 0;\n    x2 = 0;\n  } else {\n    len = 1 / len;\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  y0 = z1 * x2 - z2 * x1;\n  y1 = z2 * x0 - z0 * x2;\n  y2 = z0 * x1 - z1 * x0;\n  len = Math.hypot(y0, y1, y2);\n\n  if (!len) {\n    y0 = 0;\n    y1 = 0;\n    y2 = 0;\n  } else {\n    len = 1 / len;\n    y0 *= len;\n    y1 *= len;\n    y2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = y0;\n  out[2] = z0;\n  out[3] = 0;\n  out[4] = x1;\n  out[5] = y1;\n  out[6] = z1;\n  out[7] = 0;\n  out[8] = x2;\n  out[9] = y2;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\n  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\n  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Generates a matrix that makes something look at something else.\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {ReadonlyVec3} eye Position of the viewer\r\n * @param {ReadonlyVec3} center Point the viewer is looking at\r\n * @param {ReadonlyVec3} up vec3 pointing up\r\n * @returns {mat4} out\r\n */\n\nexport function targetTo(out, eye, target, up) {\n  var eyex = eye[0],\n      eyey = eye[1],\n      eyez = eye[2],\n      upx = up[0],\n      upy = up[1],\n      upz = up[2];\n  var z0 = eyex - target[0],\n      z1 = eyey - target[1],\n      z2 = eyez - target[2];\n  var len = z0 * z0 + z1 * z1 + z2 * z2;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    z0 *= len;\n    z1 *= len;\n    z2 *= len;\n  }\n\n  var x0 = upy * z2 - upz * z1,\n      x1 = upz * z0 - upx * z2,\n      x2 = upx * z1 - upy * z0;\n  len = x0 * x0 + x1 * x1 + x2 * x2;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = x1;\n  out[2] = x2;\n  out[3] = 0;\n  out[4] = z1 * x2 - z2 * x1;\n  out[5] = z2 * x0 - z0 * x2;\n  out[6] = z0 * x1 - z1 * x0;\n  out[7] = 0;\n  out[8] = z0;\n  out[9] = z1;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = eyex;\n  out[13] = eyey;\n  out[14] = eyez;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Returns a string representation of a mat4\r\n *\r\n * @param {ReadonlyMat4} a matrix to represent as a string\r\n * @returns {String} string representation of the matrix\r\n */\n\nexport function str(a) {\n  return \"mat4(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \", \" + a[6] + \", \" + a[7] + \", \" + a[8] + \", \" + a[9] + \", \" + a[10] + \", \" + a[11] + \", \" + a[12] + \", \" + a[13] + \", \" + a[14] + \", \" + a[15] + \")\";\n}\n/**\r\n * Returns Frobenius norm of a mat4\r\n *\r\n * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of\r\n * @returns {Number} Frobenius norm\r\n */\n\nexport function frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);\n}\n/**\r\n * Adds two mat4's\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the first operand\r\n * @param {ReadonlyMat4} b the second operand\r\n * @returns {mat4} out\r\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  out[9] = a[9] + b[9];\n  out[10] = a[10] + b[10];\n  out[11] = a[11] + b[11];\n  out[12] = a[12] + b[12];\n  out[13] = a[13] + b[13];\n  out[14] = a[14] + b[14];\n  out[15] = a[15] + b[15];\n  return out;\n}\n/**\r\n * Subtracts matrix b from matrix a\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the first operand\r\n * @param {ReadonlyMat4} b the second operand\r\n * @returns {mat4} out\r\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  out[9] = a[9] - b[9];\n  out[10] = a[10] - b[10];\n  out[11] = a[11] - b[11];\n  out[12] = a[12] - b[12];\n  out[13] = a[13] - b[13];\n  out[14] = a[14] - b[14];\n  out[15] = a[15] - b[15];\n  return out;\n}\n/**\r\n * Multiply each element of the matrix by a scalar.\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the matrix to scale\r\n * @param {Number} b amount to scale the matrix's elements by\r\n * @returns {mat4} out\r\n */\n\nexport function multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  out[9] = a[9] * b;\n  out[10] = a[10] * b;\n  out[11] = a[11] * b;\n  out[12] = a[12] * b;\n  out[13] = a[13] * b;\n  out[14] = a[14] * b;\n  out[15] = a[15] * b;\n  return out;\n}\n/**\r\n * Adds two mat4's after multiplying each element of the second operand by a scalar value.\r\n *\r\n * @param {mat4} out the receiving vector\r\n * @param {ReadonlyMat4} a the first operand\r\n * @param {ReadonlyMat4} b the second operand\r\n * @param {Number} scale the amount to scale b's elements by before adding\r\n * @returns {mat4} out\r\n */\n\nexport function multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  out[9] = a[9] + b[9] * scale;\n  out[10] = a[10] + b[10] * scale;\n  out[11] = a[11] + b[11] * scale;\n  out[12] = a[12] + b[12] * scale;\n  out[13] = a[13] + b[13] * scale;\n  out[14] = a[14] + b[14] * scale;\n  out[15] = a[15] + b[15] * scale;\n  return out;\n}\n/**\r\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {ReadonlyMat4} a The first matrix.\r\n * @param {ReadonlyMat4} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];\n}\n/**\r\n * Returns whether or not the matrices have approximately the same elements in the same position.\r\n *\r\n * @param {ReadonlyMat4} a The first matrix.\r\n * @param {ReadonlyMat4} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7];\n  var a8 = a[8],\n      a9 = a[9],\n      a10 = a[10],\n      a11 = a[11];\n  var a12 = a[12],\n      a13 = a[13],\n      a14 = a[14],\n      a15 = a[15];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  var b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7];\n  var b8 = b[8],\n      b9 = b[9],\n      b10 = b[10],\n      b11 = b[11];\n  var b12 = b[12],\n      b13 = b[13],\n      b14 = b[14],\n      b15 = b[15];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));\n}\n/**\r\n * Alias for {@link mat4.multiply}\r\n * @function\r\n */\n\nexport var mul = multiply;\n/**\r\n * Alias for {@link mat4.subtract}\r\n * @function\r\n */\n\nexport var sub = subtract;","import * as glMatrix from \"./common.js\";\n/**\r\n * 3 Dimensional Vector\r\n * @module vec3\r\n */\n\n/**\r\n * Creates a new, empty vec3\r\n *\r\n * @returns {vec3} a new 3D vector\r\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(3);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  return out;\n}\n/**\r\n * Creates a new vec3 initialized with values from an existing vector\r\n *\r\n * @param {ReadonlyVec3} a vector to clone\r\n * @returns {vec3} a new 3D vector\r\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\r\n * Calculates the length of a vec3\r\n *\r\n * @param {ReadonlyVec3} a vector to calculate length of\r\n * @returns {Number} length of a\r\n */\n\nexport function length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return Math.hypot(x, y, z);\n}\n/**\r\n * Creates a new vec3 initialized with the given values\r\n *\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @returns {vec3} a new 3D vector\r\n */\n\nexport function fromValues(x, y, z) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\r\n * Copy the values from one vec3 to another\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the source vector\r\n * @returns {vec3} out\r\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\r\n * Set the components of a vec3 to the given values\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @returns {vec3} out\r\n */\n\nexport function set(out, x, y, z) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\r\n * Adds two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  return out;\n}\n/**\r\n * Subtracts vector b from vector a\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  return out;\n}\n/**\r\n * Multiplies two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  return out;\n}\n/**\r\n * Divides two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  return out;\n}\n/**\r\n * Math.ceil the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a vector to ceil\r\n * @returns {vec3} out\r\n */\n\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  return out;\n}\n/**\r\n * Math.floor the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a vector to floor\r\n * @returns {vec3} out\r\n */\n\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  return out;\n}\n/**\r\n * Returns the minimum of two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  return out;\n}\n/**\r\n * Returns the maximum of two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  return out;\n}\n/**\r\n * Math.round the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a vector to round\r\n * @returns {vec3} out\r\n */\n\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  return out;\n}\n/**\r\n * Scales a vec3 by a scalar number\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the vector to scale\r\n * @param {Number} b amount to scale the vector by\r\n * @returns {vec3} out\r\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  return out;\n}\n/**\r\n * Adds two vec3's after scaling the second operand by a scalar value\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @param {Number} scale the amount to scale b by before adding\r\n * @returns {vec3} out\r\n */\n\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  return out;\n}\n/**\r\n * Calculates the euclidian distance between two vec3's\r\n *\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {Number} distance between a and b\r\n */\n\nexport function distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return Math.hypot(x, y, z);\n}\n/**\r\n * Calculates the squared euclidian distance between two vec3's\r\n *\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {Number} squared distance between a and b\r\n */\n\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return x * x + y * y + z * z;\n}\n/**\r\n * Calculates the squared length of a vec3\r\n *\r\n * @param {ReadonlyVec3} a vector to calculate squared length of\r\n * @returns {Number} squared length of a\r\n */\n\nexport function squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return x * x + y * y + z * z;\n}\n/**\r\n * Negates the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a vector to negate\r\n * @returns {vec3} out\r\n */\n\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  return out;\n}\n/**\r\n * Returns the inverse of the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a vector to invert\r\n * @returns {vec3} out\r\n */\n\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n}\n/**\r\n * Normalize a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a vector to normalize\r\n * @returns {vec3} out\r\n */\n\nexport function normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var len = x * x + y * y + z * z;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  out[2] = a[2] * len;\n  return out;\n}\n/**\r\n * Calculates the dot product of two vec3's\r\n *\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {Number} dot product of a and b\r\n */\n\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n/**\r\n * Computes the cross product of two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nexport function cross(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2];\n  out[0] = ay * bz - az * by;\n  out[1] = az * bx - ax * bz;\n  out[2] = ax * by - ay * bx;\n  return out;\n}\n/**\r\n * Performs a linear interpolation between two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec3} out\r\n */\n\nexport function lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  return out;\n}\n/**\r\n * Performs a hermite interpolation with two control points\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @param {ReadonlyVec3} c the third operand\r\n * @param {ReadonlyVec3} d the fourth operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec3} out\r\n */\n\nexport function hermite(out, a, b, c, d, t) {\n  var factorTimes2 = t * t;\n  var factor1 = factorTimes2 * (2 * t - 3) + 1;\n  var factor2 = factorTimes2 * (t - 2) + t;\n  var factor3 = factorTimes2 * (t - 1);\n  var factor4 = factorTimes2 * (3 - 2 * t);\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\r\n * Performs a bezier interpolation with two control points\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @param {ReadonlyVec3} c the third operand\r\n * @param {ReadonlyVec3} d the fourth operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec3} out\r\n */\n\nexport function bezier(out, a, b, c, d, t) {\n  var inverseFactor = 1 - t;\n  var inverseFactorTimesTwo = inverseFactor * inverseFactor;\n  var factorTimes2 = t * t;\n  var factor1 = inverseFactorTimesTwo * inverseFactor;\n  var factor2 = 3 * t * inverseFactorTimesTwo;\n  var factor3 = 3 * factorTimes2 * inverseFactor;\n  var factor4 = factorTimes2 * t;\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\r\n * Generates a random vector with the given scale\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\r\n * @returns {vec3} out\r\n */\n\nexport function random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  var z = glMatrix.RANDOM() * 2.0 - 1.0;\n  var zScale = Math.sqrt(1.0 - z * z) * scale;\n  out[0] = Math.cos(r) * zScale;\n  out[1] = Math.sin(r) * zScale;\n  out[2] = z * scale;\n  return out;\n}\n/**\r\n * Transforms the vec3 with a mat4.\r\n * 4th vector component is implicitly '1'\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the vector to transform\r\n * @param {ReadonlyMat4} m matrix to transform with\r\n * @returns {vec3} out\r\n */\n\nexport function transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n/**\r\n * Transforms the vec3 with a mat3.\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the vector to transform\r\n * @param {ReadonlyMat3} m the 3x3 matrix to transform with\r\n * @returns {vec3} out\r\n */\n\nexport function transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x * m[0] + y * m[3] + z * m[6];\n  out[1] = x * m[1] + y * m[4] + z * m[7];\n  out[2] = x * m[2] + y * m[5] + z * m[8];\n  return out;\n}\n/**\r\n * Transforms the vec3 with a quat\r\n * Can also be used for dual quaternions. (Multiply it with the real part)\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the vector to transform\r\n * @param {ReadonlyQuat} q quaternion to transform with\r\n * @returns {vec3} out\r\n */\n\nexport function transformQuat(out, a, q) {\n  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3];\n  var x = a[0],\n      y = a[1],\n      z = a[2]; // var qvec = [qx, qy, qz];\n  // var uv = vec3.cross([], qvec, a);\n\n  var uvx = qy * z - qz * y,\n      uvy = qz * x - qx * z,\n      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);\n\n  var uuvx = qy * uvz - qz * uvy,\n      uuvy = qz * uvx - qx * uvz,\n      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);\n\n  var w2 = qw * 2;\n  uvx *= w2;\n  uvy *= w2;\n  uvz *= w2; // vec3.scale(uuv, uuv, 2);\n\n  uuvx *= 2;\n  uuvy *= 2;\n  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));\n\n  out[0] = x + uvx + uuvx;\n  out[1] = y + uvy + uuvy;\n  out[2] = z + uvz + uuvz;\n  return out;\n}\n/**\r\n * Rotate a 3D vector around the x-axis\r\n * @param {vec3} out The receiving vec3\r\n * @param {ReadonlyVec3} a The vec3 point to rotate\r\n * @param {ReadonlyVec3} b The origin of the rotation\r\n * @param {Number} rad The angle of rotation in radians\r\n * @returns {vec3} out\r\n */\n\nexport function rotateX(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0];\n  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);\n  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\r\n * Rotate a 3D vector around the y-axis\r\n * @param {vec3} out The receiving vec3\r\n * @param {ReadonlyVec3} a The vec3 point to rotate\r\n * @param {ReadonlyVec3} b The origin of the rotation\r\n * @param {Number} rad The angle of rotation in radians\r\n * @returns {vec3} out\r\n */\n\nexport function rotateY(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n  r[1] = p[1];\n  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\r\n * Rotate a 3D vector around the z-axis\r\n * @param {vec3} out The receiving vec3\r\n * @param {ReadonlyVec3} a The vec3 point to rotate\r\n * @param {ReadonlyVec3} b The origin of the rotation\r\n * @param {Number} rad The angle of rotation in radians\r\n * @returns {vec3} out\r\n */\n\nexport function rotateZ(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n  r[2] = p[2]; //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\r\n * Get the angle between two 3D vectors\r\n * @param {ReadonlyVec3} a The first operand\r\n * @param {ReadonlyVec3} b The second operand\r\n * @returns {Number} The angle in radians\r\n */\n\nexport function angle(a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      bx = b[0],\n      by = b[1],\n      bz = b[2],\n      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),\n      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),\n      mag = mag1 * mag2,\n      cosine = mag && dot(a, b) / mag;\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\r\n * Set the components of a vec3 to zero\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @returns {vec3} out\r\n */\n\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  return out;\n}\n/**\r\n * Returns a string representation of a vector\r\n *\r\n * @param {ReadonlyVec3} a vector to represent as a string\r\n * @returns {String} string representation of the vector\r\n */\n\nexport function str(a) {\n  return \"vec3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \")\";\n}\n/**\r\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {ReadonlyVec3} a The first vector.\r\n * @param {ReadonlyVec3} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n/**\r\n * Returns whether or not the vectors have approximately the same elements in the same position.\r\n *\r\n * @param {ReadonlyVec3} a The first vector.\r\n * @param {ReadonlyVec3} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));\n}\n/**\r\n * Alias for {@link vec3.subtract}\r\n * @function\r\n */\n\nexport var sub = subtract;\n/**\r\n * Alias for {@link vec3.multiply}\r\n * @function\r\n */\n\nexport var mul = multiply;\n/**\r\n * Alias for {@link vec3.divide}\r\n * @function\r\n */\n\nexport var div = divide;\n/**\r\n * Alias for {@link vec3.distance}\r\n * @function\r\n */\n\nexport var dist = distance;\n/**\r\n * Alias for {@link vec3.squaredDistance}\r\n * @function\r\n */\n\nexport var sqrDist = squaredDistance;\n/**\r\n * Alias for {@link vec3.length}\r\n * @function\r\n */\n\nexport var len = length;\n/**\r\n * Alias for {@link vec3.squaredLength}\r\n * @function\r\n */\n\nexport var sqrLen = squaredLength;\n/**\r\n * Perform some operation over an array of vec3s.\r\n *\r\n * @param {Array} a the array of vectors to iterate over\r\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\r\n * @param {Number} offset Number of elements to skip at the beginning of the array\r\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\r\n * @param {Function} fn Function to call for each vector in the array\r\n * @param {Object} [arg] additional argument to pass to fn\r\n * @returns {Array} a\r\n * @function\r\n */\n\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 3;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n    }\n\n    return a;\n  };\n}();","import * as glMatrix from \"./common.js\";\n/**\r\n * 4 Dimensional Vector\r\n * @module vec4\r\n */\n\n/**\r\n * Creates a new, empty vec4\r\n *\r\n * @returns {vec4} a new 4D vector\r\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(4);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n  }\n\n  return out;\n}\n/**\r\n * Creates a new vec4 initialized with values from an existing vector\r\n *\r\n * @param {ReadonlyVec4} a vector to clone\r\n * @returns {vec4} a new 4D vector\r\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\r\n * Creates a new vec4 initialized with the given values\r\n *\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @param {Number} w W component\r\n * @returns {vec4} a new 4D vector\r\n */\n\nexport function fromValues(x, y, z, w) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n/**\r\n * Copy the values from one vec4 to another\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the source vector\r\n * @returns {vec4} out\r\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\r\n * Set the components of a vec4 to the given values\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @param {Number} w W component\r\n * @returns {vec4} out\r\n */\n\nexport function set(out, x, y, z, w) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n/**\r\n * Adds two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  return out;\n}\n/**\r\n * Subtracts vector b from vector a\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  return out;\n}\n/**\r\n * Multiplies two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  out[3] = a[3] * b[3];\n  return out;\n}\n/**\r\n * Divides two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  out[3] = a[3] / b[3];\n  return out;\n}\n/**\r\n * Math.ceil the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a vector to ceil\r\n * @returns {vec4} out\r\n */\n\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  out[3] = Math.ceil(a[3]);\n  return out;\n}\n/**\r\n * Math.floor the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a vector to floor\r\n * @returns {vec4} out\r\n */\n\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  out[3] = Math.floor(a[3]);\n  return out;\n}\n/**\r\n * Returns the minimum of two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  out[3] = Math.min(a[3], b[3]);\n  return out;\n}\n/**\r\n * Returns the maximum of two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  out[3] = Math.max(a[3], b[3]);\n  return out;\n}\n/**\r\n * Math.round the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a vector to round\r\n * @returns {vec4} out\r\n */\n\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  out[3] = Math.round(a[3]);\n  return out;\n}\n/**\r\n * Scales a vec4 by a scalar number\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the vector to scale\r\n * @param {Number} b amount to scale the vector by\r\n * @returns {vec4} out\r\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  return out;\n}\n/**\r\n * Adds two vec4's after scaling the second operand by a scalar value\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @param {Number} scale the amount to scale b by before adding\r\n * @returns {vec4} out\r\n */\n\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  return out;\n}\n/**\r\n * Calculates the euclidian distance between two vec4's\r\n *\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @returns {Number} distance between a and b\r\n */\n\nexport function distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return Math.hypot(x, y, z, w);\n}\n/**\r\n * Calculates the squared euclidian distance between two vec4's\r\n *\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @returns {Number} squared distance between a and b\r\n */\n\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return x * x + y * y + z * z + w * w;\n}\n/**\r\n * Calculates the length of a vec4\r\n *\r\n * @param {ReadonlyVec4} a vector to calculate length of\r\n * @returns {Number} length of a\r\n */\n\nexport function length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return Math.hypot(x, y, z, w);\n}\n/**\r\n * Calculates the squared length of a vec4\r\n *\r\n * @param {ReadonlyVec4} a vector to calculate squared length of\r\n * @returns {Number} squared length of a\r\n */\n\nexport function squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return x * x + y * y + z * z + w * w;\n}\n/**\r\n * Negates the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a vector to negate\r\n * @returns {vec4} out\r\n */\n\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = -a[3];\n  return out;\n}\n/**\r\n * Returns the inverse of the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a vector to invert\r\n * @returns {vec4} out\r\n */\n\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  out[3] = 1.0 / a[3];\n  return out;\n}\n/**\r\n * Normalize a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a vector to normalize\r\n * @returns {vec4} out\r\n */\n\nexport function normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  var len = x * x + y * y + z * z + w * w;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = x * len;\n  out[1] = y * len;\n  out[2] = z * len;\n  out[3] = w * len;\n  return out;\n}\n/**\r\n * Calculates the dot product of two vec4's\r\n *\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @returns {Number} dot product of a and b\r\n */\n\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n}\n/**\r\n * Returns the cross-product of three vectors in a 4-dimensional space\r\n *\r\n * @param {ReadonlyVec4} result the receiving vector\r\n * @param {ReadonlyVec4} U the first vector\r\n * @param {ReadonlyVec4} V the second vector\r\n * @param {ReadonlyVec4} W the third vector\r\n * @returns {vec4} result\r\n */\n\nexport function cross(out, u, v, w) {\n  var A = v[0] * w[1] - v[1] * w[0],\n      B = v[0] * w[2] - v[2] * w[0],\n      C = v[0] * w[3] - v[3] * w[0],\n      D = v[1] * w[2] - v[2] * w[1],\n      E = v[1] * w[3] - v[3] * w[1],\n      F = v[2] * w[3] - v[3] * w[2];\n  var G = u[0];\n  var H = u[1];\n  var I = u[2];\n  var J = u[3];\n  out[0] = H * F - I * E + J * D;\n  out[1] = -(G * F) + I * C - J * B;\n  out[2] = G * E - H * C + J * A;\n  out[3] = -(G * D) + H * B - I * A;\n  return out;\n}\n/**\r\n * Performs a linear interpolation between two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec4} out\r\n */\n\nexport function lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  var aw = a[3];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  out[3] = aw + t * (b[3] - aw);\n  return out;\n}\n/**\r\n * Generates a random vector with the given scale\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\r\n * @returns {vec4} out\r\n */\n\nexport function random(out, scale) {\n  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a\n  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.\n  // http://projecteuclid.org/euclid.aoms/1177692644;\n\n  var v1, v2, v3, v4;\n  var s1, s2;\n\n  do {\n    v1 = glMatrix.RANDOM() * 2 - 1;\n    v2 = glMatrix.RANDOM() * 2 - 1;\n    s1 = v1 * v1 + v2 * v2;\n  } while (s1 >= 1);\n\n  do {\n    v3 = glMatrix.RANDOM() * 2 - 1;\n    v4 = glMatrix.RANDOM() * 2 - 1;\n    s2 = v3 * v3 + v4 * v4;\n  } while (s2 >= 1);\n\n  var d = Math.sqrt((1 - s1) / s2);\n  out[0] = scale * v1;\n  out[1] = scale * v2;\n  out[2] = scale * v3 * d;\n  out[3] = scale * v4 * d;\n  return out;\n}\n/**\r\n * Transforms the vec4 with a mat4.\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the vector to transform\r\n * @param {ReadonlyMat4} m matrix to transform with\r\n * @returns {vec4} out\r\n */\n\nexport function transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2],\n      w = a[3];\n  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n  return out;\n}\n/**\r\n * Transforms the vec4 with a quat\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the vector to transform\r\n * @param {ReadonlyQuat} q quaternion to transform with\r\n * @returns {vec4} out\r\n */\n\nexport function transformQuat(out, a, q) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3]; // calculate quat * vec\n\n  var ix = qw * x + qy * z - qz * y;\n  var iy = qw * y + qz * x - qx * z;\n  var iz = qw * z + qx * y - qy * x;\n  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat\n\n  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n  out[3] = a[3];\n  return out;\n}\n/**\r\n * Set the components of a vec4 to zero\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @returns {vec4} out\r\n */\n\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  return out;\n}\n/**\r\n * Returns a string representation of a vector\r\n *\r\n * @param {ReadonlyVec4} a vector to represent as a string\r\n * @returns {String} string representation of the vector\r\n */\n\nexport function str(a) {\n  return \"vec4(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \")\";\n}\n/**\r\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {ReadonlyVec4} a The first vector.\r\n * @param {ReadonlyVec4} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n/**\r\n * Returns whether or not the vectors have approximately the same elements in the same position.\r\n *\r\n * @param {ReadonlyVec4} a The first vector.\r\n * @param {ReadonlyVec4} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));\n}\n/**\r\n * Alias for {@link vec4.subtract}\r\n * @function\r\n */\n\nexport var sub = subtract;\n/**\r\n * Alias for {@link vec4.multiply}\r\n * @function\r\n */\n\nexport var mul = multiply;\n/**\r\n * Alias for {@link vec4.divide}\r\n * @function\r\n */\n\nexport var div = divide;\n/**\r\n * Alias for {@link vec4.distance}\r\n * @function\r\n */\n\nexport var dist = distance;\n/**\r\n * Alias for {@link vec4.squaredDistance}\r\n * @function\r\n */\n\nexport var sqrDist = squaredDistance;\n/**\r\n * Alias for {@link vec4.length}\r\n * @function\r\n */\n\nexport var len = length;\n/**\r\n * Alias for {@link vec4.squaredLength}\r\n * @function\r\n */\n\nexport var sqrLen = squaredLength;\n/**\r\n * Perform some operation over an array of vec4s.\r\n *\r\n * @param {Array} a the array of vectors to iterate over\r\n * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed\r\n * @param {Number} offset Number of elements to skip at the beginning of the array\r\n * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array\r\n * @param {Function} fn Function to call for each vector in the array\r\n * @param {Object} [arg] additional argument to pass to fn\r\n * @returns {Array} a\r\n * @function\r\n */\n\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 4;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      vec[3] = a[i + 3];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n      a[i + 3] = vec[3];\n    }\n\n    return a;\n  };\n}();","import * as glMatrix from \"./common.js\";\nimport * as mat3 from \"./mat3.js\";\nimport * as vec3 from \"./vec3.js\";\nimport * as vec4 from \"./vec4.js\";\n/**\r\n * Quaternion\r\n * @module quat\r\n */\n\n/**\r\n * Creates a new identity quat\r\n *\r\n * @returns {quat} a new quaternion\r\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(4);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  out[3] = 1;\n  return out;\n}\n/**\r\n * Set a quat to the identity quaternion\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @returns {quat} out\r\n */\n\nexport function identity(out) {\n  out[0] = 0;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  return out;\n}\n/**\r\n * Sets a quat from the given angle and rotation axis,\r\n * then returns it.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {ReadonlyVec3} axis the axis around which to rotate\r\n * @param {Number} rad the angle in radians\r\n * @returns {quat} out\r\n **/\n\nexport function setAxisAngle(out, axis, rad) {\n  rad = rad * 0.5;\n  var s = Math.sin(rad);\n  out[0] = s * axis[0];\n  out[1] = s * axis[1];\n  out[2] = s * axis[2];\n  out[3] = Math.cos(rad);\n  return out;\n}\n/**\r\n * Gets the rotation axis and angle for a given\r\n *  quaternion. If a quaternion is created with\r\n *  setAxisAngle, this method will return the same\r\n *  values as providied in the original parameter list\r\n *  OR functionally equivalent values.\r\n * Example: The quaternion formed by axis [0, 0, 1] and\r\n *  angle -90 is the same as the quaternion formed by\r\n *  [0, 0, 1] and 270. This method favors the latter.\r\n * @param  {vec3} out_axis  Vector receiving the axis of rotation\r\n * @param  {ReadonlyQuat} q     Quaternion to be decomposed\r\n * @return {Number}     Angle, in radians, of the rotation\r\n */\n\nexport function getAxisAngle(out_axis, q) {\n  var rad = Math.acos(q[3]) * 2.0;\n  var s = Math.sin(rad / 2.0);\n\n  if (s > glMatrix.EPSILON) {\n    out_axis[0] = q[0] / s;\n    out_axis[1] = q[1] / s;\n    out_axis[2] = q[2] / s;\n  } else {\n    // If s is zero, return any axis (no rotation - axis does not matter)\n    out_axis[0] = 1;\n    out_axis[1] = 0;\n    out_axis[2] = 0;\n  }\n\n  return rad;\n}\n/**\r\n * Gets the angular distance between two unit quaternions\r\n *\r\n * @param  {ReadonlyQuat} a     Origin unit quaternion\r\n * @param  {ReadonlyQuat} b     Destination unit quaternion\r\n * @return {Number}     Angle, in radians, between the two quaternions\r\n */\n\nexport function getAngle(a, b) {\n  var dotproduct = dot(a, b);\n  return Math.acos(2 * dotproduct * dotproduct - 1);\n}\n/**\r\n * Multiplies two quat's\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {ReadonlyQuat} a the first operand\r\n * @param {ReadonlyQuat} b the second operand\r\n * @returns {quat} out\r\n */\n\nexport function multiply(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2],\n      bw = b[3];\n  out[0] = ax * bw + aw * bx + ay * bz - az * by;\n  out[1] = ay * bw + aw * by + az * bx - ax * bz;\n  out[2] = az * bw + aw * bz + ax * by - ay * bx;\n  out[3] = aw * bw - ax * bx - ay * by - az * bz;\n  return out;\n}\n/**\r\n * Rotates a quaternion by the given angle about the X axis\r\n *\r\n * @param {quat} out quat receiving operation result\r\n * @param {ReadonlyQuat} a quat to rotate\r\n * @param {number} rad angle (in radians) to rotate\r\n * @returns {quat} out\r\n */\n\nexport function rotateX(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bx = Math.sin(rad),\n      bw = Math.cos(rad);\n  out[0] = ax * bw + aw * bx;\n  out[1] = ay * bw + az * bx;\n  out[2] = az * bw - ay * bx;\n  out[3] = aw * bw - ax * bx;\n  return out;\n}\n/**\r\n * Rotates a quaternion by the given angle about the Y axis\r\n *\r\n * @param {quat} out quat receiving operation result\r\n * @param {ReadonlyQuat} a quat to rotate\r\n * @param {number} rad angle (in radians) to rotate\r\n * @returns {quat} out\r\n */\n\nexport function rotateY(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var by = Math.sin(rad),\n      bw = Math.cos(rad);\n  out[0] = ax * bw - az * by;\n  out[1] = ay * bw + aw * by;\n  out[2] = az * bw + ax * by;\n  out[3] = aw * bw - ay * by;\n  return out;\n}\n/**\r\n * Rotates a quaternion by the given angle about the Z axis\r\n *\r\n * @param {quat} out quat receiving operation result\r\n * @param {ReadonlyQuat} a quat to rotate\r\n * @param {number} rad angle (in radians) to rotate\r\n * @returns {quat} out\r\n */\n\nexport function rotateZ(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bz = Math.sin(rad),\n      bw = Math.cos(rad);\n  out[0] = ax * bw + ay * bz;\n  out[1] = ay * bw - ax * bz;\n  out[2] = az * bw + aw * bz;\n  out[3] = aw * bw - az * bz;\n  return out;\n}\n/**\r\n * Calculates the W component of a quat from the X, Y, and Z components.\r\n * Assumes that quaternion is 1 unit in length.\r\n * Any existing W component will be ignored.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {ReadonlyQuat} a quat to calculate W component of\r\n * @returns {quat} out\r\n */\n\nexport function calculateW(out, a) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));\n  return out;\n}\n/**\r\n * Calculate the exponential of a unit quaternion.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {ReadonlyQuat} a quat to calculate the exponential of\r\n * @returns {quat} out\r\n */\n\nexport function exp(out, a) {\n  var x = a[0],\n      y = a[1],\n      z = a[2],\n      w = a[3];\n  var r = Math.sqrt(x * x + y * y + z * z);\n  var et = Math.exp(w);\n  var s = r > 0 ? et * Math.sin(r) / r : 0;\n  out[0] = x * s;\n  out[1] = y * s;\n  out[2] = z * s;\n  out[3] = et * Math.cos(r);\n  return out;\n}\n/**\r\n * Calculate the natural logarithm of a unit quaternion.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {ReadonlyQuat} a quat to calculate the exponential of\r\n * @returns {quat} out\r\n */\n\nexport function ln(out, a) {\n  var x = a[0],\n      y = a[1],\n      z = a[2],\n      w = a[3];\n  var r = Math.sqrt(x * x + y * y + z * z);\n  var t = r > 0 ? Math.atan2(r, w) / r : 0;\n  out[0] = x * t;\n  out[1] = y * t;\n  out[2] = z * t;\n  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);\n  return out;\n}\n/**\r\n * Calculate the scalar power of a unit quaternion.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {ReadonlyQuat} a quat to calculate the exponential of\r\n * @param {Number} b amount to scale the quaternion by\r\n * @returns {quat} out\r\n */\n\nexport function pow(out, a, b) {\n  ln(out, a);\n  scale(out, out, b);\n  exp(out, out);\n  return out;\n}\n/**\r\n * Performs a spherical linear interpolation between two quat\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {ReadonlyQuat} a the first operand\r\n * @param {ReadonlyQuat} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {quat} out\r\n */\n\nexport function slerp(out, a, b, t) {\n  // benchmarks:\n  //    http://jsperf.com/quaternion-slerp-implementations\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2],\n      bw = b[3];\n  var omega, cosom, sinom, scale0, scale1; // calc cosine\n\n  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)\n\n  if (cosom < 0.0) {\n    cosom = -cosom;\n    bx = -bx;\n    by = -by;\n    bz = -bz;\n    bw = -bw;\n  } // calculate coefficients\n\n\n  if (1.0 - cosom > glMatrix.EPSILON) {\n    // standard case (slerp)\n    omega = Math.acos(cosom);\n    sinom = Math.sin(omega);\n    scale0 = Math.sin((1.0 - t) * omega) / sinom;\n    scale1 = Math.sin(t * omega) / sinom;\n  } else {\n    // \"from\" and \"to\" quaternions are very close\n    //  ... so we can do a linear interpolation\n    scale0 = 1.0 - t;\n    scale1 = t;\n  } // calculate final values\n\n\n  out[0] = scale0 * ax + scale1 * bx;\n  out[1] = scale0 * ay + scale1 * by;\n  out[2] = scale0 * az + scale1 * bz;\n  out[3] = scale0 * aw + scale1 * bw;\n  return out;\n}\n/**\r\n * Generates a random unit quaternion\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @returns {quat} out\r\n */\n\nexport function random(out) {\n  // Implementation of http://planning.cs.uiuc.edu/node198.html\n  // TODO: Calling random 3 times is probably not the fastest solution\n  var u1 = glMatrix.RANDOM();\n  var u2 = glMatrix.RANDOM();\n  var u3 = glMatrix.RANDOM();\n  var sqrt1MinusU1 = Math.sqrt(1 - u1);\n  var sqrtU1 = Math.sqrt(u1);\n  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);\n  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);\n  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);\n  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);\n  return out;\n}\n/**\r\n * Calculates the inverse of a quat\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {ReadonlyQuat} a quat to calculate inverse of\r\n * @returns {quat} out\r\n */\n\nexport function invert(out, a) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n  var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0\n\n  out[0] = -a0 * invDot;\n  out[1] = -a1 * invDot;\n  out[2] = -a2 * invDot;\n  out[3] = a3 * invDot;\n  return out;\n}\n/**\r\n * Calculates the conjugate of a quat\r\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {ReadonlyQuat} a quat to calculate conjugate of\r\n * @returns {quat} out\r\n */\n\nexport function conjugate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\r\n * Creates a quaternion from the given 3x3 rotation matrix.\r\n *\r\n * NOTE: The resultant quaternion is not normalized, so you should be sure\r\n * to renormalize the quaternion yourself where necessary.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {ReadonlyMat3} m rotation matrix\r\n * @returns {quat} out\r\n * @function\r\n */\n\nexport function fromMat3(out, m) {\n  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n  // article \"Quaternion Calculus and Fast Animation\".\n  var fTrace = m[0] + m[4] + m[8];\n  var fRoot;\n\n  if (fTrace > 0.0) {\n    // |w| > 1/2, may as well choose w > 1/2\n    fRoot = Math.sqrt(fTrace + 1.0); // 2w\n\n    out[3] = 0.5 * fRoot;\n    fRoot = 0.5 / fRoot; // 1/(4w)\n\n    out[0] = (m[5] - m[7]) * fRoot;\n    out[1] = (m[6] - m[2]) * fRoot;\n    out[2] = (m[1] - m[3]) * fRoot;\n  } else {\n    // |w| <= 1/2\n    var i = 0;\n    if (m[4] > m[0]) i = 1;\n    if (m[8] > m[i * 3 + i]) i = 2;\n    var j = (i + 1) % 3;\n    var k = (i + 2) % 3;\n    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);\n    out[i] = 0.5 * fRoot;\n    fRoot = 0.5 / fRoot;\n    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;\n    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;\n    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;\n  }\n\n  return out;\n}\n/**\r\n * Creates a quaternion from the given euler angle x, y, z.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {x} Angle to rotate around X axis in degrees.\r\n * @param {y} Angle to rotate around Y axis in degrees.\r\n * @param {z} Angle to rotate around Z axis in degrees.\r\n * @returns {quat} out\r\n * @function\r\n */\n\nexport function fromEuler(out, x, y, z) {\n  var halfToRad = 0.5 * Math.PI / 180.0;\n  x *= halfToRad;\n  y *= halfToRad;\n  z *= halfToRad;\n  var sx = Math.sin(x);\n  var cx = Math.cos(x);\n  var sy = Math.sin(y);\n  var cy = Math.cos(y);\n  var sz = Math.sin(z);\n  var cz = Math.cos(z);\n  out[0] = sx * cy * cz - cx * sy * sz;\n  out[1] = cx * sy * cz + sx * cy * sz;\n  out[2] = cx * cy * sz - sx * sy * cz;\n  out[3] = cx * cy * cz + sx * sy * sz;\n  return out;\n}\n/**\r\n * Returns a string representation of a quatenion\r\n *\r\n * @param {ReadonlyQuat} a vector to represent as a string\r\n * @returns {String} string representation of the vector\r\n */\n\nexport function str(a) {\n  return \"quat(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \")\";\n}\n/**\r\n * Creates a new quat initialized with values from an existing quaternion\r\n *\r\n * @param {ReadonlyQuat} a quaternion to clone\r\n * @returns {quat} a new quaternion\r\n * @function\r\n */\n\nexport var clone = vec4.clone;\n/**\r\n * Creates a new quat initialized with the given values\r\n *\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @param {Number} w W component\r\n * @returns {quat} a new quaternion\r\n * @function\r\n */\n\nexport var fromValues = vec4.fromValues;\n/**\r\n * Copy the values from one quat to another\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {ReadonlyQuat} a the source quaternion\r\n * @returns {quat} out\r\n * @function\r\n */\n\nexport var copy = vec4.copy;\n/**\r\n * Set the components of a quat to the given values\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @param {Number} w W component\r\n * @returns {quat} out\r\n * @function\r\n */\n\nexport var set = vec4.set;\n/**\r\n * Adds two quat's\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {ReadonlyQuat} a the first operand\r\n * @param {ReadonlyQuat} b the second operand\r\n * @returns {quat} out\r\n * @function\r\n */\n\nexport var add = vec4.add;\n/**\r\n * Alias for {@link quat.multiply}\r\n * @function\r\n */\n\nexport var mul = multiply;\n/**\r\n * Scales a quat by a scalar number\r\n *\r\n * @param {quat} out the receiving vector\r\n * @param {ReadonlyQuat} a the vector to scale\r\n * @param {Number} b amount to scale the vector by\r\n * @returns {quat} out\r\n * @function\r\n */\n\nexport var scale = vec4.scale;\n/**\r\n * Calculates the dot product of two quat's\r\n *\r\n * @param {ReadonlyQuat} a the first operand\r\n * @param {ReadonlyQuat} b the second operand\r\n * @returns {Number} dot product of a and b\r\n * @function\r\n */\n\nexport var dot = vec4.dot;\n/**\r\n * Performs a linear interpolation between two quat's\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {ReadonlyQuat} a the first operand\r\n * @param {ReadonlyQuat} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {quat} out\r\n * @function\r\n */\n\nexport var lerp = vec4.lerp;\n/**\r\n * Calculates the length of a quat\r\n *\r\n * @param {ReadonlyQuat} a vector to calculate length of\r\n * @returns {Number} length of a\r\n */\n\nexport var length = vec4.length;\n/**\r\n * Alias for {@link quat.length}\r\n * @function\r\n */\n\nexport var len = length;\n/**\r\n * Calculates the squared length of a quat\r\n *\r\n * @param {ReadonlyQuat} a vector to calculate squared length of\r\n * @returns {Number} squared length of a\r\n * @function\r\n */\n\nexport var squaredLength = vec4.squaredLength;\n/**\r\n * Alias for {@link quat.squaredLength}\r\n * @function\r\n */\n\nexport var sqrLen = squaredLength;\n/**\r\n * Normalize a quat\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {ReadonlyQuat} a quaternion to normalize\r\n * @returns {quat} out\r\n * @function\r\n */\n\nexport var normalize = vec4.normalize;\n/**\r\n * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {ReadonlyQuat} a The first quaternion.\r\n * @param {ReadonlyQuat} b The second quaternion.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nexport var exactEquals = vec4.exactEquals;\n/**\r\n * Returns whether or not the quaternions have approximately the same elements in the same position.\r\n *\r\n * @param {ReadonlyQuat} a The first vector.\r\n * @param {ReadonlyQuat} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nexport var equals = vec4.equals;\n/**\r\n * Sets a quaternion to represent the shortest rotation from one\r\n * vector to another.\r\n *\r\n * Both vectors are assumed to be unit length.\r\n *\r\n * @param {quat} out the receiving quaternion.\r\n * @param {ReadonlyVec3} a the initial vector\r\n * @param {ReadonlyVec3} b the destination vector\r\n * @returns {quat} out\r\n */\n\nexport var rotationTo = function () {\n  var tmpvec3 = vec3.create();\n  var xUnitVec3 = vec3.fromValues(1, 0, 0);\n  var yUnitVec3 = vec3.fromValues(0, 1, 0);\n  return function (out, a, b) {\n    var dot = vec3.dot(a, b);\n\n    if (dot < -0.999999) {\n      vec3.cross(tmpvec3, xUnitVec3, a);\n      if (vec3.len(tmpvec3) < 0.000001) vec3.cross(tmpvec3, yUnitVec3, a);\n      vec3.normalize(tmpvec3, tmpvec3);\n      setAxisAngle(out, tmpvec3, Math.PI);\n      return out;\n    } else if (dot > 0.999999) {\n      out[0] = 0;\n      out[1] = 0;\n      out[2] = 0;\n      out[3] = 1;\n      return out;\n    } else {\n      vec3.cross(tmpvec3, a, b);\n      out[0] = tmpvec3[0];\n      out[1] = tmpvec3[1];\n      out[2] = tmpvec3[2];\n      out[3] = 1 + dot;\n      return normalize(out, out);\n    }\n  };\n}();\n/**\r\n * Performs a spherical linear interpolation with two control points\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {ReadonlyQuat} a the first operand\r\n * @param {ReadonlyQuat} b the second operand\r\n * @param {ReadonlyQuat} c the third operand\r\n * @param {ReadonlyQuat} d the fourth operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {quat} out\r\n */\n\nexport var sqlerp = function () {\n  var temp1 = create();\n  var temp2 = create();\n  return function (out, a, b, c, d, t) {\n    slerp(temp1, a, d, t);\n    slerp(temp2, b, c, t);\n    slerp(out, temp1, temp2, 2 * t * (1 - t));\n    return out;\n  };\n}();\n/**\r\n * Sets the specified quaternion with values corresponding to the given\r\n * axes. Each axis is a vec3 and is expected to be unit length and\r\n * perpendicular to all other specified axes.\r\n *\r\n * @param {ReadonlyVec3} view  the vector representing the viewing direction\r\n * @param {ReadonlyVec3} right the vector representing the local \"right\" direction\r\n * @param {ReadonlyVec3} up    the vector representing the local \"up\" direction\r\n * @returns {quat} out\r\n */\n\nexport var setAxes = function () {\n  var matr = mat3.create();\n  return function (out, view, right, up) {\n    matr[0] = right[0];\n    matr[3] = right[1];\n    matr[6] = right[2];\n    matr[1] = up[0];\n    matr[4] = up[1];\n    matr[7] = up[2];\n    matr[2] = -view[0];\n    matr[5] = -view[1];\n    matr[8] = -view[2];\n    return normalize(out, fromMat3(out, matr));\n  };\n}();","import * as glMatrix from \"./common.js\";\nimport * as quat from \"./quat.js\";\nimport * as mat4 from \"./mat4.js\";\n/**\r\n * Dual Quaternion<br>\r\n * Format: [real, dual]<br>\r\n * Quaternion format: XYZW<br>\r\n * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>\r\n * @module quat2\r\n */\n\n/**\r\n * Creates a new identity dual quat\r\n *\r\n * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]\r\n */\n\nexport function create() {\n  var dq = new glMatrix.ARRAY_TYPE(8);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    dq[0] = 0;\n    dq[1] = 0;\n    dq[2] = 0;\n    dq[4] = 0;\n    dq[5] = 0;\n    dq[6] = 0;\n    dq[7] = 0;\n  }\n\n  dq[3] = 1;\n  return dq;\n}\n/**\r\n * Creates a new quat initialized with values from an existing quaternion\r\n *\r\n * @param {ReadonlyQuat2} a dual quaternion to clone\r\n * @returns {quat2} new dual quaternion\r\n * @function\r\n */\n\nexport function clone(a) {\n  var dq = new glMatrix.ARRAY_TYPE(8);\n  dq[0] = a[0];\n  dq[1] = a[1];\n  dq[2] = a[2];\n  dq[3] = a[3];\n  dq[4] = a[4];\n  dq[5] = a[5];\n  dq[6] = a[6];\n  dq[7] = a[7];\n  return dq;\n}\n/**\r\n * Creates a new dual quat initialized with the given values\r\n *\r\n * @param {Number} x1 X component\r\n * @param {Number} y1 Y component\r\n * @param {Number} z1 Z component\r\n * @param {Number} w1 W component\r\n * @param {Number} x2 X component\r\n * @param {Number} y2 Y component\r\n * @param {Number} z2 Z component\r\n * @param {Number} w2 W component\r\n * @returns {quat2} new dual quaternion\r\n * @function\r\n */\n\nexport function fromValues(x1, y1, z1, w1, x2, y2, z2, w2) {\n  var dq = new glMatrix.ARRAY_TYPE(8);\n  dq[0] = x1;\n  dq[1] = y1;\n  dq[2] = z1;\n  dq[3] = w1;\n  dq[4] = x2;\n  dq[5] = y2;\n  dq[6] = z2;\n  dq[7] = w2;\n  return dq;\n}\n/**\r\n * Creates a new dual quat from the given values (quat and translation)\r\n *\r\n * @param {Number} x1 X component\r\n * @param {Number} y1 Y component\r\n * @param {Number} z1 Z component\r\n * @param {Number} w1 W component\r\n * @param {Number} x2 X component (translation)\r\n * @param {Number} y2 Y component (translation)\r\n * @param {Number} z2 Z component (translation)\r\n * @returns {quat2} new dual quaternion\r\n * @function\r\n */\n\nexport function fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {\n  var dq = new glMatrix.ARRAY_TYPE(8);\n  dq[0] = x1;\n  dq[1] = y1;\n  dq[2] = z1;\n  dq[3] = w1;\n  var ax = x2 * 0.5,\n      ay = y2 * 0.5,\n      az = z2 * 0.5;\n  dq[4] = ax * w1 + ay * z1 - az * y1;\n  dq[5] = ay * w1 + az * x1 - ax * z1;\n  dq[6] = az * w1 + ax * y1 - ay * x1;\n  dq[7] = -ax * x1 - ay * y1 - az * z1;\n  return dq;\n}\n/**\r\n * Creates a dual quat from a quaternion and a translation\r\n *\r\n * @param {ReadonlyQuat2} dual quaternion receiving operation result\r\n * @param {ReadonlyQuat} q a normalized quaternion\r\n * @param {ReadonlyVec3} t tranlation vector\r\n * @returns {quat2} dual quaternion receiving operation result\r\n * @function\r\n */\n\nexport function fromRotationTranslation(out, q, t) {\n  var ax = t[0] * 0.5,\n      ay = t[1] * 0.5,\n      az = t[2] * 0.5,\n      bx = q[0],\n      by = q[1],\n      bz = q[2],\n      bw = q[3];\n  out[0] = bx;\n  out[1] = by;\n  out[2] = bz;\n  out[3] = bw;\n  out[4] = ax * bw + ay * bz - az * by;\n  out[5] = ay * bw + az * bx - ax * bz;\n  out[6] = az * bw + ax * by - ay * bx;\n  out[7] = -ax * bx - ay * by - az * bz;\n  return out;\n}\n/**\r\n * Creates a dual quat from a translation\r\n *\r\n * @param {ReadonlyQuat2} dual quaternion receiving operation result\r\n * @param {ReadonlyVec3} t translation vector\r\n * @returns {quat2} dual quaternion receiving operation result\r\n * @function\r\n */\n\nexport function fromTranslation(out, t) {\n  out[0] = 0;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = t[0] * 0.5;\n  out[5] = t[1] * 0.5;\n  out[6] = t[2] * 0.5;\n  out[7] = 0;\n  return out;\n}\n/**\r\n * Creates a dual quat from a quaternion\r\n *\r\n * @param {ReadonlyQuat2} dual quaternion receiving operation result\r\n * @param {ReadonlyQuat} q the quaternion\r\n * @returns {quat2} dual quaternion receiving operation result\r\n * @function\r\n */\n\nexport function fromRotation(out, q) {\n  out[0] = q[0];\n  out[1] = q[1];\n  out[2] = q[2];\n  out[3] = q[3];\n  out[4] = 0;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  return out;\n}\n/**\r\n * Creates a new dual quat from a matrix (4x4)\r\n *\r\n * @param {quat2} out the dual quaternion\r\n * @param {ReadonlyMat4} a the matrix\r\n * @returns {quat2} dual quat receiving operation result\r\n * @function\r\n */\n\nexport function fromMat4(out, a) {\n  //TODO Optimize this\n  var outer = quat.create();\n  mat4.getRotation(outer, a);\n  var t = new glMatrix.ARRAY_TYPE(3);\n  mat4.getTranslation(t, a);\n  fromRotationTranslation(out, outer, t);\n  return out;\n}\n/**\r\n * Copy the values from one dual quat to another\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {ReadonlyQuat2} a the source dual quaternion\r\n * @returns {quat2} out\r\n * @function\r\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  return out;\n}\n/**\r\n * Set a dual quat to the identity dual quaternion\r\n *\r\n * @param {quat2} out the receiving quaternion\r\n * @returns {quat2} out\r\n */\n\nexport function identity(out) {\n  out[0] = 0;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = 0;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  return out;\n}\n/**\r\n * Set the components of a dual quat to the given values\r\n *\r\n * @param {quat2} out the receiving quaternion\r\n * @param {Number} x1 X component\r\n * @param {Number} y1 Y component\r\n * @param {Number} z1 Z component\r\n * @param {Number} w1 W component\r\n * @param {Number} x2 X component\r\n * @param {Number} y2 Y component\r\n * @param {Number} z2 Z component\r\n * @param {Number} w2 W component\r\n * @returns {quat2} out\r\n * @function\r\n */\n\nexport function set(out, x1, y1, z1, w1, x2, y2, z2, w2) {\n  out[0] = x1;\n  out[1] = y1;\n  out[2] = z1;\n  out[3] = w1;\n  out[4] = x2;\n  out[5] = y2;\n  out[6] = z2;\n  out[7] = w2;\n  return out;\n}\n/**\r\n * Gets the real part of a dual quat\r\n * @param  {quat} out real part\r\n * @param  {ReadonlyQuat2} a Dual Quaternion\r\n * @return {quat} real part\r\n */\n\nexport var getReal = quat.copy;\n/**\r\n * Gets the dual part of a dual quat\r\n * @param  {quat} out dual part\r\n * @param  {ReadonlyQuat2} a Dual Quaternion\r\n * @return {quat} dual part\r\n */\n\nexport function getDual(out, a) {\n  out[0] = a[4];\n  out[1] = a[5];\n  out[2] = a[6];\n  out[3] = a[7];\n  return out;\n}\n/**\r\n * Set the real component of a dual quat to the given quaternion\r\n *\r\n * @param {quat2} out the receiving quaternion\r\n * @param {ReadonlyQuat} q a quaternion representing the real part\r\n * @returns {quat2} out\r\n * @function\r\n */\n\nexport var setReal = quat.copy;\n/**\r\n * Set the dual component of a dual quat to the given quaternion\r\n *\r\n * @param {quat2} out the receiving quaternion\r\n * @param {ReadonlyQuat} q a quaternion representing the dual part\r\n * @returns {quat2} out\r\n * @function\r\n */\n\nexport function setDual(out, q) {\n  out[4] = q[0];\n  out[5] = q[1];\n  out[6] = q[2];\n  out[7] = q[3];\n  return out;\n}\n/**\r\n * Gets the translation of a normalized dual quat\r\n * @param  {vec3} out translation\r\n * @param  {ReadonlyQuat2} a Dual Quaternion to be decomposed\r\n * @return {vec3} translation\r\n */\n\nexport function getTranslation(out, a) {\n  var ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7],\n      bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3];\n  out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\n  out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\n  out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;\n  return out;\n}\n/**\r\n * Translates a dual quat by the given vector\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {ReadonlyQuat2} a the dual quaternion to translate\r\n * @param {ReadonlyVec3} v vector to translate by\r\n * @returns {quat2} out\r\n */\n\nexport function translate(out, a, v) {\n  var ax1 = a[0],\n      ay1 = a[1],\n      az1 = a[2],\n      aw1 = a[3],\n      bx1 = v[0] * 0.5,\n      by1 = v[1] * 0.5,\n      bz1 = v[2] * 0.5,\n      ax2 = a[4],\n      ay2 = a[5],\n      az2 = a[6],\n      aw2 = a[7];\n  out[0] = ax1;\n  out[1] = ay1;\n  out[2] = az1;\n  out[3] = aw1;\n  out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;\n  out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;\n  out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;\n  out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;\n  return out;\n}\n/**\r\n * Rotates a dual quat around the X axis\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {ReadonlyQuat2} a the dual quaternion to rotate\r\n * @param {number} rad how far should the rotation be\r\n * @returns {quat2} out\r\n */\n\nexport function rotateX(out, a, rad) {\n  var bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3],\n      ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7],\n      ax1 = ax * bw + aw * bx + ay * bz - az * by,\n      ay1 = ay * bw + aw * by + az * bx - ax * bz,\n      az1 = az * bw + aw * bz + ax * by - ay * bx,\n      aw1 = aw * bw - ax * bx - ay * by - az * bz;\n  quat.rotateX(out, a, rad);\n  bx = out[0];\n  by = out[1];\n  bz = out[2];\n  bw = out[3];\n  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\n  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\n  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\n  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\n  return out;\n}\n/**\r\n * Rotates a dual quat around the Y axis\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {ReadonlyQuat2} a the dual quaternion to rotate\r\n * @param {number} rad how far should the rotation be\r\n * @returns {quat2} out\r\n */\n\nexport function rotateY(out, a, rad) {\n  var bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3],\n      ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7],\n      ax1 = ax * bw + aw * bx + ay * bz - az * by,\n      ay1 = ay * bw + aw * by + az * bx - ax * bz,\n      az1 = az * bw + aw * bz + ax * by - ay * bx,\n      aw1 = aw * bw - ax * bx - ay * by - az * bz;\n  quat.rotateY(out, a, rad);\n  bx = out[0];\n  by = out[1];\n  bz = out[2];\n  bw = out[3];\n  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\n  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\n  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\n  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\n  return out;\n}\n/**\r\n * Rotates a dual quat around the Z axis\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {ReadonlyQuat2} a the dual quaternion to rotate\r\n * @param {number} rad how far should the rotation be\r\n * @returns {quat2} out\r\n */\n\nexport function rotateZ(out, a, rad) {\n  var bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3],\n      ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7],\n      ax1 = ax * bw + aw * bx + ay * bz - az * by,\n      ay1 = ay * bw + aw * by + az * bx - ax * bz,\n      az1 = az * bw + aw * bz + ax * by - ay * bx,\n      aw1 = aw * bw - ax * bx - ay * by - az * bz;\n  quat.rotateZ(out, a, rad);\n  bx = out[0];\n  by = out[1];\n  bz = out[2];\n  bw = out[3];\n  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\n  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\n  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\n  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\n  return out;\n}\n/**\r\n * Rotates a dual quat by a given quaternion (a * q)\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {ReadonlyQuat2} a the dual quaternion to rotate\r\n * @param {ReadonlyQuat} q quaternion to rotate by\r\n * @returns {quat2} out\r\n */\n\nexport function rotateByQuatAppend(out, a, q) {\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3],\n      ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  out[0] = ax * qw + aw * qx + ay * qz - az * qy;\n  out[1] = ay * qw + aw * qy + az * qx - ax * qz;\n  out[2] = az * qw + aw * qz + ax * qy - ay * qx;\n  out[3] = aw * qw - ax * qx - ay * qy - az * qz;\n  ax = a[4];\n  ay = a[5];\n  az = a[6];\n  aw = a[7];\n  out[4] = ax * qw + aw * qx + ay * qz - az * qy;\n  out[5] = ay * qw + aw * qy + az * qx - ax * qz;\n  out[6] = az * qw + aw * qz + ax * qy - ay * qx;\n  out[7] = aw * qw - ax * qx - ay * qy - az * qz;\n  return out;\n}\n/**\r\n * Rotates a dual quat by a given quaternion (q * a)\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {ReadonlyQuat} q quaternion to rotate by\r\n * @param {ReadonlyQuat2} a the dual quaternion to rotate\r\n * @returns {quat2} out\r\n */\n\nexport function rotateByQuatPrepend(out, q, a) {\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3],\n      bx = a[0],\n      by = a[1],\n      bz = a[2],\n      bw = a[3];\n  out[0] = qx * bw + qw * bx + qy * bz - qz * by;\n  out[1] = qy * bw + qw * by + qz * bx - qx * bz;\n  out[2] = qz * bw + qw * bz + qx * by - qy * bx;\n  out[3] = qw * bw - qx * bx - qy * by - qz * bz;\n  bx = a[4];\n  by = a[5];\n  bz = a[6];\n  bw = a[7];\n  out[4] = qx * bw + qw * bx + qy * bz - qz * by;\n  out[5] = qy * bw + qw * by + qz * bx - qx * bz;\n  out[6] = qz * bw + qw * bz + qx * by - qy * bx;\n  out[7] = qw * bw - qx * bx - qy * by - qz * bz;\n  return out;\n}\n/**\r\n * Rotates a dual quat around a given axis. Does the normalisation automatically\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {ReadonlyQuat2} a the dual quaternion to rotate\r\n * @param {ReadonlyVec3} axis the axis to rotate around\r\n * @param {Number} rad how far the rotation should be\r\n * @returns {quat2} out\r\n */\n\nexport function rotateAroundAxis(out, a, axis, rad) {\n  //Special case for rad = 0\n  if (Math.abs(rad) < glMatrix.EPSILON) {\n    return copy(out, a);\n  }\n\n  var axisLength = Math.hypot(axis[0], axis[1], axis[2]);\n  rad = rad * 0.5;\n  var s = Math.sin(rad);\n  var bx = s * axis[0] / axisLength;\n  var by = s * axis[1] / axisLength;\n  var bz = s * axis[2] / axisLength;\n  var bw = Math.cos(rad);\n  var ax1 = a[0],\n      ay1 = a[1],\n      az1 = a[2],\n      aw1 = a[3];\n  out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\n  out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\n  out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\n  out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\n  var ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7];\n  out[4] = ax * bw + aw * bx + ay * bz - az * by;\n  out[5] = ay * bw + aw * by + az * bx - ax * bz;\n  out[6] = az * bw + aw * bz + ax * by - ay * bx;\n  out[7] = aw * bw - ax * bx - ay * by - az * bz;\n  return out;\n}\n/**\r\n * Adds two dual quat's\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {ReadonlyQuat2} a the first operand\r\n * @param {ReadonlyQuat2} b the second operand\r\n * @returns {quat2} out\r\n * @function\r\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  return out;\n}\n/**\r\n * Multiplies two dual quat's\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {ReadonlyQuat2} a the first operand\r\n * @param {ReadonlyQuat2} b the second operand\r\n * @returns {quat2} out\r\n */\n\nexport function multiply(out, a, b) {\n  var ax0 = a[0],\n      ay0 = a[1],\n      az0 = a[2],\n      aw0 = a[3],\n      bx1 = b[4],\n      by1 = b[5],\n      bz1 = b[6],\n      bw1 = b[7],\n      ax1 = a[4],\n      ay1 = a[5],\n      az1 = a[6],\n      aw1 = a[7],\n      bx0 = b[0],\n      by0 = b[1],\n      bz0 = b[2],\n      bw0 = b[3];\n  out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;\n  out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;\n  out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;\n  out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;\n  out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;\n  out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;\n  out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;\n  out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;\n  return out;\n}\n/**\r\n * Alias for {@link quat2.multiply}\r\n * @function\r\n */\n\nexport var mul = multiply;\n/**\r\n * Scales a dual quat by a scalar number\r\n *\r\n * @param {quat2} out the receiving dual quat\r\n * @param {ReadonlyQuat2} a the dual quat to scale\r\n * @param {Number} b amount to scale the dual quat by\r\n * @returns {quat2} out\r\n * @function\r\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  return out;\n}\n/**\r\n * Calculates the dot product of two dual quat's (The dot product of the real parts)\r\n *\r\n * @param {ReadonlyQuat2} a the first operand\r\n * @param {ReadonlyQuat2} b the second operand\r\n * @returns {Number} dot product of a and b\r\n * @function\r\n */\n\nexport var dot = quat.dot;\n/**\r\n * Performs a linear interpolation between two dual quats's\r\n * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)\r\n *\r\n * @param {quat2} out the receiving dual quat\r\n * @param {ReadonlyQuat2} a the first operand\r\n * @param {ReadonlyQuat2} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {quat2} out\r\n */\n\nexport function lerp(out, a, b, t) {\n  var mt = 1 - t;\n  if (dot(a, b) < 0) t = -t;\n  out[0] = a[0] * mt + b[0] * t;\n  out[1] = a[1] * mt + b[1] * t;\n  out[2] = a[2] * mt + b[2] * t;\n  out[3] = a[3] * mt + b[3] * t;\n  out[4] = a[4] * mt + b[4] * t;\n  out[5] = a[5] * mt + b[5] * t;\n  out[6] = a[6] * mt + b[6] * t;\n  out[7] = a[7] * mt + b[7] * t;\n  return out;\n}\n/**\r\n * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {ReadonlyQuat2} a dual quat to calculate inverse of\r\n * @returns {quat2} out\r\n */\n\nexport function invert(out, a) {\n  var sqlen = squaredLength(a);\n  out[0] = -a[0] / sqlen;\n  out[1] = -a[1] / sqlen;\n  out[2] = -a[2] / sqlen;\n  out[3] = a[3] / sqlen;\n  out[4] = -a[4] / sqlen;\n  out[5] = -a[5] / sqlen;\n  out[6] = -a[6] / sqlen;\n  out[7] = a[7] / sqlen;\n  return out;\n}\n/**\r\n * Calculates the conjugate of a dual quat\r\n * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.\r\n *\r\n * @param {quat2} out the receiving quaternion\r\n * @param {ReadonlyQuat2} a quat to calculate conjugate of\r\n * @returns {quat2} out\r\n */\n\nexport function conjugate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = a[3];\n  out[4] = -a[4];\n  out[5] = -a[5];\n  out[6] = -a[6];\n  out[7] = a[7];\n  return out;\n}\n/**\r\n * Calculates the length of a dual quat\r\n *\r\n * @param {ReadonlyQuat2} a dual quat to calculate length of\r\n * @returns {Number} length of a\r\n * @function\r\n */\n\nexport var length = quat.length;\n/**\r\n * Alias for {@link quat2.length}\r\n * @function\r\n */\n\nexport var len = length;\n/**\r\n * Calculates the squared length of a dual quat\r\n *\r\n * @param {ReadonlyQuat2} a dual quat to calculate squared length of\r\n * @returns {Number} squared length of a\r\n * @function\r\n */\n\nexport var squaredLength = quat.squaredLength;\n/**\r\n * Alias for {@link quat2.squaredLength}\r\n * @function\r\n */\n\nexport var sqrLen = squaredLength;\n/**\r\n * Normalize a dual quat\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {ReadonlyQuat2} a dual quaternion to normalize\r\n * @returns {quat2} out\r\n * @function\r\n */\n\nexport function normalize(out, a) {\n  var magnitude = squaredLength(a);\n\n  if (magnitude > 0) {\n    magnitude = Math.sqrt(magnitude);\n    var a0 = a[0] / magnitude;\n    var a1 = a[1] / magnitude;\n    var a2 = a[2] / magnitude;\n    var a3 = a[3] / magnitude;\n    var b0 = a[4];\n    var b1 = a[5];\n    var b2 = a[6];\n    var b3 = a[7];\n    var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;\n    out[0] = a0;\n    out[1] = a1;\n    out[2] = a2;\n    out[3] = a3;\n    out[4] = (b0 - a0 * a_dot_b) / magnitude;\n    out[5] = (b1 - a1 * a_dot_b) / magnitude;\n    out[6] = (b2 - a2 * a_dot_b) / magnitude;\n    out[7] = (b3 - a3 * a_dot_b) / magnitude;\n  }\n\n  return out;\n}\n/**\r\n * Returns a string representation of a dual quatenion\r\n *\r\n * @param {ReadonlyQuat2} a dual quaternion to represent as a string\r\n * @returns {String} string representation of the dual quat\r\n */\n\nexport function str(a) {\n  return \"quat2(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \", \" + a[6] + \", \" + a[7] + \")\";\n}\n/**\r\n * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {ReadonlyQuat2} a the first dual quaternion.\r\n * @param {ReadonlyQuat2} b the second dual quaternion.\r\n * @returns {Boolean} true if the dual quaternions are equal, false otherwise.\r\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];\n}\n/**\r\n * Returns whether or not the dual quaternions have approximately the same elements in the same position.\r\n *\r\n * @param {ReadonlyQuat2} a the first dual quat.\r\n * @param {ReadonlyQuat2} b the second dual quat.\r\n * @returns {Boolean} true if the dual quats are equal, false otherwise.\r\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3],\n      b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7));\n}","import * as glMatrix from \"./common.js\";\n/**\r\n * 2 Dimensional Vector\r\n * @module vec2\r\n */\n\n/**\r\n * Creates a new, empty vec2\r\n *\r\n * @returns {vec2} a new 2D vector\r\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(2);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n  }\n\n  return out;\n}\n/**\r\n * Creates a new vec2 initialized with values from an existing vector\r\n *\r\n * @param {ReadonlyVec2} a vector to clone\r\n * @returns {vec2} a new 2D vector\r\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(2);\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n/**\r\n * Creates a new vec2 initialized with the given values\r\n *\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @returns {vec2} a new 2D vector\r\n */\n\nexport function fromValues(x, y) {\n  var out = new glMatrix.ARRAY_TYPE(2);\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\r\n * Copy the values from one vec2 to another\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the source vector\r\n * @returns {vec2} out\r\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n/**\r\n * Set the components of a vec2 to the given values\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @returns {vec2} out\r\n */\n\nexport function set(out, x, y) {\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\r\n * Adds two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @returns {vec2} out\r\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  return out;\n}\n/**\r\n * Subtracts vector b from vector a\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @returns {vec2} out\r\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  return out;\n}\n/**\r\n * Multiplies two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @returns {vec2} out\r\n */\n\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  return out;\n}\n/**\r\n * Divides two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @returns {vec2} out\r\n */\n\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  return out;\n}\n/**\r\n * Math.ceil the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a vector to ceil\r\n * @returns {vec2} out\r\n */\n\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  return out;\n}\n/**\r\n * Math.floor the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a vector to floor\r\n * @returns {vec2} out\r\n */\n\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  return out;\n}\n/**\r\n * Returns the minimum of two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @returns {vec2} out\r\n */\n\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  return out;\n}\n/**\r\n * Returns the maximum of two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @returns {vec2} out\r\n */\n\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  return out;\n}\n/**\r\n * Math.round the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a vector to round\r\n * @returns {vec2} out\r\n */\n\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  return out;\n}\n/**\r\n * Scales a vec2 by a scalar number\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the vector to scale\r\n * @param {Number} b amount to scale the vector by\r\n * @returns {vec2} out\r\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  return out;\n}\n/**\r\n * Adds two vec2's after scaling the second operand by a scalar value\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @param {Number} scale the amount to scale b by before adding\r\n * @returns {vec2} out\r\n */\n\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  return out;\n}\n/**\r\n * Calculates the euclidian distance between two vec2's\r\n *\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @returns {Number} distance between a and b\r\n */\n\nexport function distance(a, b) {\n  var x = b[0] - a[0],\n      y = b[1] - a[1];\n  return Math.hypot(x, y);\n}\n/**\r\n * Calculates the squared euclidian distance between two vec2's\r\n *\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @returns {Number} squared distance between a and b\r\n */\n\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0],\n      y = b[1] - a[1];\n  return x * x + y * y;\n}\n/**\r\n * Calculates the length of a vec2\r\n *\r\n * @param {ReadonlyVec2} a vector to calculate length of\r\n * @returns {Number} length of a\r\n */\n\nexport function length(a) {\n  var x = a[0],\n      y = a[1];\n  return Math.hypot(x, y);\n}\n/**\r\n * Calculates the squared length of a vec2\r\n *\r\n * @param {ReadonlyVec2} a vector to calculate squared length of\r\n * @returns {Number} squared length of a\r\n */\n\nexport function squaredLength(a) {\n  var x = a[0],\n      y = a[1];\n  return x * x + y * y;\n}\n/**\r\n * Negates the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a vector to negate\r\n * @returns {vec2} out\r\n */\n\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  return out;\n}\n/**\r\n * Returns the inverse of the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a vector to invert\r\n * @returns {vec2} out\r\n */\n\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  return out;\n}\n/**\r\n * Normalize a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a vector to normalize\r\n * @returns {vec2} out\r\n */\n\nexport function normalize(out, a) {\n  var x = a[0],\n      y = a[1];\n  var len = x * x + y * y;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  return out;\n}\n/**\r\n * Calculates the dot product of two vec2's\r\n *\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @returns {Number} dot product of a and b\r\n */\n\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1];\n}\n/**\r\n * Computes the cross product of two vec2's\r\n * Note that the cross product must by definition produce a 3D vector\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @returns {vec3} out\r\n */\n\nexport function cross(out, a, b) {\n  var z = a[0] * b[1] - a[1] * b[0];\n  out[0] = out[1] = 0;\n  out[2] = z;\n  return out;\n}\n/**\r\n * Performs a linear interpolation between two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec2} out\r\n */\n\nexport function lerp(out, a, b, t) {\n  var ax = a[0],\n      ay = a[1];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  return out;\n}\n/**\r\n * Generates a random vector with the given scale\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\r\n * @returns {vec2} out\r\n */\n\nexport function random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  out[0] = Math.cos(r) * scale;\n  out[1] = Math.sin(r) * scale;\n  return out;\n}\n/**\r\n * Transforms the vec2 with a mat2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the vector to transform\r\n * @param {ReadonlyMat2} m matrix to transform with\r\n * @returns {vec2} out\r\n */\n\nexport function transformMat2(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[2] * y;\n  out[1] = m[1] * x + m[3] * y;\n  return out;\n}\n/**\r\n * Transforms the vec2 with a mat2d\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the vector to transform\r\n * @param {ReadonlyMat2d} m matrix to transform with\r\n * @returns {vec2} out\r\n */\n\nexport function transformMat2d(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[2] * y + m[4];\n  out[1] = m[1] * x + m[3] * y + m[5];\n  return out;\n}\n/**\r\n * Transforms the vec2 with a mat3\r\n * 3rd vector component is implicitly '1'\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the vector to transform\r\n * @param {ReadonlyMat3} m matrix to transform with\r\n * @returns {vec2} out\r\n */\n\nexport function transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[3] * y + m[6];\n  out[1] = m[1] * x + m[4] * y + m[7];\n  return out;\n}\n/**\r\n * Transforms the vec2 with a mat4\r\n * 3rd vector component is implicitly '0'\r\n * 4th vector component is implicitly '1'\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the vector to transform\r\n * @param {ReadonlyMat4} m matrix to transform with\r\n * @returns {vec2} out\r\n */\n\nexport function transformMat4(out, a, m) {\n  var x = a[0];\n  var y = a[1];\n  out[0] = m[0] * x + m[4] * y + m[12];\n  out[1] = m[1] * x + m[5] * y + m[13];\n  return out;\n}\n/**\r\n * Rotate a 2D vector\r\n * @param {vec2} out The receiving vec2\r\n * @param {ReadonlyVec2} a The vec2 point to rotate\r\n * @param {ReadonlyVec2} b The origin of the rotation\r\n * @param {Number} rad The angle of rotation in radians\r\n * @returns {vec2} out\r\n */\n\nexport function rotate(out, a, b, rad) {\n  //Translate point to the origin\n  var p0 = a[0] - b[0],\n      p1 = a[1] - b[1],\n      sinC = Math.sin(rad),\n      cosC = Math.cos(rad); //perform rotation and translate to correct position\n\n  out[0] = p0 * cosC - p1 * sinC + b[0];\n  out[1] = p0 * sinC + p1 * cosC + b[1];\n  return out;\n}\n/**\r\n * Get the angle between two 2D vectors\r\n * @param {ReadonlyVec2} a The first operand\r\n * @param {ReadonlyVec2} b The second operand\r\n * @returns {Number} The angle in radians\r\n */\n\nexport function angle(a, b) {\n  var x1 = a[0],\n      y1 = a[1],\n      x2 = b[0],\n      y2 = b[1],\n      // mag is the product of the magnitudes of a and b\n  mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),\n      // mag &&.. short circuits if mag == 0\n  cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1\n\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\r\n * Set the components of a vec2 to zero\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @returns {vec2} out\r\n */\n\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  return out;\n}\n/**\r\n * Returns a string representation of a vector\r\n *\r\n * @param {ReadonlyVec2} a vector to represent as a string\r\n * @returns {String} string representation of the vector\r\n */\n\nexport function str(a) {\n  return \"vec2(\" + a[0] + \", \" + a[1] + \")\";\n}\n/**\r\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\r\n *\r\n * @param {ReadonlyVec2} a The first vector.\r\n * @param {ReadonlyVec2} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1];\n}\n/**\r\n * Returns whether or not the vectors have approximately the same elements in the same position.\r\n *\r\n * @param {ReadonlyVec2} a The first vector.\r\n * @param {ReadonlyVec2} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1];\n  var b0 = b[0],\n      b1 = b[1];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));\n}\n/**\r\n * Alias for {@link vec2.length}\r\n * @function\r\n */\n\nexport var len = length;\n/**\r\n * Alias for {@link vec2.subtract}\r\n * @function\r\n */\n\nexport var sub = subtract;\n/**\r\n * Alias for {@link vec2.multiply}\r\n * @function\r\n */\n\nexport var mul = multiply;\n/**\r\n * Alias for {@link vec2.divide}\r\n * @function\r\n */\n\nexport var div = divide;\n/**\r\n * Alias for {@link vec2.distance}\r\n * @function\r\n */\n\nexport var dist = distance;\n/**\r\n * Alias for {@link vec2.squaredDistance}\r\n * @function\r\n */\n\nexport var sqrDist = squaredDistance;\n/**\r\n * Alias for {@link vec2.squaredLength}\r\n * @function\r\n */\n\nexport var sqrLen = squaredLength;\n/**\r\n * Perform some operation over an array of vec2s.\r\n *\r\n * @param {Array} a the array of vectors to iterate over\r\n * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed\r\n * @param {Number} offset Number of elements to skip at the beginning of the array\r\n * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array\r\n * @param {Function} fn Function to call for each vector in the array\r\n * @param {Object} [arg] additional argument to pass to fn\r\n * @returns {Array} a\r\n * @function\r\n */\n\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 2;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n    }\n\n    return a;\n  };\n}();","import * as glMatrix from \"./common.js\";\nimport * as mat2 from \"./mat2.js\";\nimport * as mat2d from \"./mat2d.js\";\nimport * as mat3 from \"./mat3.js\";\nimport * as mat4 from \"./mat4.js\";\nimport * as quat from \"./quat.js\";\nimport * as quat2 from \"./quat2.js\";\nimport * as vec2 from \"./vec2.js\";\nimport * as vec3 from \"./vec3.js\";\nimport * as vec4 from \"./vec4.js\";\nexport { glMatrix, mat2, mat2d, mat3, mat4, quat, quat2, vec2, vec3, vec4 };"],"sourceRoot":""}