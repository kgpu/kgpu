package io.github.kgpu.wgpuj.jni;

/** NOTE: THIS FILE WAS PRE-GENERATED BY JNR_GEN! */
public final class Wgpu {

    public static final int MAX_BIND_GROUPS = 8;
    public static final int MAX_COLOR_TARGETS = 4;
    public static final int MAX_MIP_LEVELS = 16;
    public static final int MAX_VERTEX_BUFFERS = 16;
    public static final int MAX_ANISOTROPY = 16;
    public static final int SHADER_STAGE_COUNT = 3;
    public static final int DESIRED_NUM_FRAMES = 3;
    /**
     * Buffer-Texture copies must have [`bytes_per_row`] aligned to this number.
     *
     * <p>This doesn't apply to [`Queue::write_texture`].
     *
     * <p>[`bytes_per_row`]: TextureDataLayout::bytes_per_row
     */
    public static final int COPY_BYTES_PER_ROW_ALIGNMENT = 256;
    /** Alignment all push constants need */
    public static final int PUSH_CONSTANT_ALIGNMENT = 4;
    /** Bound uniform/storage buffer offsets must be aligned to this number. */
    public static final int BIND_BUFFER_ALIGNMENT = 256;
    /** Buffer to buffer copy offsets and sizes must be aligned to this number. */
    public static final int COPY_BUFFER_ALIGNMENT = 4;
    /** Vertex buffer strides have to be aligned to this number. */
    public static final int VERTEX_STRIDE_ALIGNMENT = 4;

    public static final class Features {
        /**
         * By default, polygon depth is clipped to 0-1 range. Anything outside of that range is
         * rejected, and respective fragments are not touched.
         *
         * <p>With this extension, we can force clamping of the polygon depth to 0-1. That allows
         * shadow map occluders to be rendered into a tighter depth range.
         *
         * <p>Supported platforms: - desktops - some mobile chips
         *
         * <p>This is a web and native feature.
         */
        public static final int DEPTH_CLAMPING = 1;
        /**
         * Enables BCn family of compressed textures. All BCn textures use 4x4 pixel blocks with 8
         * or 16 bytes per block.
         *
         * <p>Compressed textures sacrifice some quality in exchange for signifigantly reduced
         * bandwidth usage.
         *
         * <p>Supported Platforms: - desktops
         *
         * <p>This is a web and native feature.
         */
        public static final int TEXTURE_COMPRESSION_BC = 2;
        /**
         * Webgpu only allows the MAP_READ and MAP_WRITE buffer usage to be matched with COPY_DST
         * and COPY_SRC respectively. This removes this requirement.
         *
         * <p>This is only beneficial on systems that share memory between CPU and GPU. If enabled
         * on a system that doesn't, this can severely hinder performance. Only use if you
         * understand the consequences.
         *
         * <p>Supported platforms: - All
         *
         * <p>This is a native only feature.
         */
        public static final int MAPPABLE_PRIMARY_BUFFERS = 65536;
        /**
         * Allows the user to create uniform arrays of sampled textures in shaders:
         *
         * <p>eg. `uniform texture2D textures[10]`.
         *
         * <p>This capability allows them to exist and to be indexed by compile time constant
         * values.
         *
         * <p>Supported platforms: - DX12 - Metal (with MSL 2.0+ on macOS 10.13+) - Vulkan
         *
         * <p>This is a native only feature.
         */
        public static final int SAMPLED_TEXTURE_BINDING_ARRAY = 131072;
        /**
         * Allows shaders to index sampled texture arrays with dynamically uniform values:
         *
         * <p>eg. `texture_array[uniform_value]`
         *
         * <p>This capability means the hardware will also support SAMPLED_TEXTURE_BINDING_ARRAY.
         *
         * <p>Supported platforms: - DX12 - Metal (with MSL 2.0+ on macOS 10.13+) - Vulkan's
         * shaderSampledImageArrayDynamicIndexing feature
         *
         * <p>This is a native only feature.
         */
        public static final int SAMPLED_TEXTURE_ARRAY_DYNAMIC_INDEXING = 262144;
        /**
         * Allows shaders to index sampled texture arrays with dynamically non-uniform values:
         *
         * <p>eg. `texture_array[vertex_data]`
         *
         * <p>In order to use this capability, the corresponding GLSL extension must be enabled like
         * so:
         *
         * <p>`#extension GL_EXT_nonuniform_qualifier : require`
         *
         * <p>and then used either as `nonuniformEXT` qualifier in variable declaration:
         *
         * <p>eg. `layout(location = 0) nonuniformEXT flat in int vertex_data;`
         *
         * <p>or as `nonuniformEXT` constructor:
         *
         * <p>eg. `texture_array[nonuniformEXT(vertex_data)]`
         *
         * <p>HLSL does not need any extension.
         *
         * <p>This capability means the hardware will also support
         * SAMPLED_TEXTURE_ARRAY_DYNAMIC_INDEXING and SAMPLED_TEXTURE_BINDING_ARRAY.
         *
         * <p>Supported platforms: - DX12 - Metal (with MSL 2.0+ on macOS 10.13+) - Vulkan 1.2+ (or
         * VK_EXT_descriptor_indexing)'s shaderSampledImageArrayNonUniformIndexing feature)
         *
         * <p>This is a native only feature.
         */
        public static final int SAMPLED_TEXTURE_ARRAY_NON_UNIFORM_INDEXING = 524288;
        /**
         * Allows the user to create unsized uniform arrays of bindings:
         *
         * <p>eg. `uniform texture2D textures[]`.
         *
         * <p>If this capability is supported, SAMPLED_TEXTURE_ARRAY_NON_UNIFORM_INDEXING is very
         * likely to also be supported
         *
         * <p>Supported platforms: - DX12 - Vulkan 1.2+ (or VK_EXT_descriptor_indexing)'s
         * runtimeDescriptorArray feature
         *
         * <p>This is a native only feature.
         */
        public static final int UNSIZED_BINDING_ARRAY = 1048576;
        /**
         * Allows the user to call [`RenderPass::multi_draw_indirect`] and
         * [`RenderPass::multi_draw_indexed_indirect`].
         *
         * <p>Allows multiple indirect calls to be dispatched from a single buffer.
         *
         * <p>Supported platforms: - DX12 - Metal - Vulkan
         *
         * <p>This is a native only feature.
         */
        public static final int MULTI_DRAW_INDIRECT = 2097152;
        /**
         * Allows the user to call [`RenderPass::multi_draw_indirect_count`] and
         * [`RenderPass::multi_draw_indexed_indirect_count`].
         *
         * <p>This allows the use of a buffer containing the actual number of draw calls.
         *
         * <p>Supported platforms: - DX12 - Vulkan 1.2+ (or VK_KHR_draw_indirect_count)
         *
         * <p>This is a native only feature.
         */
        public static final int MULTI_DRAW_INDIRECT_COUNT = 4194304;
        /**
         * Allows the use of push constants: small, fast bits of memory that can be updated inside a
         * [`RenderPass`].
         *
         * <p>Allows the user to call [`RenderPass::set_push_constants`], provide a non-empty array
         * to [`PipelineLayoutDescriptor`], and provide a non-zero limit to
         * [`Limits::max_push_constant_size`].
         *
         * <p>A block of push constants can be declared with `layout(push_constant) uniform Name
         * {..}` in shaders.
         *
         * <p>Supported platforms: - DX12 - Vulkan - Metal - DX11 (emulated with uniforms) - OpenGL
         * (emulated with uniforms)
         *
         * <p>This is a native only feature.
         */
        public static final int PUSH_CONSTANTS = 8388608;
        /**
         * Allows the use of [`AddressMode::ClampToBorder`].
         *
         * <p>Supported platforms: - DX12 - Vulkan - Metal (macOS 10.12+ only) - DX11 - OpenGL
         *
         * <p>This is a web and native feature.
         */
        public static final int ADDRESS_MODE_CLAMP_TO_BORDER = 16777216;
        /**
         * Allows the user to set a non-fill polygon mode in
         * [`RasterizationStateDescriptor::polygon_mode`]
         *
         * <p>This allows drawing polygons/triangles as lines (wireframe) or points instead of
         * filled
         *
         * <p>Supported platforms: - DX12 - Vulkan
         *
         * <p>This is a native only feature.
         */
        public static final int NON_FILL_POLYGON_MODE = 33554432;
        /** Features which are part of the upstream WebGPU standard. */
        public static final int ALL_WEBGPU = 65535;
        /** Features that are only available when targeting native (not web). */
        public static final long ALL_NATIVE = Long.parseUnsignedLong("18446744073709486080");
    }

    public static final class ShaderStage {
        /** Binding is not visible from any shader stage. */
        public static final int NONE = 0;
        /** Binding is visible from the vertex shader of a render pipeline. */
        public static final int VERTEX = 1;
        /** Binding is visible from the fragment shader of a render pipeline. */
        public static final int FRAGMENT = 2;
        /** Binding is visible from the compute shader of a compute pipeline. */
        public static final int COMPUTE = 4;
    }

    public static final class ColorWrite {
        /** Enable red channel writes */
        public static final int RED = 1;
        /** Enable green channel writes */
        public static final int GREEN = 2;
        /** Enable blue channel writes */
        public static final int BLUE = 4;
        /** Enable alpha channel writes */
        public static final int ALPHA = 8;
        /** Enable red, green, and blue channel writes */
        public static final int COLOR = 7;
        /** Enable writes to all channels. */
        public static final int ALL = 15;
    }

    public static final class BufferUsage {
        /**
         * Allow a buffer to be mapped for reading using [`Buffer::map_async`] +
         * [`Buffer::get_mapped_range`]. This does not include creating a buffer with
         * [`BufferDescriptor::mapped_at_creation`] set.
         *
         * <p>If [`Features::MAPPABLE_PRIMARY_BUFFERS`] isn't enabled, the only other usage a buffer
         * may have is COPY_DST.
         */
        public static final int MAP_READ = 1;
        /**
         * Allow a buffer to be mapped for writing using [`Buffer::map_async`] +
         * [`Buffer::get_mapped_range_mut`]. This does not include creating a buffer with
         * `mapped_at_creation` set.
         *
         * <p>If [`Features::MAPPABLE_PRIMARY_BUFFERS`] feature isn't enabled, the only other usage
         * a buffer may have is COPY_SRC.
         */
        public static final int MAP_WRITE = 2;
        /**
         * Allow a buffer to be the source buffer for a [`CommandEncoder::copy_buffer_to_buffer`] or
         * [`CommandEncoder::copy_buffer_to_texture`] operation.
         */
        public static final int COPY_SRC = 4;
        /**
         * Allow a buffer to be the destination buffer for a
         * [`CommandEncoder::copy_buffer_to_buffer`], [`CommandEncoder::copy_texture_to_buffer`], or
         * [`Queue::write_buffer`] operation.
         */
        public static final int COPY_DST = 8;
        /** Allow a buffer to be the index buffer in a draw operation. */
        public static final int INDEX = 16;
        /** Allow a buffer to be the vertex buffer in a draw operation. */
        public static final int VERTEX = 32;
        /** Allow a buffer to be a [`BufferBindingType::Uniform`] inside a bind group. */
        public static final int UNIFORM = 64;
        /** Allow a buffer to be a [`BufferBindingType::Storage`] inside a bind group. */
        public static final int STORAGE = 128;
        /** Allow a buffer to be the indirect buffer in an indirect draw call. */
        public static final int INDIRECT = 256;
    }

    public static final class TextureUsage {
        /**
         * Allows a texture to be the source in a [`CommandEncoder::copy_texture_to_buffer`] or
         * [`CommandEncoder::copy_texture_to_texture`] operation.
         */
        public static final int COPY_SRC = 1;
        /**
         * Allows a texture to be the destination in a [`CommandEncoder::copy_texture_to_buffer`],
         * [`CommandEncoder::copy_texture_to_texture`], or [`Queue::write_texture`] operation.
         */
        public static final int COPY_DST = 2;
        /** Allows a texture to be a [`BindingType::Texture`] in a bind group. */
        public static final int SAMPLED = 4;
        /** Allows a texture to be a [`BindingType::StorageTexture`] in a bind group. */
        public static final int STORAGE = 8;
        /** Allows a texture to be an output attachment of a renderpass. */
        public static final int RENDER_ATTACHMENT = 16;
    }
}
